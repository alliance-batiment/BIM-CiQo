{"version":3,"file":"221.bundle.js","mappings":"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","sources":["webpack://ciqo/./node_modules/react-merge-refs/src/index.tsx","webpack://ciqo/./node_modules/react-vtree/dist/es/utils.js","webpack://ciqo/./node_modules/react-vtree/dist/es/Tree.js","webpack://ciqo/./node_modules/react-vtree/dist/es/FixedSizeTree.js","webpack://ciqo/./node_modules/react-vtree/dist/es/VariableSizeTree.js"],"sourcesContent":["import * as React from \"react\";\n\nexport default function mergeRefs<T = any>(\n  refs: Array<React.MutableRefObject<T> | React.LegacyRef<T>>\n): React.RefCallback<T> {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        (ref as React.MutableRefObject<T | null>).current = value;\n      }\n    });\n  };\n}\n","// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport var noop = function noop() {};\nexport var identity = function identity(value) {\n  return value;\n};\nexport var createBasicRecord = function createBasicRecord(pub, parent) {\n  if (parent === void 0) {\n    parent = null;\n  }\n\n  return {\n    child: null,\n    isShown: parent ? parent.public.isOpen && parent.isShown : true,\n    parent: parent,\n    public: pub,\n    sibling: null,\n    visited: false\n  };\n};\nexport var getIdByIndex = function getIdByIndex(index, _ref) {\n  var getRecordData = _ref.getRecordData;\n\n  var _getRecordData = getRecordData(index),\n      id = _getRecordData.data.id;\n\n  return id;\n};","import _extends from \"@babel/runtime/helpers/extends\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inheritsLoose from \"@babel/runtime/helpers/inheritsLoose\";\n\n/* eslint-disable no-labels,max-depth,complexity */\nimport React, { createRef, PureComponent } from 'react';\nimport mergeRefs from 'react-merge-refs';\nimport { noop } from './utils';\n// eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/prefer-readonly-parameter-types\nexport var Row = function Row(_ref) {\n  var index = _ref.index,\n      _ref$data = _ref.data,\n      Node = _ref$data.component,\n      getRecordData = _ref$data.getRecordData,\n      treeData = _ref$data.treeData,\n      style = _ref.style,\n      isScrolling = _ref.isScrolling;\n  var data = getRecordData(index);\n  return /*#__PURE__*/React.createElement(Node, Object.assign({\n    isScrolling: isScrolling,\n    style: style,\n    treeData: treeData\n  }, data));\n};\n\n// If refresh is required, we will run the TreeWalker. It will completely\n// update all requests and reset every state to default.\nvar generateNewTree = function generateNewTree(_ref2, _ref3, state) {\n  var createRecord = _ref2.createRecord;\n  var buildingTaskTimeout = _ref3.buildingTaskTimeout,\n      placeholder = _ref3.placeholder,\n      _ref3$async = _ref3.async,\n      async = _ref3$async === void 0 ? false : _ref3$async,\n      treeWalker = _ref3.treeWalker;\n  var shouldPreservePreviousState = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  async && state.records !== undefined;\n  var previousRecords = state.records;\n  var order = [];\n  var records = new Map();\n  var requestIdleCallbackOptions = buildingTaskTimeout ? {\n    timeout: buildingTaskTimeout\n  } : undefined;\n  var meta = new WeakMap();\n  var iter = treeWalker();\n\n  var _iter$next = iter.next(),\n      root = _iter$next.value; // Each record has a link to a parent, the next sibling and the next child.\n  // Having this info, we can perform a depth-first traverse.\n\n\n  var rootRecord = createRecord(root.data, state, undefined, shouldPreservePreviousState ? previousRecords.get(root.data.id) : undefined);\n  records.set(rootRecord.public.data.id, rootRecord);\n  meta.set(rootRecord, root);\n  var currentRecord = rootRecord;\n  var isTraversingRoot = true;\n  var tempRecord = rootRecord;\n  var useIdleCallback = typeof 'requestIdleCallback' !== 'undefined' && placeholder !== undefined && // If placeholder is set to null and this is the first build, idle callback\n  // won't be used. It is necessary for trees with async data which can be\n  // extremely complex but the first build is quite easy. During the following\n  // idle callbacks the old tree will be shown.\n  !(placeholder === null && !state.order);\n  var hasTime = useIdleCallback ? function (deadline) {\n    return deadline.timeRemaining() > 0;\n  } : function () {\n    return true;\n  };\n\n  var task = function task(deadline) {\n    while (currentRecord !== null) {\n      if (!hasTime(deadline)) {\n        requestIdleCallback(task, requestIdleCallbackOptions);\n        return;\n      }\n\n      if (!currentRecord.visited) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        var _iter$next2 = iter.next(meta.get(currentRecord)),\n            child = _iter$next2.value; // When the generator returns the undefined value we consider that all\n        // children are already sent and we need to select the new parent\n        // element to get its children.\n\n\n        if (child === undefined) {\n          if (isTraversingRoot) {\n            isTraversingRoot = false;\n          } else {\n            if (currentRecord.isShown) {\n              order.push(currentRecord.public.data.id);\n            }\n\n            currentRecord.visited = currentRecord.child !== null;\n            currentRecord = currentRecord.child !== null ? currentRecord.child : currentRecord.sibling !== null ? currentRecord.sibling : currentRecord.parent;\n          }\n\n          tempRecord = currentRecord;\n          continue;\n        }\n\n        var childRecord = createRecord(child.data, state, isTraversingRoot ? undefined : currentRecord, shouldPreservePreviousState ? previousRecords.get(child.data.id) : undefined);\n        records.set(childRecord.public.data.id, childRecord);\n        meta.set(childRecord, child);\n\n        if (!isTraversingRoot && tempRecord === currentRecord) {\n          tempRecord.child = childRecord;\n        } else {\n          tempRecord.sibling = childRecord;\n        }\n\n        tempRecord = childRecord;\n      } else {\n        currentRecord.visited = false;\n        currentRecord = currentRecord.sibling !== null ? currentRecord.sibling : currentRecord.parent;\n        tempRecord = currentRecord;\n      }\n    }\n\n    if (useIdleCallback) {\n      state.setState({\n        order: order,\n        records: records,\n        updateRequest: {}\n      });\n    }\n  };\n\n  if (useIdleCallback) {\n    requestIdleCallback(task, requestIdleCallbackOptions);\n  } else {\n    task();\n  } // If we want to preserve the previous state and use the requestIdleCallback,\n  // we need to return the old state.\n\n\n  return placeholder !== undefined && async && state.order ? state : {\n    order: order,\n    records: records\n  };\n};\n\nvar MAX_FUNCTION_ARGUMENTS = 32768;\nvar SPLICE_DEFAULT_ARGUMENTS_NUMBER = 2; // If we need to perform only the update, treeWalker won't be used. Update will\n// work internally, traversing only the subtree of elements that require\n// update through the opennessState option.\n\nvar updateExistingTree = function updateExistingTree(_ref4, _ref5) {\n  var order = _ref4.order,\n      records = _ref4.records;\n  var opennessState = _ref5.opennessState;\n\n  if (typeof opennessState !== 'object') {\n    return null;\n  }\n\n  for (var id in opennessState) {\n    if (!records.has(id)) {\n      continue;\n    }\n\n    var opts = opennessState[id];\n    var ownerRecord = records.get(id); // Here we unify the shape of openness state options\n\n    var _ref6 = typeof opts === 'boolean' ? {\n      open: opts\n    } : opts,\n        open = _ref6.open,\n        _ref6$subtreeCallback = _ref6.subtreeCallback,\n        subtreeCallback = _ref6$subtreeCallback === void 0 ? noop : _ref6$subtreeCallback;\n\n    var update = noop;\n    var apply = noop;\n\n    if (ownerRecord.isShown) {\n      if (open) {\n        (function () {\n          // If received rules require us to open the subtree, we have 2 cases:\n          // 1. The node is not opened yet. In this case we simply have to\n          // calculate and add new ids.\n          // 2. The node is opened already. In this case we have to remove all\n          // existing ids and replace them with new ids.\n          var index = order.indexOf(id); // Here we calculate a count of visible subtree nodes to remove from\n          // `order`. Then we will replace the gap with the updated list of\n          // subtree nodes.\n\n          var recordNextToSubtree = ownerRecord;\n\n          while (recordNextToSubtree !== null) {\n            if (recordNextToSubtree.sibling !== null) {\n              recordNextToSubtree = recordNextToSubtree.sibling;\n              break;\n            }\n\n            recordNextToSubtree = recordNextToSubtree.parent;\n          }\n\n          var countToRemove = recordNextToSubtree === null ? order.length - 1 - index : order.indexOf(recordNextToSubtree.public.data.id) - 1 - index;\n          var orderParts = [[index + 1, countToRemove]]; // Unfortunately, splice cannot work with big arrays. If array exceeds\n          // some length it may fire an exception. The length is specific for\n          // each engine; e.g., MDN says about 65536 for Webkit. So, to avoid this\n          // overflow, I split `order` parts to chunks by 32768 elements in each\n          // one. These chunks will be sent as arguments to the `splice` method.\n          //\n          // To avoid array concatenations which may cause Major GC, I set two\n          // first arguments as `splice`'s `start` and `deleteCount` arguments.\n\n          update = function update(record) {\n            // We have to consider only the newly shown elements that are not in\n            // the order list yet. We should do it AFTER the visibility update\n            // happens because otherwise we won't be able to distinguish if the\n            // element should be included in the order list.\n            // Update record visibility\n            record.isShown = record.parent ? record.parent.public.isOpen && record.parent.isShown : true;\n\n            if (record.isShown) {\n              var currentOrderPart = orderParts[orderParts.length - 1];\n              currentOrderPart.push(record.public.data.id);\n\n              if (currentOrderPart.length === MAX_FUNCTION_ARGUMENTS + SPLICE_DEFAULT_ARGUMENTS_NUMBER) {\n                orderParts.push([index + 1 + MAX_FUNCTION_ARGUMENTS * orderParts.length, 0]);\n              }\n            }\n          };\n\n          apply = function apply() {\n            for (var i = 0; i < orderParts.length; i++) {\n              var _ref7;\n\n              // @ts-expect-error: too generic for TS\n              (_ref7 = order).splice.apply(_ref7, orderParts[i]);\n            }\n          };\n        })();\n      } else if (ownerRecord.public.isOpen) {\n        (function () {\n          // If received rules require us to close the subtree, we have to remove\n          // all subtree ids from the order list.\n          var index = order.indexOf(id);\n          var count = 0;\n\n          update = function update(record) {\n            // We have to consider only currently visible subtree nodes BEFORE\n            // their visibility is updated. Otherwise we will have incorrect\n            // number of items to remove: we cannot remove elements that are not\n            // in the order list.\n            //\n            // If we do it after the visibility update, we will be unable to\n            // understand if the element is still in the order list.\n            if (record.isShown) {\n              count += 1;\n            } // Update record visibility\n\n\n            record.isShown = record.parent ? record.parent.public.isOpen && record.parent.isShown : true;\n          };\n\n          apply = function apply() {\n            // Remove data after element with index\n            order.splice(index + 1, count);\n          };\n        })();\n      }\n    }\n\n    var currentRecord = ownerRecord;\n\n    while (currentRecord !== null) {\n      if (!currentRecord.visited) {\n        currentRecord.public.isOpen = currentRecord === ownerRecord ? open : currentRecord.public.isOpen;\n        subtreeCallback(currentRecord.public, ownerRecord.public);\n\n        if (currentRecord !== ownerRecord) {\n          update(currentRecord);\n        }\n\n        currentRecord.visited = currentRecord.child !== null; // This algorithm is a bit different from the visit algorithm in the\n        // tree generator. We are restricted with the bounds of a subtree and\n        // shouldn't go over it. So we cannot search for the ownerRecord's\n        // parent or sibling because it will lead us out of the subtree.\n\n        currentRecord = // Look for child in any case\n        currentRecord.child !== null ? currentRecord.child : // Stop looking for next element if currentRecord is root.\n        currentRecord === ownerRecord ? null : // Otherwise, look for sibling or parent\n        currentRecord.sibling !== null ? currentRecord.sibling : currentRecord.parent;\n      } else {\n        currentRecord.visited = false;\n        currentRecord = currentRecord === ownerRecord ? null : currentRecord.sibling !== null ? currentRecord.sibling : currentRecord.parent;\n      }\n    }\n\n    apply();\n  }\n\n  return {\n    order: order,\n    records: records,\n    updateRequest: {}\n  };\n};\n\nexport var createTreeComputer = function createTreeComputer(creatorOptions) {\n  return function (props, state, options) {\n    return options.refresh ? generateNewTree(creatorOptions, props, state) : updateExistingTree(state, options);\n  };\n};\n\nvar Tree = /*#__PURE__*/function (_PureComponent) {\n  _inheritsLoose(Tree, _PureComponent);\n\n  Tree.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    var _props$listRef = props.listRef,\n        listRef = _props$listRef === void 0 ? null : _props$listRef,\n        treeWalker = props.treeWalker;\n    var computeTree = state.computeTree,\n        list = state.list,\n        order = state.order,\n        oldTreeWalker = state.treeWalker;\n    return _extends({\n      attachRefs: mergeRefs([list, listRef])\n    }, treeWalker !== oldTreeWalker || !order ? computeTree(props, state, {\n      refresh: true\n    }) : null, {\n      treeWalker: treeWalker\n    });\n  };\n\n  function Tree(props, context) {\n    var _this;\n\n    _this = _PureComponent.call(this, props, context) || this;\n    _this.getRecordData = _this.getRecordData.bind(_assertThisInitialized(_this));\n    /* eslint-disable react/no-unused-state,@typescript-eslint/consistent-type-assertions */\n\n    _this.state = {\n      list: /*#__PURE__*/createRef(),\n      recomputeTree: _this.recomputeTree.bind(_assertThisInitialized(_this)),\n      setState: _this.setState.bind(_assertThisInitialized(_this))\n    };\n    /* eslint-enable react/no-unused-state,@typescript-eslint/consistent-type-assertions */\n\n    return _this;\n  }\n\n  var _proto = Tree.prototype;\n\n  _proto.getItemData = function getItemData() {\n    var _this$props = this.props,\n        component = _this$props.children,\n        treeData = _this$props.itemData;\n    return {\n      component: component,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      getRecordData: this.getRecordData,\n      treeData: treeData\n    };\n  };\n\n  _proto.getRecordData = function getRecordData(index) {\n    var _this$state = this.state,\n        order = _this$state.order,\n        records = _this$state.records;\n    return records.get(order[index]).public;\n  };\n\n  _proto.recomputeTree = function recomputeTree(state) {\n    var _this2 = this;\n\n    return new Promise(function (resolve) {\n      _this2.setState(function (prevState) {\n        return prevState.computeTree(_this2.props, prevState, {\n          opennessState: state\n        });\n      }, resolve);\n    });\n  };\n\n  _proto.scrollTo = function scrollTo(scrollOffset) {\n    var _this$state$list$curr;\n\n    // eslint-disable-next-line react/destructuring-assignment\n    (_this$state$list$curr = this.state.list.current) == null ? void 0 : _this$state$list$curr.scrollTo(scrollOffset);\n  };\n\n  _proto.scrollToItem = function scrollToItem(id, align) {\n    var _this$state$list$curr2;\n\n    // eslint-disable-next-line react/destructuring-assignment\n    (_this$state$list$curr2 = this.state.list.current) == null ? void 0 : _this$state$list$curr2.scrollToItem(this.state.order.indexOf(id), align);\n  };\n\n  return Tree;\n}(PureComponent);\n\nTree.defaultProps = {\n  rowComponent: Row\n};\nexport default Tree;","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/inheritsLoose\";\nimport React from 'react';\nimport { FixedSizeList } from 'react-window';\nimport Tree, { createTreeComputer } from './Tree';\nimport { createBasicRecord, getIdByIndex } from './utils';\nvar computeTree = createTreeComputer({\n  createRecord: function createRecord(data, _ref, parent, previousRecord) {\n    var recomputeTree = _ref.recomputeTree;\n    return createBasicRecord({\n      data: data,\n      isOpen: previousRecord ? previousRecord.public.isOpen : data.isOpenByDefault,\n      setOpen: function setOpen(state) {\n        var _recomputeTree;\n\n        return recomputeTree((_recomputeTree = {}, _recomputeTree[data.id] = state, _recomputeTree));\n      }\n    }, parent);\n  }\n});\nexport var FixedSizeTree = /*#__PURE__*/function (_Tree) {\n  _inheritsLoose(FixedSizeTree, _Tree);\n\n  function FixedSizeTree(props, context) {\n    var _this;\n\n    _this = _Tree.call(this, props, context) || this;\n    _this.state = _extends({}, _this.state, {\n      computeTree: computeTree\n    });\n    return _this;\n  }\n\n  var _proto = FixedSizeTree.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        children = _this$props.children,\n        listRef = _this$props.listRef,\n        placeholder = _this$props.placeholder,\n        treeWalker = _this$props.treeWalker,\n        rowComponent = _this$props.rowComponent,\n        rest = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"listRef\", \"placeholder\", \"treeWalker\", \"rowComponent\"]);\n\n    var _this$state = this.state,\n        attachRefs = _this$state.attachRefs,\n        order = _this$state.order;\n    return placeholder && order.length === 0 ? placeholder : /*#__PURE__*/React.createElement(FixedSizeList, Object.assign({}, rest, {\n      itemCount: order.length,\n      itemData: this.getItemData() // eslint-disable-next-line @typescript-eslint/unbound-method\n      ,\n      itemKey: getIdByIndex // eslint-disable-next-line @typescript-eslint/unbound-method\n      ,\n      ref: attachRefs\n    }), rowComponent);\n  };\n\n  return FixedSizeTree;\n}(Tree);","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inheritsLoose from \"@babel/runtime/helpers/inheritsLoose\";\nimport React from 'react';\nimport { VariableSizeList } from 'react-window';\nimport Tree, { createTreeComputer } from './Tree';\nimport { createBasicRecord, getIdByIndex } from './utils';\nvar computeTree = createTreeComputer({\n  createRecord: function createRecord(data, _ref, parent, previousRecord) {\n    var recomputeTree = _ref.recomputeTree,\n        resetAfterId = _ref.resetAfterId;\n    var record = createBasicRecord({\n      data: data,\n      height: previousRecord ? previousRecord.public.height : data.defaultHeight,\n      isOpen: previousRecord ? previousRecord.public.isOpen : data.isOpenByDefault,\n      resize: function resize(height, shouldForceUpdate) {\n        record.public.height = height;\n        resetAfterId(record.public.data.id, shouldForceUpdate);\n      },\n      setOpen: function setOpen(state) {\n        var _recomputeTree;\n\n        return recomputeTree((_recomputeTree = {}, _recomputeTree[data.id] = state, _recomputeTree));\n      }\n    }, parent);\n    return record;\n  }\n});\nexport var VariableSizeTree = /*#__PURE__*/function (_Tree) {\n  _inheritsLoose(VariableSizeTree, _Tree);\n\n  function VariableSizeTree(props, context) {\n    var _this;\n\n    _this = _Tree.call(this, props, context) || this;\n    _this.getItemSize = _this.getItemSize.bind(_assertThisInitialized(_this));\n    _this.state = _extends({}, _this.state, {\n      computeTree: computeTree,\n      resetAfterId: _this.resetAfterId.bind(_assertThisInitialized(_this))\n    });\n    return _this;\n  }\n\n  var _proto = VariableSizeTree.prototype;\n\n  _proto.resetAfterId = function resetAfterId(id, shouldForceUpdate) {\n    var _list$current;\n\n    if (shouldForceUpdate === void 0) {\n      shouldForceUpdate = false;\n    }\n\n    var _this$state = this.state,\n        list = _this$state.list,\n        order = _this$state.order;\n    (_list$current = list.current) == null ? void 0 : _list$current.resetAfterIndex(order.indexOf(id), shouldForceUpdate);\n  };\n\n  _proto.recomputeTree = function recomputeTree(state) {\n    var _this2 = this;\n\n    return _Tree.prototype.recomputeTree.call(this, state).then(function () {\n      var _this2$state$list$cur;\n\n      (_this2$state$list$cur = _this2.state.list.current) == null ? void 0 : _this2$state$list$cur.resetAfterIndex(0, true);\n    });\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        children = _this$props.children,\n        placeholder = _this$props.placeholder,\n        itemSize = _this$props.itemSize,\n        rowComponent = _this$props.rowComponent,\n        treeWalker = _this$props.treeWalker,\n        rest = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"placeholder\", \"itemSize\", \"rowComponent\", \"treeWalker\"]);\n\n    var _this$state2 = this.state,\n        attachRefs = _this$state2.attachRefs,\n        order = _this$state2.order;\n    return placeholder && order.length === 0 ? placeholder : /*#__PURE__*/React.createElement(VariableSizeList, Object.assign({}, rest, {\n      itemCount: order.length,\n      itemData: this.getItemData() // eslint-disable-next-line @typescript-eslint/unbound-method\n      ,\n      itemKey: getIdByIndex // eslint-disable-next-line @typescript-eslint/unbound-method\n      ,\n      itemSize: itemSize != null ? itemSize : this.getItemSize // eslint-disable-next-line @typescript-eslint/unbound-method\n      ,\n      ref: attachRefs\n    }), rowComponent);\n  };\n\n  _proto.getItemSize = function getItemSize(index) {\n    return this.getRecordData(index).height;\n  };\n\n  return VariableSizeTree;\n}(Tree);"],"names":["refs","value","forEach","ref","current","noop","createBasicRecord","pub","parent","child","isShown","public","isOpen","sibling","visited","getIdByIndex","index","_ref","getRecordData","data","id","Row","_ref$data","Node","component","treeData","style","isScrolling","React","Object","assign","createTreeComputer","creatorOptions","props","state","options","refresh","_ref2","_ref3","createRecord","buildingTaskTimeout","placeholder","_ref3$async","async","treeWalker","shouldPreservePreviousState","undefined","records","previousRecords","order","Map","requestIdleCallbackOptions","timeout","meta","WeakMap","iter","root","next","rootRecord","get","set","currentRecord","isTraversingRoot","tempRecord","useIdleCallback","hasTime","deadline","timeRemaining","task","requestIdleCallback","push","childRecord","setState","updateRequest","generateNewTree","_ref4","_ref5","opennessState","has","opts","ownerRecord","_ref6","open","_ref6$subtreeCallback","subtreeCallback","update","apply","indexOf","recordNextToSubtree","countToRemove","length","orderParts","record","currentOrderPart","MAX_FUNCTION_ARGUMENTS","i","_ref7","splice","count","updateExistingTree","Tree","_PureComponent","context","_this","call","this","bind","_assertThisInitialized","list","createRef","recomputeTree","_inheritsLoose","getDerivedStateFromProps","_props$listRef","listRef","computeTree","oldTreeWalker","_extends","attachRefs","mergeRefs","_proto","prototype","getItemData","_this$props","children","itemData","_this$state","_this2","Promise","resolve","prevState","scrollTo","scrollOffset","_this$state$list$curr","scrollToItem","align","_this$state$list$curr2","PureComponent","defaultProps","rowComponent","previousRecord","isOpenByDefault","setOpen","_recomputeTree","FixedSizeTree","_Tree","render","rest","_objectWithoutPropertiesLoose","FixedSizeList","itemCount","itemKey","resetAfterId","height","defaultHeight","resize","shouldForceUpdate","VariableSizeTree","getItemSize","_list$current","resetAfterIndex","then","_this2$state$list$cur","itemSize","_this$state2","VariableSizeList"],"sourceRoot":""}