{"version":3,"file":"6719.bundle.js","mappings":"yMAWqBA,EAAAA,WACjB,WAAYC,IAAM,eACdC,KAAKC,SAAW,EAChBD,KAAKE,MAAO,EACZF,KAAKG,MAAQJ,CAChB,C,mCAMD,WACI,IAAKC,KAAKI,UACN,MAAKJ,KAAKE,KAGA,IAAIG,MAAM,oDAFV,IAAIA,MAAM,iFAAmFL,KAAKG,MAAMH,KAAKC,WAI3H,IAAMK,EAAQ,CACVC,KAAMC,SAASR,KAAKG,MAAMH,KAAKC,YAQnC,OANAD,KAAKC,WACLK,EAAMG,MAAQC,EAAgBJ,EAAMC,KAAMP,KAAKG,MAAMH,KAAKC,UAAUU,QACpEX,KAAKC,WACc,IAAfK,EAAMC,MAA8B,QAAhBD,EAAMG,QAC1BT,KAAKE,MAAO,GAChBF,KAAKY,cAAgBN,EACdA,CACV,G,kBACD,WACI,IAAKN,KAAKI,UACN,MAAKJ,KAAKE,KAGA,IAAIG,MAAM,oDAFV,IAAIA,MAAM,iFAAmFL,KAAKG,MAAMH,KAAKC,WAI3H,IAAMK,EAAQ,CACVC,KAAMC,SAASR,KAAKG,MAAMH,KAAKC,YAGnC,OADAK,EAAMG,MAAQC,EAAgBJ,EAAMC,KAAMP,KAAKG,MAAMH,KAAKC,SAAW,GAAGU,QACjEL,CACV,G,oBACD,WAA2B,IAApBO,EAAoB,uDAAH,EACpBb,KAAKC,SAAWD,KAAKC,SAA4B,EAAjBY,CACnC,G,qBAKD,WAEI,OAAIb,KAAKE,QAILF,KAAKC,SAAWD,KAAKG,MAAMW,OAAS,EAI3C,G,mBAKD,WACI,OAAOd,KAAKE,IACf,K,EAlEgBJ,GA4ErB,SAASY,EAAgBH,EAAME,GAC3B,OAAIF,GAAQ,EACDE,EACPF,GAAQ,IAAMA,GAAQ,GACfQ,WAAWN,GAClBF,GAAQ,IAAMA,GAAQ,GACfC,SAASC,GAChBF,GAAQ,KAAOA,GAAQ,IAChBE,EACPF,GAAQ,KAAOA,GAAQ,IAChBQ,WAAWN,GAClBF,GAAQ,KAAOA,GAAQ,IAChBC,SAASC,GAChBF,GAAQ,KAAOA,GAAQ,IAChBQ,WAAWN,GAClBF,GAAQ,KAAOA,GAAQ,IAChBC,SAASC,GAChBF,GAAQ,KAAOA,GAAQ,IAsC/B,SAAsBS,GAClB,GAAY,MAARA,EACA,OAAO,EACX,GAAY,MAARA,EACA,OAAO,EACX,MAAMC,UAAU,WAAcD,EAAM,mCACvC,CA3CcE,CAAaT,GACpBF,GAAQ,KAAOA,GAAQ,IAChBE,EACPF,GAAQ,KAAOA,GAAQ,IAChBC,SAASC,GAChBF,GAAQ,KAAOA,GAAQ,IAChBE,EACPF,GAAQ,KAAOA,GAAQ,IAChBC,SAASC,GAChBF,GAAQ,KAAOA,GAAQ,IAChBE,EACPF,GAAQ,KAAOA,GAAQ,IAChBC,SAASC,GAChBF,GAAQ,KAAOA,GAAQ,IAChBE,EACPF,GAAQ,KAAOA,GAAQ,IAChBC,SAASC,GAChBF,GAAQ,KAAOA,GAAQ,IAChBQ,WAAWN,GAClBF,GAAQ,KAAOA,GAAQ,KAEd,MAATA,GAEAA,GAAQ,KAAQA,GAAQ,KAHjBE,EAKPF,GAAQ,MAAQA,GAAQ,KACjBQ,WAAWN,GAClBF,GAAQ,MAAQA,GAAQ,KACjBC,SAASC,IACpBU,QAAQC,IAAI,uDAAwD,CAAEb,KAAMA,EAAME,MAAOA,IAClFA,EACV,CClID,OACI,EACA,SACA,SACA,MACA,MACA,IACA,SACA,SACA,QACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,QACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,MACA,QACA,KACA,QACA,MACA,QACA,MACA,QACA,KACA,QACA,KACA,QACA,KACA,QACA,IACA,QACA,IACA,QACA,IACA,QACA,IACA,QACA,GACA,QACA,QACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,QACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,UCzPG,SAASY,EAAWC,GACvB,IAAMC,EAAQ,CAAC,EAEfD,EAAQE,SACR,IAAIC,EAAOH,EAAQI,OACfnB,EAAOkB,EAAKlB,KAIhB,GAHAgB,EAAMI,EAAIF,EAAKhB,MACfF,GAAQ,IACRkB,EAAOH,EAAQI,QACNnB,MAAQA,EACb,MAAM,IAAIF,MAAM,uCAAyCE,EACrD,YAAckB,EAAKlB,KAAO,KAIlC,OAHAgB,EAAMK,EAAIH,EAAKhB,MACfF,GAAQ,IACRkB,EAAOH,EAAQI,QACNnB,MAAQA,GAEbe,EAAQE,SACDD,IAEXA,EAAMM,EAAIJ,EAAKhB,MACRc,EACV,CAOM,SAASO,EAA4BC,EAAQN,EAAMH,GACtD,OAAQG,EAAKlB,MACT,KAAK,EACDwB,EAAOC,KAAOP,EAAKhB,MACnB,MACJ,KAAK,EACDsB,EAAOE,OAASR,EAAKhB,MACrB,MACJ,KAAK,EACDsB,EAAOG,SAAWT,EAAKhB,MACvB,MACJ,KAAK,EACDsB,EAAOI,MAAQV,EAAKhB,MACpB,MACJ,KAAK,GACDsB,EAAOK,cAAgBX,EAAKhB,MAC5B,MACJ,KAAK,GACDsB,EAAOM,QAAyB,IAAfZ,EAAKhB,MACtB,MACJ,KAAK,GACDsB,EAAOO,WAAab,EAAKhB,MACzBsB,EAAOQ,OA3DUC,EA2DWC,KAAKC,IAAIjB,EAAKhB,OA1D3CkC,EAAqBH,IA2DpB,MACJ,KAAK,GACDT,EAAOa,aAA8B,IAAfnB,EAAKhB,MAC3B,MACJ,KAAK,IAED,MACJ,KAAK,IAED,KAAoB,GAAbgB,EAAKlB,MACRkB,EAAOH,EAAQI,OAEnBJ,EAAQE,SACR,MACJ,KAAK,IACDO,EAAOc,YAAcpB,EAAKhB,MAC1B,MACJ,KAAK,IACDsB,EAAOe,qBAAuBrB,EAAKhB,MACnC,MACJ,KAAK,IAKDsB,EAAOgB,WAAatB,EAAKhB,MACzB,MACJ,KAAK,IACDsB,EAAOQ,MAAQd,EAAKhB,MACpB,MACJ,KAAK,IACDsB,EAAOiB,aAAejB,EAAOiB,cAAgB,CAAC,EAC9CjB,EAAOiB,aAAaC,cAAgBlB,EAAOiB,aAAaC,eAAiB,GACzElB,EAAOiB,aAAaC,cAAcC,KAAKzB,EAAKhB,OAC5C,MACJ,KAAK,KACDsB,EAAOiB,aAAejB,EAAOiB,cAAgB,CAAC,EAC9CjB,EAAOiB,aAAaG,gBAAkB1B,EAAKhB,MAC3C,MACJ,QACI,OAAO,EApGZ,IAAsB+B,EAsGzB,OAAO,CACV,C,IC3GoBY,EAAAA,WACjB,cAAc,eACVpD,KAAKqD,cAAgB,QACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,MAAO6C,SAAU,IAE7C,IADA7B,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACDwB,EAAOyB,MAA8B,KAAP,EAAb/B,EAAKhB,OACtBsB,EAAO0B,6BAAuD,OAAT,IAAbhC,EAAKhB,OAC7C,MACJ,KAAK,GACDsB,EAAOuB,SAAWI,EAAoBpC,EAASG,GAC/CA,EAAOH,EAAQV,cACf,MACJ,QACI+C,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EA1BgBqB,GA4BrB,SAASM,EAAoBpC,EAASG,GAKlC,IAJA,IAAI6B,EAAW,GACXM,GAAkB,EAClBC,GAAmB,EAEdC,EAAI,EAAGA,GADQ,EACgBA,IAAK,CAEzC,IADA,IAAIC,EAAS,CAAC,GACNzC,EAAQiC,SACM,IAAd9B,EAAKlB,OAAcsD,GADF,CAGrB,OAAQpC,EAAKlB,MACT,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACD,GAAIqD,EAAiB,CACjBC,GAAmB,EACnB,QACH,CACDE,EAAOpC,EAAIF,EAAKhB,MAChBmD,GAAkB,EAClB,MACJ,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACDG,EAAOnC,EAAIH,EAAKhB,MAChB,MACJ,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACDsD,EAAOlC,EAAIJ,EAAKhB,MAChB,MACJ,QAGI,OAAO6C,EAEf7B,EAAOH,EAAQI,MAClB,CAED4B,EAASJ,KAAKa,GACdH,GAAkB,EAClBC,GAAmB,CACtB,CAED,OADAvC,EAAQE,SACD8B,CACV,C,IC5EoBU,EAAAA,WACjB,cAAc,eACVhE,KAAKqD,cAAgB,KACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,OAE5B,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACDwB,EAAOkC,OAASN,EAAmBrC,GACnC,MACJ,KAAK,GACDS,EAAOmC,OAASzC,EAAKhB,MACrB,MACJ,KAAK,GACDsB,EAAOoC,WAAa1B,KAAK2B,GAAK,IAAM3C,EAAKhB,MACzC,MACJ,KAAK,GACDsB,EAAOsC,SAAW5B,KAAK2B,GAAK,IAAM3C,EAAKhB,MACvCsB,EAAOuC,YAAcvC,EAAOsC,SAAWtC,EAAOoC,WAC9C,MACJ,KAAK,IACDpC,EAAOwC,oBAAsB9C,EAAKhB,MAClC,MACJ,KAAK,IACDsB,EAAOyC,oBAAsB/C,EAAKhB,MAClC,MACJ,KAAK,IACDsB,EAAO0C,oBAAsBhD,EAAKhB,MAClC,MACJ,QACIkD,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EAxCgBiC,GCAAU,EAAAA,WACjB,cAAc,eACV1E,KAAKqD,cAAgB,QACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAIM,EAAS,CACTC,KAAMP,EAAKhB,MACXkE,MAAO,EACPC,UAAW,YAGf,IADAnD,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAIrB,OAAQkB,EAAKlB,MACT,KAAK,EACDwB,EAAO8C,KAAOpD,EAAKhB,MACnB,MACJ,KAAK,EACDsB,EAAO+C,IAAMrD,EAAKhB,MAClB,MACJ,KAAK,EACDsB,EAAOgD,OAAStD,EAAKhB,MACrB,MACJ,KAAK,EACDsB,EAAO6C,UAAYnD,EAAKhB,MACxB,MACJ,KAAK,GACDsB,EAAOiD,WAAarB,EAAmBrC,GACvC,MACJ,KAAK,GACDS,EAAOkD,SAAWtB,EAAmBrC,GACrC,MACJ,KAAK,GACDS,EAAOmD,UAAYzD,EAAKhB,MACxB,MACJ,KAAK,GACDsB,EAAOoD,WAAa1D,EAAKhB,MACzB,MACJ,KAAK,GACDsB,EAAO4C,MAAQlD,EAAKhB,MACpB,MACJ,KAAK,GACDsB,EAAOqD,SAAW3D,EAAKhB,MACvB,MACJ,KAAK,GACDsB,EAAOsD,aAAe5D,EAAKhB,MAC3B,MACJ,KAAK,GACDsB,EAAOuD,aAA4B,EAAb7D,EAAKhB,OAC3BsB,EAAOwD,YAA2B,EAAb9D,EAAKhB,OAC1BsB,EAAOyD,wBAAuC,EAAb/D,EAAKhB,OACtCsB,EAAO0D,UAAyB,EAAbhE,EAAKhB,OACxB,MACJ,KAAK,GACDsB,EAAO2D,aAA4B,EAAbjE,EAAKhB,OAC3BsB,EAAO4D,YAA2B,EAAblE,EAAKhB,OAC1B,MACJ,KAAK,GAEDsB,EAAO6D,wBAA0BnE,EAAKhB,MACtC,MACJ,KAAK,GACDsB,EAAO8D,YAAcpE,EAAKhB,MAC1B,MACJ,KAAK,GAEDsB,EAAO+D,sBAAwBrE,EAAKhB,MACpC,MACJ,KAAK,IACD,MACJ,KAAK,IACDsB,EAAOwC,oBAAsB9C,EAAKhB,MAClC,MACJ,KAAK,IACDsB,EAAOyC,oBAAsB/C,EAAKhB,MAClC,MACJ,KAAK,IACDsB,EAAO0C,oBAAsBhD,EAAKhB,MAClC,MACJ,QACIkD,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EAxFgB2C,GCAAqB,EAAAA,WACjB,cAAc,eACV/F,KAAKqD,cAAgB,QACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,OAE5B,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACDwB,EAAOkC,OAASN,EAAmBrC,GACnC,MACJ,KAAK,GACDS,EAAOmC,OAASzC,EAAKhB,MACrB,MACJ,KAAK,GACDsB,EAAOoC,WAAa1B,KAAK2B,GAAK,IAAM3C,EAAKhB,MACzC,MACJ,KAAK,GACD,IAAM4D,EAAW5B,KAAK2B,GAAK,IAAM3C,EAAKhB,MAClC4D,EAAWtC,EAAOoC,WAClBpC,EAAOuC,YAAcD,EAAW,EAAI5B,KAAK2B,GAAKrC,EAAOoC,WAErDpC,EAAOuC,YAAcD,EAAWtC,EAAOoC,WAC3CpC,EAAOsC,SAAWA,EAClB,MACJ,QACIV,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EAnCgBgE,GCAAC,EAAAA,WACjB,cAAc,eACVhG,KAAKqD,cAAgB,WACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,OAE5B,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,EACDwB,EAAOkE,MAAQxE,EAAKhB,MACpB,MACJ,KAAK,GACDsB,EAAOmE,YAAcvC,EAAmBrC,GACxC,MACJ,KAAK,GACDS,EAAOoE,aAAexC,EAAmBrC,GACzC,MACJ,KAAK,GACDS,EAAOqE,eAAiBzC,EAAmBrC,GAC3C,MACJ,KAAK,GACDS,EAAOsE,sBAAwB1C,EAAmBrC,GAClD,MACJ,KAAK,GACDS,EAAOuE,sBAAwB3C,EAAmBrC,GAClD,MACJ,KAAK,GACDS,EAAOwE,sBAAwB5C,EAAmBrC,GAClD,MACJ,KAAK,GACDS,EAAOyE,SAAW7C,EAAmBrC,GACrC,MACJ,KAAK,GACDS,EAAO0E,cAAgBhF,EAAKhB,MAC5B,MACJ,KAAK,GACDsB,EAAO2E,gBAAkBjF,EAAKhB,MAC9B,MACJ,KAAK,GACDsB,EAAO4E,kBAAoBlF,EAAKhB,MAChC,MACJ,KAAK,EACDsB,EAAO8C,KAAOpD,EAAKhB,MACnB,MACJ,KAAK,GACDsB,EAAO6E,MAAQnF,EAAKhB,MACpB,MACJ,QACIkD,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EAzDgBiE,GCAAa,EAAAA,WACjB,cAAc,eACV7G,KAAKqD,cAAgB,SACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,OAE5B,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACDwB,EAAOkC,OAASN,EAAmBrC,GACnC,MACJ,KAAK,GACDS,EAAO+E,kBAAoBnD,EAAmBrC,GAC9C,MACJ,KAAK,GACDS,EAAOgF,UAAYtF,EAAKhB,MACxB,MACJ,KAAK,GACDsB,EAAOoC,WAAa1C,EAAKhB,MACzB,MACJ,KAAK,GACDsB,EAAOsC,SAAW5C,EAAKhB,MACvB,MACJ,KAAK,EACDsB,EAAOiF,KAAOvF,EAAKhB,MACnB,MACJ,QACIkD,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EApCgB8E,GCAAI,EAAAA,WACjB,cAAc,eACVjH,KAAKqD,cAAgB,QACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,OAE5B,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,EACDwB,EAAOiF,KAAOvF,EAAKhB,MACnB,MACJ,KAAK,GACDsB,EAAOmF,OAASzF,EAAKhB,MACrB,MACJ,KAAK,GACDsB,EAAOoF,OAAS1F,EAAKhB,MACrB,MACJ,KAAK,GACDsB,EAAOqF,OAAS3F,EAAKhB,MACrB,MACJ,KAAK,GACDsB,EAAOsF,SAAW1D,EAAmBrC,GACrC,MACJ,KAAK,GACDS,EAAOqD,SAAW3D,EAAKhB,MACvB,MACJ,KAAK,GACDsB,EAAOuF,YAAc7F,EAAKhB,MAC1B,MACJ,KAAK,GACDsB,EAAOwF,SAAW9F,EAAKhB,MACvB,MACJ,KAAK,GACDsB,EAAOyF,cAAgB/F,EAAKhB,MAC5B,MACJ,KAAK,GACDsB,EAAO0F,WAAahG,EAAKhB,MACzB,MACJ,KAAK,IACDsB,EAAO2F,mBAAqB/D,EAAmBrC,GAC/C,MACJ,QACIqC,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EAnDgBkF,GCAAU,EAAAA,WACjB,cAAc,eACV3H,KAAKqD,cAAgB,MACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,MAAO6C,SAAU,IAE7C,IADA7B,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACDwB,EAAOuB,SAASsE,QAAQjE,EAAmBrC,IAC3C,MACJ,KAAK,GACDS,EAAOuB,SAASJ,KAAKS,EAAmBrC,IACxC,MACJ,KAAK,IACDS,EAAO2F,mBAAqB/D,EAAmBrC,GAC/C,MACJ,KAAK,IACD,MACJ,QACIqC,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EA7BgB4F,GCAAE,EAAAA,WACjB,cAAc,eACV7H,KAAKqD,cAAgB,YACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,MAAO6C,SAAU,IACzCwE,EAAmB,EAEvB,IADArG,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACDwB,EAAOgG,UAAYtG,EAAKhB,MACxB,MACJ,KAAK,GACDsB,EAAOiG,MAAQvG,EAAKhB,MACpB,MACJ,KAAK,GACDsB,EAAOyB,MAA8B,KAAP,EAAb/B,EAAKhB,OACtBsB,EAAO0B,6BAAuD,OAAT,IAAbhC,EAAKhB,OAC7C,MACJ,KAAK,GACDqH,EAAmBrG,EAAKhB,MACxB,MACJ,KAAK,GACDsB,EAAOuB,SAAW2E,EAAwBH,EAAkBxG,GAC5D,MACJ,KAAK,GACkB,IAAfG,EAAKhB,QACLsB,EAAOmG,MAAQzG,EAAKhB,OACxB,MACJ,KAAK,IACDsB,EAAOwC,oBAAsB9C,EAAKhB,MAClC,MACJ,KAAK,IACDsB,EAAOyC,oBAAsB/C,EAAKhB,MAClC,MACJ,KAAK,IACDsB,EAAO0C,oBAAsBhD,EAAKhB,MAClC,MACJ,QACIkD,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EAhDgB8F,GAkDrB,SAASI,EAAwBE,EAAG7G,GAChC,IAAK6G,GAAKA,GAAK,EACX,MAAM9H,MAAM,sCAKhB,IAJA,IAAMiD,EAAW,GACbM,GAAkB,EAClBC,GAAmB,EACnBpC,EAAOH,EAAQV,cACVkD,EAAI,EAAGA,EAAIqE,EAAGrE,IAAK,CAExB,IADA,IAAMC,EAAS,CAAC,GACRzC,EAAQiC,SACM,IAAd9B,EAAKlB,OAAcsD,GADF,CAGrB,OAAQpC,EAAKlB,MACT,KAAK,GACD,GAAIqD,EAAiB,CACjBC,GAAmB,EACnB,QACH,CACDE,EAAOpC,EAAIF,EAAKhB,MAChBmD,GAAkB,EAClB,MACJ,KAAK,GACDG,EAAOnC,EAAIH,EAAKhB,MAChB,MACJ,KAAK,GACDsD,EAAOlC,EAAIJ,EAAKhB,MAChB,MACJ,KAAK,GACDsD,EAAOqE,WAAa3G,EAAKhB,MACzB,MACJ,KAAK,GACDsD,EAAOsE,SAAW5G,EAAKhB,MACvB,MACJ,KAAK,GACiB,GAAdgB,EAAKhB,QACLsD,EAAOuE,MAAQ7G,EAAKhB,OACxB,MACJ,QAOI,OALAa,EAAQE,SACJoC,GACAN,EAASJ,KAAKa,GAElBzC,EAAQE,SACD8B,EAEf7B,EAAOH,EAAQI,MAClB,CAED4B,EAASJ,KAAKa,GACdH,GAAkB,EAClBC,GAAmB,CACtB,CAED,OADAvC,EAAQE,SACD8B,CACV,C,ICzGoBiF,EAAAA,WACjB,cAAc,eACVvI,KAAKqD,cAAgB,OACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,OAE5B,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,EAGL,KAAK,EACDwB,EAAO8C,KAAO9C,EAAO8C,MAAQpD,EAAKhB,MAAQsB,EAAO8C,KAAOpD,EAAKhB,MAC7D,MACJ,KAAK,GACDsB,EAAOsF,SAAW1D,EAAmBrC,GACrC,MACJ,KAAK,GACDS,EAAOyG,gBAAkB7E,EAAmBrC,GAC5C,MACJ,KAAK,GAEDS,EAAO0G,OAAShH,EAAKhB,MACrB,MACJ,KAAK,GACDsB,EAAOmG,MAAQzG,EAAKhB,MACpB,MACJ,KAAK,GACDsB,EAAOqD,SAAW3D,EAAKhB,MACvB,MACJ,KAAK,GACDsB,EAAO2E,gBAAkBjF,EAAKhB,MAC9B,MACJ,KAAK,GACDsB,EAAO2G,iBAAmBjH,EAAKhB,MAC/B,MACJ,QACIkD,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EA9CgBwG,GCAAI,EAAAA,WACjB,cAAc,eACV3I,KAAKqD,cAAgB,OACxB,C,0CACD,SAAY/B,EAASG,GACjB,IACMM,EAAS,CAAEC,KADJP,EAAKhB,OAGlB,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACDwB,EAAOsF,SAAW1D,EAAmBrC,GACrC,MACJ,KAAK,GACDS,EAAOmD,UAAYzD,EAAKhB,MACxB,MACJ,KAAK,IACDsB,EAAO2F,mBAAqB/D,EAAmBrC,GAC/C,MACJ,KAAK,IACD,MACJ,QACIqC,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EA9BgB4G,GCAAC,EAAAA,WACjB,cAAc,eACV5I,KAAKqD,cAAgB,QACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAIM,EAAS,CAAEC,KAAMP,EAAKhB,OAE1B,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACDwB,EAAOJ,EAAIF,EAAKhB,MAChB,MACJ,KAAK,GACDsB,EAAOH,EAAIH,EAAKhB,MAChB,MACJ,KAAK,GACDsB,EAAOF,EAAIJ,EAAKhB,MAChB,MACJ,KAAK,GAEL,KAAK,GAeL,KAAK,GACD,MAdJ,KAAK,GACiB,GAAdgB,EAAKhB,QACLsB,EAAOuG,MAAQ7G,EAAKhB,OACxB,MACJ,KAAK,GACDsB,EAAO8G,mBAA0C,KAAP,EAAbpH,EAAKhB,OAClCsB,EAAO+G,gBAAuC,KAAP,EAAbrH,EAAKhB,OAC/BsB,EAAOgH,aAAoC,KAAP,EAAbtH,EAAKhB,OAC5BsB,EAAOiH,mBAA2C,KAAR,GAAbvH,EAAKhB,OAClCsB,EAAOkH,qBAA6C,KAAR,GAAbxH,EAAKhB,OACpCsB,EAAOmH,mBAA2C,KAAR,GAAbzH,EAAKhB,OAClCsB,EAAOoH,mBAA4C,KAAT,IAAb1H,EAAKhB,OAClC,MAGJ,KAAK,GACDsB,EAAOqH,MAAQ3H,EAAKhB,MACpB,MACJ,KAAK,GACDsB,EAAOsH,MAAQ5H,EAAKhB,MACpB,MACJ,KAAK,GACDsB,EAAOuH,MAAQ7H,EAAKhB,MACpB,MACJ,KAAK,GACDsB,EAAOwH,MAAQ9H,EAAKhB,MACpB,MACJ,QACIkD,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EA1DgB6G,GCCAY,EAAAA,WACjB,cAAc,eACVxJ,KAAKqD,cAAgB,UACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAIM,EAAS,CAAEC,KAAMP,EAAKhB,MAAO6C,SAAU,IAE3C,IADA7B,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GAEL,KAAK,GAEL,KAAK,GAKL,KAAK,GAEL,KAAK,GAYL,KAAK,GAEL,KAAK,GAEL,KAAK,GAEL,KAAK,GAEL,KAAK,GACD,MA1BJ,KAAK,GACDwB,EAAOmD,UAAYzD,EAAKhB,MACxB,MAKJ,KAAK,GACDsB,EAAOyB,MAA6B,KAAP,EAAb/B,EAAKhB,OACrBsB,EAAO0H,yBAAgD,KAAP,EAAbhI,EAAKhB,OACxCsB,EAAO2H,0BAAiD,KAAP,EAAbjI,EAAKhB,OACzCsB,EAAO4H,aAAoC,KAAP,EAAblI,EAAKhB,OAC5BsB,EAAO6H,gBAAwC,KAAR,GAAbnI,EAAKhB,OAC/BsB,EAAO8H,sBAA8C,KAAR,GAAbpI,EAAKhB,OACrCsB,EAAO+H,eAAuC,KAAR,GAAbrI,EAAKhB,OAC9BsB,EAAO0B,6BAAsD,KAAT,IAAbhC,EAAKhB,OAC5C,MAWJ,KAAK,IACDsB,EAAO2F,mBAAqB/D,EAAmBrC,GAC/C,MACJ,QACIqC,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CAED,OADAK,EAAOuB,SAIf,SAA+BhC,EAASG,GACpC,IAAMsI,EAAe,IAAIC,EACnB1G,EAAW,GACjB,MAAQhC,EAAQiC,SACZ,GAAkB,IAAd9B,EAAKlB,KACL,GAAmB,WAAfkB,EAAKhB,MACL6C,EAASJ,KAAK6G,EAAaE,YAAY3I,EAASG,IAChDA,EAAOH,EAAQV,mBAEd,GAAmB,WAAfa,EAAKhB,MAAoB,CAC9ByJ,EAAY5I,EAASG,GACrB,KACH,CAGT,OAAO6B,CACV,CApByB6G,CAAsB7I,EAASG,GAC1CM,CACV,K,EAvDgByH,GA0ErB,SAASU,EAAY5I,EAASG,GAC1B,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,OAE5B,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACK,GAAb9B,EAAKlB,MAEToD,EAAoC5B,EAAQN,EAAMH,GAClDG,EAAOH,EAAQI,OAEnB,OAAOK,CACV,C,ICrFoBqI,EAAAA,WACjB,cAAc,eACVpK,KAAKqD,cAAgB,OACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,MAAO4J,OAAQ,IAE3C,IADA5I,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACDwB,EAAOsI,OAAO,GAAK1G,EAAmBrC,GACtC,MACJ,KAAK,GACDS,EAAOsI,OAAO,GAAK1G,EAAmBrC,GACtC,MACJ,KAAK,GACDS,EAAOsI,OAAO,GAAK1G,EAAmBrC,GACtC,MACJ,KAAK,GACDS,EAAOsI,OAAO,GAAK1G,EAAmBrC,GACtC,MACJ,KAAK,IACDS,EAAO2F,mBAAqB/D,EAAmBrC,GAC/C,MACJ,QACIqC,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EAjCgBqI,GCAAE,EAAAA,WACjB,cAAc,eACVtK,KAAKqD,cAAgB,QACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,OAE5B,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACIwB,EAAOwI,gBACRxI,EAAOwI,cAAgB,IAC3BxI,EAAOwI,cAAcrH,KAAKS,EAAmBrC,IAC7C,MACJ,KAAK,GACIS,EAAOyI,YACRzI,EAAOyI,UAAY,IACvBzI,EAAOyI,UAAUtH,KAAKS,EAAmBrC,IACzC,MACJ,KAAK,GACDS,EAAO0I,aAAe9G,EAAmBrC,GACzC,MACJ,KAAK,GACDS,EAAO2I,WAAa/G,EAAmBrC,GACvC,MACJ,KAAK,GACIS,EAAO4I,aACR5I,EAAO4I,WAAa,IACxB5I,EAAO4I,WAAWzH,KAAKzB,EAAKhB,OAC5B,MACJ,KAAK,GACuB,IAAN,EAAbgB,EAAKhB,SACNsB,EAAO6I,QAAS,GACI,IAAN,EAAbnJ,EAAKhB,SACNsB,EAAO8I,UAAW,GACE,IAAN,EAAbpJ,EAAKhB,SACNsB,EAAO+I,UAAW,GACE,IAAN,EAAbrJ,EAAKhB,SACNsB,EAAOgJ,QAAS,GACK,IAAP,GAAbtJ,EAAKhB,SACNsB,EAAOgJ,QAAS,EAChBhJ,EAAOiJ,QAAS,GAEpB,MACJ,KAAK,GACDjJ,EAAOkJ,oBAAsBxJ,EAAKhB,MAClC,MACJ,KAAK,GACDsB,EAAOmJ,cAAgBzJ,EAAKhB,MAC5B,MACJ,KAAK,GACDsB,EAAOoJ,sBAAwB1J,EAAKhB,MACpC,MACJ,KAAK,GACDsB,EAAOqJ,kBAAoB3J,EAAKhB,MAChC,MACJ,KAAK,IACDsB,EAAOsJ,aAAe1H,EAAmBrC,GACzC,MACJ,QACIqC,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EApEgBuI,GCAAgB,EAAAA,WACjB,cAAc,eACVtL,KAAKqD,cAAgB,MACxB,C,0CACD,SAAY/B,EAASG,GACjB,IAAMM,EAAS,CAAEC,KAAMP,EAAKhB,OAE5B,IADAgB,EAAOH,EAAQI,QACPJ,EAAQiC,SACM,IAAd9B,EAAKlB,MADY,CAGrB,OAAQkB,EAAKlB,MACT,KAAK,GACDwB,EAAOiD,WAAarB,EAAmBrC,GACvC,MACJ,KAAK,GACDS,EAAOkD,SAAWtB,EAAmBrC,GACrC,MACJ,KAAK,GACDS,EAAOoD,WAAa1D,EAAKhB,MACzB,MACJ,KAAK,GACDsB,EAAOmF,OAASzF,EAAKhB,MACrB,MACJ,KAAK,GACDsB,EAAOqD,SAAW3D,EAAKhB,MACvB,MACJ,KAAK,EACDsB,EAAO8C,KAAOpD,EAAKhB,MACnB,MAEJ,KAAK,GACDsB,EAAOwJ,OAAS9J,EAAKhB,MACrB,MACJ,KAAK,GACDsB,EAAOyJ,OAAS/J,EAAKhB,MACrB,MACJ,QACIkD,EAAoC5B,EAAQN,EAAMH,GAG1DG,EAAOH,EAAQI,MAClB,CACD,OAAOK,CACV,K,EA3CgBuJ,G,oBCsBrBlK,IAAAA,SAAa,S,IAoBQqK,EAAAA,WACjB,aApBJ,IAAuCC,GAoBrB,eACV1L,KAAK2L,gBAAkB,CAAC,GArBOD,EAsBD1L,MApBxB4L,sBAAsBC,GAChCH,EAAUE,sBAAsB5H,GAChC0H,EAAUE,sBAAsBE,GAChCJ,EAAUE,sBAAsB7F,GAChC2F,EAAUE,sBAAsB5F,GAChC0F,EAAUE,sBAAsB/E,GAChC6E,EAAUE,sBAAsB3E,GAChCyE,EAAUE,sBAAsBjE,GAChC+D,EAAUE,sBAAsBG,GAChCL,EAAUE,sBAAsBI,GAChCN,EAAUE,sBAAsBjD,GAChC+C,EAAUE,sBAAsBpC,GAChCkC,EAAUE,sBAAsBxB,GAChCsB,EAAUE,sBAAsBtB,GAChCoB,EAAUE,sBAAsBN,EAO/B,C,oCACD,SAAMW,GACF,MAAsB,kBAAXA,EACAjM,KAAKkM,OAAOD,IAGnB9K,QAAQgL,MAAM,0CAA6CF,GACpD,KAEd,G,mCACD,SAAsBG,GAClB,IAAMC,EAAW,IAAID,EACrBpM,KAAK2L,gBAAgBU,EAAShJ,eAAiBgJ,CAClD,G,uBACD,SAAUJ,GACN,OAAOjM,KAAKsM,MAAML,EACrB,G,yBACD,SAAYM,GACR,IAAIC,EAAY,GACVC,EAAOzM,KACb,OAAO,IAAI0M,SAAQ,SAACC,EAAKC,GACrBL,EAAOM,GAAG,QAAQ,SAACC,GACfN,GAAaM,CAChB,IACDP,EAAOM,GAAG,OAAO,WACb,IACIF,EAAIF,EAAKP,OAAOM,GAInB,CAFD,MAAOO,GACHH,EAAIG,EACP,CACJ,IACDR,EAAOM,GAAG,SAAS,SAACE,GAChBH,EAAIG,EACP,GACJ,GACJ,G,oBACD,SAAOP,GACH,IAAMQ,EAAM,CAAC,EACTC,EAAa,EACXC,EAAgBV,EAAUW,MAAM,eAChC7L,EAAU,IAAIxB,EAAgBoN,GACpC,IAAK5L,EAAQlB,UACT,MAAMC,MAAM,cAChB,IACIoB,EADEgL,EAAOzM,KAkDb,SAASoN,IAKL,IAAIC,EAAc,KACdC,EAAe,KACbC,EAAS,CAAC,EAGhB,IADA9L,EAAOH,EAAQI,SACF,CACT,GAAI8L,EAAQ/L,EAAM,EAAG,UAAW,CACxB4L,IACAE,EAAOF,GAAeC,GAC1B,KACH,CACsB,IAAd7L,EAAKlB,MACN8M,IACAE,EAAOF,GAAeC,GAC1BD,EAAc5L,EAAKhB,OAID,KAAdgB,EAAKlB,KACL+M,EAAe,CAAE3L,EAAGF,EAAKhB,OAEN,KAAdgB,EAAKlB,KACV+M,EAAa1L,EAAIH,EAAKhB,MAEH,KAAdgB,EAAKlB,KACV+M,EAAazL,EAAIJ,EAAKhB,MAGtB6M,EAAe7L,EAAKhB,MAG5BgB,EAAOH,EAAQI,MAClB,CAGD,OADAD,EAAOH,EAAQI,OACR6L,CACV,CAID,SAASE,IACL,IAAMC,EAAS,CAAC,EAEhB,IADAjM,EAAOH,EAAQI,OACO,QAAfD,EAAKhB,QACJ+M,EAAQ/L,EAAM,EAAG,WAGrB,GAAI+L,EAAQ/L,EAAM,EAAG,SAAU,CAC3BL,IAAAA,MAAU,WACV,IAAM6E,EAAQ0H,IACdvM,IAAAA,MAAU,KACVwM,EAAa3H,GACRA,EAAMe,KAGP0G,EAAOzH,EAAMe,MAAQf,EAFrB7E,IAAAA,MAAU,sBAAwB6E,EAAMhE,OAAS,uBAGxD,MAEG4L,EAAkBpM,GAClBA,EAAOH,EAAQI,OAGvB,OAAOgM,CACV,CACD,SAASC,IACL,IAAM1H,EAAQ,CAAC,EAEf,IADAxE,EAAOH,EAAQI,OACO,QAAfD,EAAKhB,OAAiB,CACzB,OAAQgB,EAAKlB,MACT,KAAK,EACD0F,EAAM6H,SAAWrM,EAAKhB,MACtBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,EACDuE,EAAMe,KAAOvF,EAAKhB,MAClBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,EACDuE,EAAM8H,MAAQtM,EAAKhB,MACnBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,EACDuE,EAAMhE,OAASR,EAAKhB,MACpBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,EACDuE,EAAM9D,MAAQV,EAAKhB,MACnBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACDuE,EAAMoB,SAAWhG,EAAWI,GAC5BA,EAAOH,EAAQI,OACf,MACJ,KAAK,GACDuE,EAAM+H,cAAcvM,EAAKhB,OAAuB,GAAdgB,EAAKhB,OACvCgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACiB,GAAdD,EAAKhB,QAQLwF,EAAMjE,KAAOP,EAAKhB,OAEtBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,IAEDD,EAAOH,EAAQI,OACf,MACJ,KAAK,IACDuE,EAAMpD,YAAcpB,EAAKhB,MACzBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,EACD,GAAkB,UAAdD,EAAKhB,MACL,MACJwF,EAAMgI,SAAWC,GAAc,GAC/B,MACJ,QACIL,EAAkBpM,GAClBA,EAAOH,EAAQI,OAEvB,GAAI8L,EAAQ/L,EAAM,EAAG,UAAW,CAC5BA,EAAOH,EAAQI,OACf,KACH,CACJ,CACD,OAAOuE,CACV,CAKD,SAASkI,IACL,IAAMC,EAAS,CAAC,EAEhB,IADA3M,EAAOH,EAAQI,OACO,QAAfD,EAAKhB,QACJ+M,EAAQ/L,EAAM,EAAG,WADI,CAGrB+L,EAAQ/L,EAAM,EAAG,UACjBA,EAAOH,EAAQI,OACS2M,EAAiB5M,EAAKhB,QAE1CW,IAAAA,MAAUK,EAAKhB,MAAQ,YACvB2N,EAAOC,EAAiB5M,EAAKhB,OAAO6N,WAAaC,EAAW9M,GAC5DL,IAAAA,MAAU,MAGVA,IAAAA,MAAU,mBAAqBK,EAAKhB,QAKxCgB,EAAOH,EAAQI,MAEtB,CAED,OADAD,EAAOH,EAAQI,OACR0M,CACV,CACD,IAAMI,EAAqB,SAC3B,SAASD,EAAWjO,GAChB,IAAMmO,EAAkBJ,EAAiB/N,EAAMG,OACzCiO,EAAQ,CAAC,EACXC,EAAgB,EAEpB,IADAlN,EAAOH,EAAQI,QACP8L,EAAQ/L,EAAM,EAAG+M,IACrB,OAAQ/M,EAAKlB,MACT,KAAK,EACDmO,EAAMzM,OAASR,EAAKhB,MACpBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,IACDgN,EAAM7L,YAAcpB,EAAKhB,MACzBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,IACkB,oBAAfD,EAAKhB,OAKLoN,EAAkBpM,GAHlBA,EAAOH,EAAQI,OAMnB,MACJ,KAAK,GACDiN,EAAgBlN,EAAKhB,MACrBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,EACGD,EAAKhB,QAAUgO,EAAgBG,cAC/BF,EAAMD,EAAgBI,sBAAwBJ,EAAgBK,qBAG9DjB,EAAkBpM,GAClBA,EAAOH,EAAQI,QAEnB,MACJ,QACImM,EAAkBpM,GAClBA,EAAOH,EAAQI,OAG3B,IAAMqN,EAAeL,EAAMD,EAAgBI,sBAC3C,GAAIE,EAAc,CACd,IAAIC,EACID,EAAaE,cAAgBC,MACtBH,EAAajO,OAEW,kBAAlBiO,EACNI,OAAOC,KAAKL,GAAcjO,YADhC,EAKL6N,IAAkBK,GAClB5N,IAAAA,KAAS,UAAY4N,EAAc,IAAMP,EAAgBG,cAAgB,mBAAsBD,EACtG,CAED,OADAlN,EAAOH,EAAQI,OACRgN,CACV,CAqOD,IAAML,EAAmB,CACrBgB,MAAO,CACHR,qBAAsB,YACtBP,UAAW,WACXM,cAAe,QACfE,kBAzOR,WACI,IAAMQ,EAAY,GACdC,EAAW,CAAC,EAGhB,IAFAnO,IAAAA,MAAU,cACVK,EAAOH,EAAQI,QACP8L,EAAQ/L,EAAM,EAAG+M,IACrB,OAAQ/M,EAAKlB,MACT,KAAK,EACDgP,EAASvI,KAAOvF,EAAKhB,MACrBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASC,gBAAkBnO,EAAWI,GACtCA,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASE,iBAAmBpO,EAAWI,GACvCA,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAAStL,OAAS5C,EAAWI,GAC7BA,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASG,cAAgBrO,EAAWI,GACpCA,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASI,YAActO,EAAWI,GAClCA,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASK,YAAcvO,EAAWI,GAClCA,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASM,wBAA0BxO,EAAWI,GAC9CA,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASO,WAAazO,EAAWI,GACjCA,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASQ,WAAatO,EAAKhB,MAC3BgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASS,mBAAqBvO,EAAKhB,MACnCgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASU,kBAAoBxO,EAAKhB,MAClCgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASW,WAAazO,EAAKhB,MAC3BgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASY,kBAAoB1O,EAAKhB,MAClCgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASa,eAAiB3O,EAAKhB,MAC/BgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACD6N,EAASc,iBAAmB5O,EAAKhB,MACjCgB,EAAOH,EAAQI,OACf,MACJ,KAAK,IAYL,KAAK,IACD6N,EAASe,UAAYjP,EAAWI,GAChCA,EAAOH,EAAQI,OACf,MAXJ,KAAK,IACD6N,EAASgB,SAAWlP,EAAWI,GAC/BA,EAAOH,EAAQI,OACf,MACJ,KAAK,IACD6N,EAASiB,SAAWnP,EAAWI,GAC/BA,EAAOH,EAAQI,OACf,MAKJ,KAAK,IACD6N,EAASkB,WAAahP,EAAKhB,MAC3BgB,EAAOH,EAAQI,OACf,MACJ,KAAK,IAED6N,EAASmB,oBAAsBjP,EAAKhB,MACpCgB,EAAOH,EAAQI,OACf,MACJ,KAAK,IACD6N,EAASoB,kBAAoBlP,EAAKhB,MAClCgB,EAAOH,EAAQI,OACf,MACJ,KAAK,IACD6N,EAAS1M,YAAcpB,EAAKhB,MAC5BgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACL,KAAK,IACL,KAAK,IACD6N,EAASqB,aAAenP,EAAKhB,MAC7BgB,EAAOH,EAAQI,OACf,MACJ,KAAK,EAEkB,UAAfD,EAAKhB,QACLW,IAAAA,MAAU,KACVkO,EAAUpM,KAAKqM,GACfnO,IAAAA,MAAU,cACVmO,EAAW,CAAC,EACZ9N,EAAOH,EAAQI,QAEnB,MACJ,QACImM,EAAkBpM,GAClBA,EAAOH,EAAQI,OAQ3B,OAFAN,IAAAA,MAAU,KACVkO,EAAUpM,KAAKqM,GACRD,CACV,GAwGGuB,MAAO,CACHhC,qBAAsB,YACtBP,UAAW,WACXM,cAAe,QACfE,kBA3GR,WACI,IAGIgC,EAHEC,EAAS,CAAC,EACZC,EAAQ,CAAC,EACTlQ,EAAS,EAIb,IAFAM,IAAAA,MAAU,WACVK,EAAOH,EAAQI,QACP8L,EAAQ/L,EAAM,EAAG,WACrB,OAAQA,EAAKlB,MACT,KAAK,EACDyQ,EAAMhK,KAAOvF,EAAKhB,MAClBqQ,EAAYrP,EAAKhB,MACjBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,EACDsP,EAAMC,YAAcxP,EAAKhB,MACzBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,IACDZ,EAASW,EAAKhB,OACD,IACTuQ,EAAME,QAAU,IACpBzP,EAAOH,EAAQI,OACf,MACJ,KAAK,GACDsP,EAAMG,cAAgB1P,EAAKhB,MAC3BgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACDsP,EAAME,QAAQhO,KAAKzB,EAAKhB,OACxBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,EACDN,IAAAA,MAAU,KACNN,EAAS,GAAKA,IAAWkQ,EAAME,QAAQpQ,QACvCM,IAAAA,KAAS,yCACb2P,EAAOD,GAAaE,EACpBA,EAAQ,CAAC,EACT5P,IAAAA,MAAU,WACVK,EAAOH,EAAQI,OACf,MACJ,QACID,EAAOH,EAAQI,OAK3B,OAFAN,IAAAA,MAAU,KACV2P,EAAOD,GAAaE,EACbD,CACV,GA6DGK,MAAO,CACHvC,qBAAsB,SACtBP,UAAW,QACXM,cAAe,QACfE,kBAhER,WACI,IAEIuC,EAyJM7O,EA3JJ8O,EAAS,CAAC,EACZnP,EAAQ,CAAC,EAIb,IAFAf,IAAAA,MAAU,WACVK,EAAOH,EAAQI,QACP8L,EAAQ/L,EAAM,EAAG,WACrB,OAAQA,EAAKlB,MACT,KAAK,EACD4B,EAAM6E,KAAOvF,EAAKhB,MAClB4Q,EAAY5P,EAAKhB,MACjBgB,EAAOH,EAAQI,OACf,MACJ,KAAK,GACDS,EAAME,QAAUZ,EAAKhB,OAAS,EAE9B0B,EAAMG,WAAaG,KAAKC,IAAIjB,EAAKhB,OACjC0B,EAAMI,OA2IRC,EA3I6BL,EAAMG,WA4I9CK,EAAqBH,IA3IRf,EAAOH,EAAQI,OACf,MACJ,KAAK,GACDS,EAAMoP,OAA8B,IAAN,EAAb9P,EAAKhB,QAAuC,IAAN,EAAbgB,EAAKhB,OAC/CgB,EAAOH,EAAQI,OACf,MACJ,KAAK,EAEkB,UAAfD,EAAKhB,QACLW,IAAAA,MAAU,KACVkQ,EAAOD,GAAalP,EACpBf,IAAAA,MAAU,WACVe,EAAQ,CAAC,EACTkP,OAAYG,EACZ/P,EAAOH,EAAQI,QAEnB,MACJ,QACImM,EAAkBpM,GAClBA,EAAOH,EAAQI,OAQ3B,OAFAN,IAAAA,MAAU,KACVkQ,EAAOD,GAAalP,EACbmP,CACV,IA0BD,SAASpD,EAAcuD,GACnB,IAAMxD,EAAW,GACXyD,EAAgBD,EAAW,SAAW,SAI5C,IAHKA,IACDhQ,EAAOH,EAAQI,UAGf,GAAkB,IAAdD,EAAKlB,KAAY,CACjB,GAAIkB,EAAKhB,QAAUiR,EACf,MAEJ,IAAMC,EAAUlF,EAAKd,gBAAgBlK,EAAKhB,OAC1C,GAAe,MAAXkR,EAQC,CACDvQ,IAAAA,KAAS,oBAAsBK,EAAKhB,OACpCgB,EAAOH,EAAQI,OACf,QACH,CAXGN,IAAAA,MAAUK,EAAKhB,MAAQ,MACvB,IAAMsB,EAAS4P,EAAQ1H,YAAY3I,EAASG,GAC5CA,EAAOH,EAAQV,cACfQ,IAAAA,MAAU,KACVwM,EAAa7L,GACbkM,EAAS/K,KAAKnB,EAOrB,MAGGN,EAAOH,EAAQI,OAKvB,MAFqB,UAAjBgQ,IACAjQ,EAAOH,EAAQI,QACZuM,CACV,CAQD,SAAS5M,EAAWI,GAChB,IAAMF,EAAQ,CAAC,EACXhB,EAAOkB,EAAKlB,KAIhB,GAHAgB,EAAMI,EAAIF,EAAKhB,MACfF,GAAQ,IACRkB,EAAOH,EAAQI,QACNnB,MAAQA,EACb,MAAM,IAAIF,MAAM,uCAAyCE,EACrD,YAAckB,EAAKlB,KAAO,KAIlC,OAHAgB,EAAMK,EAAIH,EAAKhB,MACfF,GAAQ,IACRkB,EAAOH,EAAQI,QACNnB,MAAQA,GACbe,EAAQE,SACDD,IAEXA,EAAMM,EAAIJ,EAAKhB,MACRc,EACV,CACD,SAASqM,EAAa7L,GAClB,IAAKA,EACD,MAAM,IAAId,UAAU,sCACnBc,EAAOE,SACRF,EAAOE,OAASgL,IACvB,CAED,OAvlBA,WAEI,IADAxL,EAAOH,EAAQI,QACPJ,EAAQiC,SACZ,GAAkB,IAAd9B,EAAKlB,MAA6B,YAAfkB,EAAKhB,MAAqB,CAG7C,GAAkB,KAFlBgB,EAAOH,EAAQI,QAENnB,KAAY,CACjBY,QAAQgL,MAAM,qCAAsCyF,EAAUnQ,IAC9DA,EAAOH,EAAQI,OACf,QACH,CACkB,WAAfD,EAAKhB,OACLW,IAAAA,MAAU,YACV4L,EAAIO,OAASH,IACbhM,IAAAA,MAAU,MAEU,WAAfK,EAAKhB,OACVW,IAAAA,MAAU,YACV4L,EAAIU,OAASD,IACbrM,IAAAA,MAAU,MAEU,aAAfK,EAAKhB,OACVW,IAAAA,MAAU,cACV4L,EAAIiB,SAAWC,GAAc,GAC7B9M,IAAAA,MAAU,MAEU,WAAfK,EAAKhB,OACVW,IAAAA,MAAU,YACV4L,EAAIoB,OAASD,IACb/M,IAAAA,MAAU,MAEU,QAAfK,EAAKhB,MACVW,IAAAA,MAAU,OAGVA,IAAAA,KAAS,wBAA2BK,EAAKhB,MAEhD,MAEGgB,EAAOH,EAAQI,MAI1B,CA2iBDmQ,GACO7E,CACV,K,EA1oBgBvB,GA4oBrB,SAAS+B,EAAQlN,EAAOC,EAAME,GAC1B,OAAOH,EAAMC,OAASA,GAAQD,EAAMG,QAAUA,CACjD,CACD,SAASoN,EAAkBpM,GACvBL,IAAAA,MAAU,mBAAqBwQ,EAAUnQ,GAC5C,CACD,SAASmQ,EAAUnQ,GACf,OAAOA,EAAKlB,KAAO,IAAMkB,EAAKhB,KACjC,CC7rBD,O,wBCFA,SAMC,SAAUqR,EAAMC,GACb,aAEIC,EAMA,WAIJ,IAAIC,EAAO,WAAa,EACpBC,EAAgB,YAChBC,SAAeC,SAAWF,UAA0BE,OAAOC,YAAcH,GACzE,kBAAkBI,KAAKF,OAAOC,UAAUE,WAGxCC,EAAa,CACb,QACA,QACA,OACA,OACA,SAIJ,SAASC,EAAWC,EAAKC,GACrB,IAAIC,EAASF,EAAIC,GACjB,GAA2B,oBAAhBC,EAAOC,KACd,OAAOD,EAAOC,KAAKH,GAEnB,IACI,OAAOI,SAASC,UAAUF,KAAKG,KAAKJ,EAAQF,EAM/C,CALC,MAAOO,GAEL,OAAO,WACH,OAAOH,SAASC,UAAUG,MAAMA,MAAMN,EAAQ,CAACF,EAAKS,WACvD,CACJ,CAER,CAGD,SAASC,IACDjS,QAAQC,MACJD,QAAQC,IAAI8R,MACZ/R,QAAQC,IAAI8R,MAAM/R,QAASgS,WAG3BL,SAASC,UAAUG,MAAMA,MAAM/R,QAAQC,IAAK,CAACD,QAASgS,aAG1DhS,QAAQkS,OAAOlS,QAAQkS,OAC9B,CAID,SAASC,EAAWX,GAKhB,MAJmB,UAAfA,IACAA,EAAa,cAGNxR,UAAY+Q,IAEG,UAAfS,GAA0BR,EAC1BiB,OACwB5B,IAAxBrQ,QAAQwR,GACRF,EAAWtR,QAASwR,QACJnB,IAAhBrQ,QAAQC,IACRqR,EAAWtR,QAAS,OAEpB8Q,EAEd,CAID,SAASsB,EAAsBC,EAAOC,GAElC,IAAK,IAAI3P,EAAI,EAAGA,EAAI0O,EAAW1R,OAAQgD,IAAK,CACxC,IAAI6O,EAAaH,EAAW1O,GAC5B9D,KAAK2S,GAAe7O,EAAI0P,EACpBvB,EACAjS,KAAK0T,cAAcf,EAAYa,EAAOC,EAC7C,CAGDzT,KAAKoB,IAAMpB,KAAK2T,KACnB,CAID,SAASC,EAAgCjB,EAAYa,EAAOC,GACxD,OAAO,kBACQtS,UAAY+Q,IACnBqB,EAAsBP,KAAKhT,KAAMwT,EAAOC,GACxCzT,KAAK2S,GAAYO,MAAMlT,KAAMmT,WAEpC,CACJ,CAID,SAASU,EAAqBlB,EAAYa,EAAOC,GAE7C,OAAOH,EAAWX,IACXiB,EAAgCV,MAAMlT,KAAMmT,UACtD,CAED,SAASW,EAAO9M,EAAM+M,EAAcC,GAClC,IACIC,EADAxH,EAAOzM,KAEX+T,EAA+B,MAAhBA,EAAuB,OAASA,EAE/C,IAAIG,EAAa,WAOjB,SAASC,EAAuBC,GAC5B,IAAIC,GAAa7B,EAAW4B,IAAa,UAAUE,cAEnD,UAAWlC,SAAWF,GAAkBgC,EAAxC,CAGA,IAEI,YADA9B,OAAOmC,aAAaL,GAAcG,EAEnB,CAAjB,MAAOG,GAAU,CAGnB,IACIpC,OAAOqC,SAASC,OACdC,mBAAmBT,GAAc,IAAMG,EAAY,GACtC,CAAjB,MAAOG,GAAU,CAZuC,CAa7D,CAED,SAASI,IACL,IAAIC,EAEJ,UAAWzC,SAAWF,GAAkBgC,EAAxC,CAEA,IACIW,EAAczC,OAAOmC,aAAaL,EACnB,CAAjB,MAAOM,GAAU,CAGnB,UAAWK,IAAgB3C,EACvB,IACI,IAAIwC,EAAStC,OAAOqC,SAASC,OACzBI,EAAWJ,EAAOK,QAClBJ,mBAAmBT,GAAc,MACnB,IAAdY,IACAD,EAAc,WAAWG,KAAKN,EAAOO,MAAMH,IAAW,GAE3C,CAAjB,MAAON,GAAU,CAQvB,YAJiChD,IAA7B/E,EAAKyI,OAAOL,KACZA,OAAcrD,GAGXqD,CAvBmD,CAwB7D,CAED,SAASM,IACL,UAAW/C,SAAWF,GAAkBgC,EAAxC,CAGA,IAEI,YADA9B,OAAOmC,aAAaa,WAAWlB,EAEhB,CAAjB,MAAOM,GAAU,CAGnB,IACIpC,OAAOqC,SAASC,OACdC,mBAAmBT,GAAc,0CACpB,CAAjB,MAAOM,GAAU,CAZuC,CAa7D,CAnEmB,kBAATxN,EACTkN,GAAc,IAAMlN,EACK,kBAATA,IAChBkN,OAAa1C,GAwEf/E,EAAKzF,KAAOA,EAEZyF,EAAKyI,OAAS,CAAE,MAAS,EAAG,MAAS,EAAG,KAAQ,EAAG,KAAQ,EACvD,MAAS,EAAG,OAAU,GAE1BzI,EAAKiH,cAAgBM,GAAWH,EAEhCpH,EAAK4I,SAAW,WACZ,OAAOpB,CACV,EAEDxH,EAAK6I,SAAW,SAAU9B,EAAO+B,GAI7B,GAHqB,kBAAV/B,QAA2DhC,IAArC/E,EAAKyI,OAAO1B,EAAMc,iBAC/Cd,EAAQ/G,EAAKyI,OAAO1B,EAAMc,kBAET,kBAAVd,GAAsBA,GAAS,GAAKA,GAAS/G,EAAKyI,OAAOM,QAUhE,KAAM,6CAA+ChC,EAJrD,GALAS,EAAeT,GACC,IAAZ+B,GACApB,EAAuBX,GAE3BD,EAAsBP,KAAKvG,EAAM+G,EAAOxM,UAC7B7F,UAAY+Q,GAAiBsB,EAAQ/G,EAAKyI,OAAOM,OACxD,MAAO,kCAKlB,EAED/I,EAAKgJ,gBAAkB,SAAUjC,GAC7BO,EAAeP,EACVoB,KACDnI,EAAK6I,SAAS9B,GAAO,EAE5B,EAED/G,EAAKiJ,WAAa,WACdjJ,EAAK6I,SAASvB,GAAc,GAC5BoB,GACH,EAED1I,EAAKkJ,UAAY,SAASJ,GACtB9I,EAAK6I,SAAS7I,EAAKyI,OAAOU,MAAOL,EACpC,EAED9I,EAAKoJ,WAAa,SAASN,GACvB9I,EAAK6I,SAAS7I,EAAKyI,OAAOM,OAAQD,EACrC,EAGD,IAAIO,EAAelB,IACC,MAAhBkB,IACAA,EAAe/B,GAEnBtH,EAAK6I,SAASQ,GAAc,EAC7B,CAQD,IAAIC,EAAgB,IAAIjC,EAEpBkC,EAAiB,CAAC,EACtBD,EAAcE,UAAY,SAAmBjP,GACzC,GAAqB,kBAATA,GAAqC,kBAATA,GAA+B,KAATA,EAC5D,MAAM,IAAI/F,UAAU,kDAGtB,IAAIiV,EAASF,EAAehP,GAK5B,OAJKkP,IACHA,EAASF,EAAehP,GAAQ,IAAI8M,EAClC9M,EAAM+O,EAAcV,WAAYU,EAAcrC,gBAE3CwC,CACV,EAGD,IAAIC,SAAe/D,SAAWF,EAAiBE,OAAOhR,SAAMoQ,EAiB5D,OAhBAuE,EAAcK,WAAa,WAMvB,cALWhE,SAAWF,GACfE,OAAOhR,MAAQ2U,IAClB3D,OAAOhR,IAAM+U,GAGVJ,CACV,EAEDA,EAAcM,WAAa,WACvB,OAAOL,CACV,EAGDD,EAAa,QAAcA,EAEpBA,CACV,OA/Ra,8DAHb,G","sources":["webpack://ciqo/./node_modules/dxf-parser/dist/DxfArrayScanner.js","webpack://ciqo/./node_modules/dxf-parser/dist/AutoCadColorIndex.js","webpack://ciqo/./node_modules/dxf-parser/dist/ParseHelpers.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/3dface.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/arc.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/attdef.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/circle.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/dimension.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/ellipse.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/insert.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/line.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/lwpolyline.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/mtext.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/point.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/vertex.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/polyline.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/solid.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/spline.js","webpack://ciqo/./node_modules/dxf-parser/dist/entities/text.js","webpack://ciqo/./node_modules/dxf-parser/dist/DxfParser.js","webpack://ciqo/./node_modules/dxf-parser/dist/index.js","webpack://ciqo/./node_modules/loglevel/lib/loglevel.js"],"sourcesContent":["/**\n * DxfArrayScanner\n *\n * Based off the AutoCad 2012 DXF Reference\n * http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf\n *\n * Reads through an array representing lines of a dxf file. Takes an array and\n * provides an easy interface to extract group code and value pairs.\n * @param data - an array where each element represents a line in the dxf file\n * @constructor\n */\nexport default class DxfArrayScanner {\n    constructor(data) {\n        this._pointer = 0;\n        this._eof = false;\n        this._data = data;\n    }\n    /**\n     * Gets the next group (code, value) from the array. A group is two consecutive elements\n     * in the array. The first is the code, the second is the value.\n     * @returns {{code: Number}|*}\n     */\n    next() {\n        if (!this.hasNext()) {\n            if (!this._eof)\n                throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\n            else\n                throw new Error('Cannot call \\'next\\' after EOF group has been read');\n        }\n        const group = {\n            code: parseInt(this._data[this._pointer])\n        };\n        this._pointer++;\n        group.value = parseGroupValue(group.code, this._data[this._pointer].trim());\n        this._pointer++;\n        if (group.code === 0 && group.value === 'EOF')\n            this._eof = true;\n        this.lastReadGroup = group;\n        return group;\n    }\n    peek() {\n        if (!this.hasNext()) {\n            if (!this._eof)\n                throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\n            else\n                throw new Error('Cannot call \\'next\\' after EOF group has been read');\n        }\n        const group = {\n            code: parseInt(this._data[this._pointer])\n        };\n        group.value = parseGroupValue(group.code, this._data[this._pointer + 1].trim());\n        return group;\n    }\n    rewind(numberOfGroups = 1) {\n        this._pointer = this._pointer - numberOfGroups * 2;\n    }\n    /**\n     * Returns true if there is another code/value pair (2 elements in the array).\n     * @returns {boolean}\n     */\n    hasNext() {\n        // Check if we have read EOF group code\n        if (this._eof) {\n            return false;\n        }\n        // We need to be sure there are two lines available\n        if (this._pointer > this._data.length - 2) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns true if the scanner is at the end of the array\n     * @returns {boolean}\n     */\n    isEOF() {\n        return this._eof;\n    }\n}\n/**\n * Parse a value to its proper type.\n * See pages 3 - 10 of the AutoCad DXF 2012 reference given at the top of this file\n *\n * @param code\n * @param value\n * @returns {*}\n */\nfunction parseGroupValue(code, value) {\n    if (code <= 9)\n        return value;\n    if (code >= 10 && code <= 59)\n        return parseFloat(value);\n    if (code >= 60 && code <= 99)\n        return parseInt(value);\n    if (code >= 100 && code <= 109)\n        return value;\n    if (code >= 110 && code <= 149)\n        return parseFloat(value);\n    if (code >= 160 && code <= 179)\n        return parseInt(value);\n    if (code >= 210 && code <= 239)\n        return parseFloat(value);\n    if (code >= 270 && code <= 289)\n        return parseInt(value);\n    if (code >= 290 && code <= 299)\n        return parseBoolean(value);\n    if (code >= 300 && code <= 369)\n        return value;\n    if (code >= 370 && code <= 389)\n        return parseInt(value);\n    if (code >= 390 && code <= 399)\n        return value;\n    if (code >= 400 && code <= 409)\n        return parseInt(value);\n    if (code >= 410 && code <= 419)\n        return value;\n    if (code >= 420 && code <= 429)\n        return parseInt(value);\n    if (code >= 430 && code <= 439)\n        return value;\n    if (code >= 440 && code <= 459)\n        return parseInt(value);\n    if (code >= 460 && code <= 469)\n        return parseFloat(value);\n    if (code >= 470 && code <= 481)\n        return value;\n    if (code === 999)\n        return value;\n    if (code >= 1000 && code <= 1009)\n        return value;\n    if (code >= 1010 && code <= 1059)\n        return parseFloat(value);\n    if (code >= 1060 && code <= 1071)\n        return parseInt(value);\n    console.log('WARNING: Group code does not have a defined type: %j', { code: code, value: value });\n    return value;\n}\n/**\n * Parse a boolean according to a 1 or 0 value\n * @param str\n * @returns {boolean}\n */\nfunction parseBoolean(str) {\n    if (str === '0')\n        return false;\n    if (str === '1')\n        return true;\n    throw TypeError('String \\'' + str + '\\' cannot be cast to Boolean type');\n}\n","/**\n * AutoCad files sometimes use an indexed color value between 1 and 255 inclusive.\n * Each value corresponds to a color. index 1 is red, that is 16711680 or 0xFF0000.\n * index 0 and 256, while included in this array, are actually reserved for inheritance\n * values in AutoCad so they should not be used for index color lookups.\n */\nexport default [\n    0,\n    16711680,\n    16776960,\n    65280,\n    65535,\n    255,\n    16711935,\n    16777215,\n    8421504,\n    12632256,\n    16711680,\n    16744319,\n    13369344,\n    13395558,\n    10027008,\n    10046540,\n    8323072,\n    8339263,\n    4980736,\n    4990502,\n    16727808,\n    16752511,\n    13382400,\n    13401958,\n    10036736,\n    10051404,\n    8331008,\n    8343359,\n    4985600,\n    4992806,\n    16744192,\n    16760703,\n    13395456,\n    13408614,\n    10046464,\n    10056268,\n    8339200,\n    8347455,\n    4990464,\n    4995366,\n    16760576,\n    16768895,\n    13408512,\n    13415014,\n    10056192,\n    10061132,\n    8347392,\n    8351551,\n    4995328,\n    4997670,\n    16776960,\n    16777087,\n    13421568,\n    13421670,\n    10000384,\n    10000460,\n    8355584,\n    8355647,\n    5000192,\n    5000230,\n    12582656,\n    14679935,\n    10079232,\n    11717734,\n    7510016,\n    8755276,\n    6258432,\n    7307071,\n    3755008,\n    4344870,\n    8388352,\n    12582783,\n    6736896,\n    10079334,\n    5019648,\n    7510092,\n    4161280,\n    6258495,\n    2509824,\n    3755046,\n    4194048,\n    10485631,\n    3394560,\n    8375398,\n    2529280,\n    6264908,\n    2064128,\n    5209919,\n    1264640,\n    3099686,\n    65280,\n    8388479,\n    52224,\n    6736998,\n    38912,\n    5019724,\n    32512,\n    4161343,\n    19456,\n    2509862,\n    65343,\n    8388511,\n    52275,\n    6737023,\n    38950,\n    5019743,\n    32543,\n    4161359,\n    19475,\n    2509871,\n    65407,\n    8388543,\n    52326,\n    6737049,\n    38988,\n    5019762,\n    32575,\n    4161375,\n    19494,\n    2509881,\n    65471,\n    8388575,\n    52377,\n    6737074,\n    39026,\n    5019781,\n    32607,\n    4161391,\n    19513,\n    2509890,\n    65535,\n    8388607,\n    52428,\n    6737100,\n    39064,\n    5019800,\n    32639,\n    4161407,\n    19532,\n    2509900,\n    49151,\n    8380415,\n    39372,\n    6730444,\n    29336,\n    5014936,\n    24447,\n    4157311,\n    14668,\n    2507340,\n    32767,\n    8372223,\n    26316,\n    6724044,\n    19608,\n    5010072,\n    16255,\n    4153215,\n    9804,\n    2505036,\n    16383,\n    8364031,\n    13260,\n    6717388,\n    9880,\n    5005208,\n    8063,\n    4149119,\n    4940,\n    2502476,\n    255,\n    8355839,\n    204,\n    6710988,\n    152,\n    5000344,\n    127,\n    4145023,\n    76,\n    2500172,\n    4129023,\n    10452991,\n    3342540,\n    8349388,\n    2490520,\n    6245528,\n    2031743,\n    5193599,\n    1245260,\n    3089996,\n    8323327,\n    12550143,\n    6684876,\n    10053324,\n    4980888,\n    7490712,\n    4128895,\n    6242175,\n    2490444,\n    3745356,\n    12517631,\n    14647295,\n    10027212,\n    11691724,\n    7471256,\n    8735896,\n    6226047,\n    7290751,\n    3735628,\n    4335180,\n    16711935,\n    16744447,\n    13369548,\n    13395660,\n    9961624,\n    9981080,\n    8323199,\n    8339327,\n    4980812,\n    4990540,\n    16711871,\n    16744415,\n    13369497,\n    13395634,\n    9961586,\n    9981061,\n    8323167,\n    8339311,\n    4980793,\n    4990530,\n    16711807,\n    16744383,\n    13369446,\n    13395609,\n    9961548,\n    9981042,\n    8323135,\n    8339295,\n    4980774,\n    4990521,\n    16711743,\n    16744351,\n    13369395,\n    13395583,\n    9961510,\n    9981023,\n    8323103,\n    8339279,\n    4980755,\n    4990511,\n    3355443,\n    5987163,\n    8684676,\n    11382189,\n    14079702,\n    16777215\n];\n","import AUTO_CAD_COLOR_INDEX from './AutoCadColorIndex';\n/**\n * Returns the truecolor value of the given AutoCad color index value\n * @return {Number} truecolor value as a number\n */\nexport function getAcadColor(index) {\n    return AUTO_CAD_COLOR_INDEX[index];\n}\n/**\n * Parses the 2D or 3D coordinate, vector, or point. When complete,\n * the scanner remains on the last group of the coordinate.\n * @param {*} scanner\n */\nexport function parsePoint(scanner) {\n    const point = {};\n    // Reread group for the first coordinate\n    scanner.rewind();\n    let curr = scanner.next();\n    let code = curr.code;\n    point.x = curr.value;\n    code += 10;\n    curr = scanner.next();\n    if (curr.code != code)\n        throw new Error('Expected code for point value to be ' + code +\n            ' but got ' + curr.code + '.');\n    point.y = curr.value;\n    code += 10;\n    curr = scanner.next();\n    if (curr.code != code) {\n        // Only the x and y are specified. Don't read z.\n        scanner.rewind(); // Let the calling code advance off the point\n        return point;\n    }\n    point.z = curr.value;\n    return point;\n}\n/**\n * Attempts to parse codes common to all entities. Returns true if the group\n * was handled by this function.\n * @param {*} entity - the entity currently being parsed\n * @param {*} curr - the current group being parsed\n */\nexport function checkCommonEntityProperties(entity, curr, scanner) {\n    switch (curr.code) {\n        case 0:\n            entity.type = curr.value;\n            break;\n        case 5:\n            entity.handle = curr.value;\n            break;\n        case 6:\n            entity.lineType = curr.value;\n            break;\n        case 8: // Layer name\n            entity.layer = curr.value;\n            break;\n        case 48:\n            entity.lineTypeScale = curr.value;\n            break;\n        case 60:\n            entity.visible = curr.value === 0;\n            break;\n        case 62: // Acad Index Color. 0 inherits ByBlock. 256 inherits ByLayer. Default is bylayer\n            entity.colorIndex = curr.value;\n            entity.color = getAcadColor(Math.abs(curr.value));\n            break;\n        case 67:\n            entity.inPaperSpace = curr.value !== 0;\n            break;\n        case 100:\n            //ignore\n            break;\n        case 101: // Embedded Object in ACAD 2018.\n            // See https://ezdxf.readthedocs.io/en/master/dxfinternals/dxftags.html#embedded-objects\n            while (curr.code != 0) {\n                curr = scanner.next();\n            }\n            scanner.rewind();\n            break;\n        case 330:\n            entity.ownerHandle = curr.value;\n            break;\n        case 347:\n            entity.materialObjectHandle = curr.value;\n            break;\n        case 370:\n            //From https://www.woutware.com/Forum/Topic/955/lineweight?returnUrl=%2FForum%2FUserPosts%3FuserId%3D478262319\n            // An integer representing 100th of mm, must be one of the following values:\n            // 0, 5, 9, 13, 15, 18, 20, 25, 30, 35, 40, 50, 53, 60, 70, 80, 90, 100, 106, 120, 140, 158, 200, 211.\n            // -3 = STANDARD, -2 = BYLAYER, -1 = BYBLOCK\n            entity.lineweight = curr.value;\n            break;\n        case 420: // TrueColor Color\n            entity.color = curr.value;\n            break;\n        case 1000:\n            entity.extendedData = entity.extendedData || {};\n            entity.extendedData.customStrings = entity.extendedData.customStrings || [];\n            entity.extendedData.customStrings.push(curr.value);\n            break;\n        case 1001:\n            entity.extendedData = entity.extendedData || {};\n            entity.extendedData.applicationName = curr.value;\n            break;\n        default:\n            return false;\n    }\n    return true;\n}\n","import * as helpers from '../ParseHelpers';\nexport default class ThreeDface {\n    constructor() {\n        this.ForEntityName = '3DFACE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, vertices: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\n                    entity.shape = ((curr.value & 1) === 1);\n                    entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\n                    break;\n                case 10: // X coordinate of point\n                    entity.vertices = parse3dFaceVertices(scanner, curr);\n                    curr = scanner.lastReadGroup;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\nfunction parse3dFaceVertices(scanner, curr) {\n    var vertices = [];\n    var vertexIsStarted = false;\n    var vertexIsFinished = false;\n    var verticesPer3dFace = 4; // there can be up to four vertices per face, although 3 is most used for TIN\n    for (let i = 0; i <= verticesPer3dFace; i++) {\n        var vertex = {};\n        while (!scanner.isEOF()) {\n            if (curr.code === 0 || vertexIsFinished)\n                break;\n            switch (curr.code) {\n                case 10: // X0\n                case 11: // X1\n                case 12: // X2\n                case 13: // X3\n                    if (vertexIsStarted) {\n                        vertexIsFinished = true;\n                        continue;\n                    }\n                    vertex.x = curr.value;\n                    vertexIsStarted = true;\n                    break;\n                case 20: // Y\n                case 21:\n                case 22:\n                case 23:\n                    vertex.y = curr.value;\n                    break;\n                case 30: // Z\n                case 31:\n                case 32:\n                case 33:\n                    vertex.z = curr.value;\n                    break;\n                default:\n                    // it is possible to have entity codes after the vertices.  \n                    // So if code is not accounted for return to entity parser where it might be accounted for\n                    return vertices;\n            }\n            curr = scanner.next();\n        }\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\n        vertices.push(vertex);\n        vertexIsStarted = false;\n        vertexIsFinished = false;\n    }\n    scanner.rewind();\n    return vertices;\n}\n;\n","import * as helpers from '../ParseHelpers';\nexport default class Arc {\n    constructor() {\n        this.ForEntityName = 'ARC';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of point\n                    entity.center = helpers.parsePoint(scanner);\n                    break;\n                case 40: // radius\n                    entity.radius = curr.value;\n                    break;\n                case 50: // start angle\n                    entity.startAngle = Math.PI / 180 * curr.value;\n                    break;\n                case 51: // end angle\n                    entity.endAngle = Math.PI / 180 * curr.value;\n                    entity.angleLength = entity.endAngle - entity.startAngle; // angleLength is deprecated\n                    break;\n                case 210:\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220:\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230:\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                default: // ignored attribute\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Attdef {\n    constructor() {\n        this.ForEntityName = 'ATTDEF';\n    }\n    parseEntity(scanner, curr) {\n        var entity = {\n            type: curr.value,\n            scale: 1,\n            textStyle: 'STANDARD'\n        };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0) {\n                break;\n            }\n            switch (curr.code) {\n                case 1:\n                    entity.text = curr.value;\n                    break;\n                case 2:\n                    entity.tag = curr.value;\n                    break;\n                case 3:\n                    entity.prompt = curr.value;\n                    break;\n                case 7:\n                    entity.textStyle = curr.value;\n                    break;\n                case 10: // X coordinate of 'first alignment point'\n                    entity.startPoint = helpers.parsePoint(scanner);\n                    break;\n                case 11: // X coordinate of 'second alignment point'\n                    entity.endPoint = helpers.parsePoint(scanner);\n                    break;\n                case 39:\n                    entity.thickness = curr.value;\n                    break;\n                case 40:\n                    entity.textHeight = curr.value;\n                    break;\n                case 41:\n                    entity.scale = curr.value;\n                    break;\n                case 50:\n                    entity.rotation = curr.value;\n                    break;\n                case 51:\n                    entity.obliqueAngle = curr.value;\n                    break;\n                case 70:\n                    entity.invisible = !!(curr.value & 0x01);\n                    entity.constant = !!(curr.value & 0x02);\n                    entity.verificationRequired = !!(curr.value & 0x04);\n                    entity.preset = !!(curr.value & 0x08);\n                    break;\n                case 71:\n                    entity.backwards = !!(curr.value & 0x02);\n                    entity.mirrored = !!(curr.value & 0x04);\n                    break;\n                case 72:\n                    // TODO: enum values?\n                    entity.horizontalJustification = curr.value;\n                    break;\n                case 73:\n                    entity.fieldLength = curr.value;\n                    break;\n                case 74:\n                    // TODO: enum values?\n                    entity.verticalJustification = curr.value;\n                    break;\n                case 100:\n                    break;\n                case 210:\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220:\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230:\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Circle {\n    constructor() {\n        this.ForEntityName = 'CIRCLE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of point\n                    entity.center = helpers.parsePoint(scanner);\n                    break;\n                case 40: // radius\n                    entity.radius = curr.value;\n                    break;\n                case 50: // start angle\n                    entity.startAngle = Math.PI / 180 * curr.value;\n                    break;\n                case 51: // end angle\n                    const endAngle = Math.PI / 180 * curr.value;\n                    if (endAngle < entity.startAngle)\n                        entity.angleLength = endAngle + 2 * Math.PI - entity.startAngle;\n                    else\n                        entity.angleLength = endAngle - entity.startAngle;\n                    entity.endAngle = endAngle;\n                    break;\n                default: // ignored attribute\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Dimension {\n    constructor() {\n        this.ForEntityName = 'DIMENSION';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 2: // Referenced block name\n                    entity.block = curr.value;\n                    break;\n                case 10: // X coordinate of 'first alignment point'\n                    entity.anchorPoint = helpers.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.middleOfText = helpers.parsePoint(scanner);\n                    break;\n                case 12: // Insertion point for clones of a dimension\n                    entity.insertionPoint = helpers.parsePoint(scanner);\n                    break;\n                case 13: // Definition point for linear and angular dimensions \n                    entity.linearOrAngularPoint1 = helpers.parsePoint(scanner);\n                    break;\n                case 14: // Definition point for linear and angular dimensions \n                    entity.linearOrAngularPoint2 = helpers.parsePoint(scanner);\n                    break;\n                case 15: // Definition point for diameter, radius, and angular dimensions\n                    entity.diameterOrRadiusPoint = helpers.parsePoint(scanner);\n                    break;\n                case 16: // Point defining dimension arc for angular dimensions\n                    entity.arcPoint = helpers.parsePoint(scanner);\n                    break;\n                case 70: // Dimension type\n                    entity.dimensionType = curr.value;\n                    break;\n                case 71: // 5 = Middle center\n                    entity.attachmentPoint = curr.value;\n                    break;\n                case 42: // Actual measurement\n                    entity.actualMeasurement = curr.value;\n                    break;\n                case 1: // Text entered by user explicitly\n                    entity.text = curr.value;\n                    break;\n                case 50: // Angle of rotated, horizontal, or vertical dimensions\n                    entity.angle = curr.value;\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Ellipse {\n    constructor() {\n        this.ForEntityName = 'ELLIPSE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    entity.center = helpers.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.majorAxisEndPoint = helpers.parsePoint(scanner);\n                    break;\n                case 40:\n                    entity.axisRatio = curr.value;\n                    break;\n                case 41:\n                    entity.startAngle = curr.value;\n                    break;\n                case 42:\n                    entity.endAngle = curr.value;\n                    break;\n                case 2:\n                    entity.name = curr.value;\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Insert {\n    constructor() {\n        this.ForEntityName = 'INSERT';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 2:\n                    entity.name = curr.value;\n                    break;\n                case 41:\n                    entity.xScale = curr.value;\n                    break;\n                case 42:\n                    entity.yScale = curr.value;\n                    break;\n                case 43:\n                    entity.zScale = curr.value;\n                    break;\n                case 10:\n                    entity.position = helpers.parsePoint(scanner);\n                    break;\n                case 50:\n                    entity.rotation = curr.value;\n                    break;\n                case 70:\n                    entity.columnCount = curr.value;\n                    break;\n                case 71:\n                    entity.rowCount = curr.value;\n                    break;\n                case 44:\n                    entity.columnSpacing = curr.value;\n                    break;\n                case 45:\n                    entity.rowSpacing = curr.value;\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Line {\n    constructor() {\n        this.ForEntityName = 'LINE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, vertices: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of point\n                    entity.vertices.unshift(helpers.parsePoint(scanner));\n                    break;\n                case 11:\n                    entity.vertices.push(helpers.parsePoint(scanner));\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                case 100:\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Lwpolyline {\n    constructor() {\n        this.ForEntityName = 'LWPOLYLINE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, vertices: [] };\n        let numberOfVertices = 0;\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 38:\n                    entity.elevation = curr.value;\n                    break;\n                case 39:\n                    entity.depth = curr.value;\n                    break;\n                case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\n                    entity.shape = ((curr.value & 1) === 1);\n                    entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\n                    break;\n                case 90:\n                    numberOfVertices = curr.value;\n                    break;\n                case 10: // X coordinate of point\n                    entity.vertices = parseLWPolylineVertices(numberOfVertices, scanner);\n                    break;\n                case 43:\n                    if (curr.value !== 0)\n                        entity.width = curr.value;\n                    break;\n                case 210:\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220:\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230:\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\nfunction parseLWPolylineVertices(n, scanner) {\n    if (!n || n <= 0)\n        throw Error('n must be greater than 0 verticies');\n    const vertices = [];\n    let vertexIsStarted = false;\n    let vertexIsFinished = false;\n    let curr = scanner.lastReadGroup;\n    for (let i = 0; i < n; i++) {\n        const vertex = {};\n        while (!scanner.isEOF()) {\n            if (curr.code === 0 || vertexIsFinished)\n                break;\n            switch (curr.code) {\n                case 10: // X\n                    if (vertexIsStarted) {\n                        vertexIsFinished = true;\n                        continue;\n                    }\n                    vertex.x = curr.value;\n                    vertexIsStarted = true;\n                    break;\n                case 20: // Y\n                    vertex.y = curr.value;\n                    break;\n                case 30: // Z\n                    vertex.z = curr.value;\n                    break;\n                case 40: // start width\n                    vertex.startWidth = curr.value;\n                    break;\n                case 41: // end width\n                    vertex.endWidth = curr.value;\n                    break;\n                case 42: // bulge\n                    if (curr.value != 0)\n                        vertex.bulge = curr.value;\n                    break;\n                default:\n                    // if we do not hit known code return vertices.  Code might belong to entity\n                    scanner.rewind();\n                    if (vertexIsStarted) {\n                        vertices.push(vertex);\n                    }\n                    scanner.rewind();\n                    return vertices;\n            }\n            curr = scanner.next();\n        }\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\n        vertices.push(vertex);\n        vertexIsStarted = false;\n        vertexIsFinished = false;\n    }\n    scanner.rewind();\n    return vertices;\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Mtext {\n    constructor() {\n        this.ForEntityName = 'MTEXT';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 3:\n                    entity.text ? entity.text += curr.value : entity.text = curr.value;\n                    break;\n                case 1:\n                    entity.text ? entity.text += curr.value : entity.text = curr.value;\n                    break;\n                case 10:\n                    entity.position = helpers.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.directionVector = helpers.parsePoint(scanner);\n                    break;\n                case 40:\n                    //Note: this is the text height\n                    entity.height = curr.value;\n                    break;\n                case 41:\n                    entity.width = curr.value;\n                    break;\n                case 50:\n                    entity.rotation = curr.value;\n                    break;\n                case 71:\n                    entity.attachmentPoint = curr.value;\n                    break;\n                case 72:\n                    entity.drawingDirection = curr.value;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Point {\n    constructor() {\n        this.ForEntityName = 'POINT';\n    }\n    parseEntity(scanner, curr) {\n        const type = curr.value;\n        const entity = { type };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    entity.position = helpers.parsePoint(scanner);\n                    break;\n                case 39:\n                    entity.thickness = curr.value;\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                case 100:\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Vertex {\n    constructor() {\n        this.ForEntityName = 'VERTEX';\n    }\n    parseEntity(scanner, curr) {\n        var entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X\n                    entity.x = curr.value;\n                    break;\n                case 20: // Y\n                    entity.y = curr.value;\n                    break;\n                case 30: // Z\n                    entity.z = curr.value;\n                    break;\n                case 40: // start width\n                    break;\n                case 41: // end width\n                    break;\n                case 42: // bulge\n                    if (curr.value != 0)\n                        entity.bulge = curr.value;\n                    break;\n                case 70: // flags\n                    entity.curveFittingVertex = (curr.value & 1) !== 0;\n                    entity.curveFitTangent = (curr.value & 2) !== 0;\n                    entity.splineVertex = (curr.value & 8) !== 0;\n                    entity.splineControlPoint = (curr.value & 16) !== 0;\n                    entity.threeDPolylineVertex = (curr.value & 32) !== 0;\n                    entity.threeDPolylineMesh = (curr.value & 64) !== 0;\n                    entity.polyfaceMeshVertex = (curr.value & 128) !== 0;\n                    break;\n                case 50: // curve fit tangent direction\n                    break;\n                case 71: // polyface mesh vertex index\n                    entity.faceA = curr.value;\n                    break;\n                case 72: // polyface mesh vertex index\n                    entity.faceB = curr.value;\n                    break;\n                case 73: // polyface mesh vertex index\n                    entity.faceC = curr.value;\n                    break;\n                case 74: // polyface mesh vertex index\n                    entity.faceD = curr.value;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nimport VertexParser from './vertex';\nexport default class Polyline {\n    constructor() {\n        this.ForEntityName = 'POLYLINE';\n    }\n    parseEntity(scanner, curr) {\n        var entity = { type: curr.value, vertices: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // always 0\n                    break;\n                case 20: // always 0\n                    break;\n                case 30: // elevation\n                    break;\n                case 39: // thickness\n                    entity.thickness = curr.value;\n                    break;\n                case 40: // start width\n                    break;\n                case 41: // end width\n                    break;\n                case 70:\n                    entity.shape = (curr.value & 1) !== 0;\n                    entity.includesCurveFitVertices = (curr.value & 2) !== 0;\n                    entity.includesSplineFitVertices = (curr.value & 4) !== 0;\n                    entity.is3dPolyline = (curr.value & 8) !== 0;\n                    entity.is3dPolygonMesh = (curr.value & 16) !== 0;\n                    entity.is3dPolygonMeshClosed = (curr.value & 32) !== 0; // 32 = The polygon mesh is closed in the N direction\n                    entity.isPolyfaceMesh = (curr.value & 64) !== 0;\n                    entity.hasContinuousLinetypePattern = (curr.value & 128) !== 0;\n                    break;\n                case 71: // Polygon mesh M vertex count\n                    break;\n                case 72: // Polygon mesh N vertex count\n                    break;\n                case 73: // Smooth surface M density\n                    break;\n                case 74: // Smooth surface N density\n                    break;\n                case 75: // Curves and smooth surface type\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        entity.vertices = parsePolylineVertices(scanner, curr);\n        return entity;\n    }\n}\nfunction parsePolylineVertices(scanner, curr) {\n    const vertexParser = new VertexParser();\n    const vertices = [];\n    while (!scanner.isEOF()) {\n        if (curr.code === 0) {\n            if (curr.value === 'VERTEX') {\n                vertices.push(vertexParser.parseEntity(scanner, curr));\n                curr = scanner.lastReadGroup;\n            }\n            else if (curr.value === 'SEQEND') {\n                parseSeqEnd(scanner, curr);\n                break;\n            }\n        }\n    }\n    return vertices;\n}\nfunction parseSeqEnd(scanner, curr) {\n    const entity = { type: curr.value };\n    curr = scanner.next();\n    while (!scanner.isEOF()) {\n        if (curr.code == 0)\n            break;\n        helpers.checkCommonEntityProperties(entity, curr, scanner);\n        curr = scanner.next();\n    }\n    return entity;\n}\n;\n","import * as helpers from '../ParseHelpers';\nexport default class Solid {\n    constructor() {\n        this.ForEntityName = 'SOLID';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, points: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    entity.points[0] = helpers.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.points[1] = helpers.parsePoint(scanner);\n                    break;\n                case 12:\n                    entity.points[2] = helpers.parsePoint(scanner);\n                    break;\n                case 13:\n                    entity.points[3] = helpers.parsePoint(scanner);\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Spline {\n    constructor() {\n        this.ForEntityName = 'SPLINE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    if (!entity.controlPoints)\n                        entity.controlPoints = [];\n                    entity.controlPoints.push(helpers.parsePoint(scanner));\n                    break;\n                case 11:\n                    if (!entity.fitPoints)\n                        entity.fitPoints = [];\n                    entity.fitPoints.push(helpers.parsePoint(scanner));\n                    break;\n                case 12:\n                    entity.startTangent = helpers.parsePoint(scanner);\n                    break;\n                case 13:\n                    entity.endTangent = helpers.parsePoint(scanner);\n                    break;\n                case 40:\n                    if (!entity.knotValues)\n                        entity.knotValues = [];\n                    entity.knotValues.push(curr.value);\n                    break;\n                case 70:\n                    if ((curr.value & 1) != 0)\n                        entity.closed = true;\n                    if ((curr.value & 2) != 0)\n                        entity.periodic = true;\n                    if ((curr.value & 4) != 0)\n                        entity.rational = true;\n                    if ((curr.value & 8) != 0)\n                        entity.planar = true;\n                    if ((curr.value & 16) != 0) {\n                        entity.planar = true;\n                        entity.linear = true;\n                    }\n                    break;\n                case 71:\n                    entity.degreeOfSplineCurve = curr.value;\n                    break;\n                case 72:\n                    entity.numberOfKnots = curr.value;\n                    break;\n                case 73:\n                    entity.numberOfControlPoints = curr.value;\n                    break;\n                case 74:\n                    entity.numberOfFitPoints = curr.value;\n                    break;\n                case 210:\n                    entity.normalVector = helpers.parsePoint(scanner);\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import * as helpers from '../ParseHelpers';\nexport default class Text {\n    constructor() {\n        this.ForEntityName = 'TEXT';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of 'first alignment point'\n                    entity.startPoint = helpers.parsePoint(scanner);\n                    break;\n                case 11: // X coordinate of 'second alignment point'\n                    entity.endPoint = helpers.parsePoint(scanner);\n                    break;\n                case 40: // Text height\n                    entity.textHeight = curr.value;\n                    break;\n                case 41:\n                    entity.xScale = curr.value;\n                    break;\n                case 50: // Rotation in degrees\n                    entity.rotation = curr.value;\n                    break;\n                case 1: // Text\n                    entity.text = curr.value;\n                    break;\n                // NOTE: 72 and 73 are meaningless without 11 (second alignment point)\n                case 72: // Horizontal alignment\n                    entity.halign = curr.value;\n                    break;\n                case 73: // Vertical alignment\n                    entity.valign = curr.value;\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n","import DxfArrayScanner from './DxfArrayScanner';\nimport AUTO_CAD_COLOR_INDEX from './AutoCadColorIndex';\nimport Face from './entities/3dface';\nimport Arc from './entities/arc';\nimport AttDef from './entities/attdef';\nimport Circle from './entities/circle';\nimport Dimension from './entities/dimension';\nimport Ellipse from './entities/ellipse';\nimport Insert from './entities/insert';\nimport Line from './entities/line';\nimport LWPolyline from './entities/lwpolyline';\nimport MText from './entities/mtext';\nimport Point from './entities/point';\nimport Polyline from './entities/polyline';\nimport Solid from './entities/solid';\nimport Spline from './entities/spline';\nimport Text from './entities/text';\n//import Vertex from './entities/';\nimport log from 'loglevel';\n//log.setLevel('trace');\n//log.setLevel('debug');\n//log.setLevel('info');\n//log.setLevel('warn');\nlog.setLevel('error');\nfunction registerDefaultEntityHandlers(dxfParser) {\n    // Supported entities here (some entity code is still being refactored into this flow)\n    dxfParser.registerEntityHandler(Face);\n    dxfParser.registerEntityHandler(Arc);\n    dxfParser.registerEntityHandler(AttDef);\n    dxfParser.registerEntityHandler(Circle);\n    dxfParser.registerEntityHandler(Dimension);\n    dxfParser.registerEntityHandler(Ellipse);\n    dxfParser.registerEntityHandler(Insert);\n    dxfParser.registerEntityHandler(Line);\n    dxfParser.registerEntityHandler(LWPolyline);\n    dxfParser.registerEntityHandler(MText);\n    dxfParser.registerEntityHandler(Point);\n    dxfParser.registerEntityHandler(Polyline);\n    dxfParser.registerEntityHandler(Solid);\n    dxfParser.registerEntityHandler(Spline);\n    dxfParser.registerEntityHandler(Text);\n    //dxfParser.registerEntityHandler(require('./entities/vertex'));\n}\nexport default class DxfParser {\n    constructor() {\n        this._entityHandlers = {};\n        registerDefaultEntityHandlers(this);\n    }\n    parse(source) {\n        if (typeof source === 'string') {\n            return this._parse(source);\n        }\n        else {\n            console.error('Cannot read dxf source of type `' + typeof (source));\n            return null;\n        }\n    }\n    registerEntityHandler(handlerType) {\n        const instance = new handlerType();\n        this._entityHandlers[instance.ForEntityName] = instance;\n    }\n    parseSync(source) {\n        return this.parse(source);\n    }\n    parseStream(stream) {\n        let dxfString = \"\";\n        const self = this;\n        return new Promise((res, rej) => {\n            stream.on('data', (chunk) => {\n                dxfString += chunk;\n            });\n            stream.on('end', () => {\n                try {\n                    res(self._parse(dxfString));\n                }\n                catch (err) {\n                    rej(err);\n                }\n            });\n            stream.on('error', (err) => {\n                rej(err);\n            });\n        });\n    }\n    _parse(dxfString) {\n        const dxf = {};\n        let lastHandle = 0;\n        const dxfLinesArray = dxfString.split(/\\r\\n|\\r|\\n/g);\n        const scanner = new DxfArrayScanner(dxfLinesArray);\n        if (!scanner.hasNext())\n            throw Error('Empty file');\n        const self = this;\n        let curr;\n        function parseAll() {\n            curr = scanner.next();\n            while (!scanner.isEOF()) {\n                if (curr.code === 0 && curr.value === 'SECTION') {\n                    curr = scanner.next();\n                    // Be sure we are reading a section code\n                    if (curr.code !== 2) {\n                        console.error('Unexpected code %s after 0:SECTION', debugCode(curr));\n                        curr = scanner.next();\n                        continue;\n                    }\n                    if (curr.value === 'HEADER') {\n                        log.debug('> HEADER');\n                        dxf.header = parseHeader();\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'BLOCKS') {\n                        log.debug('> BLOCKS');\n                        dxf.blocks = parseBlocks();\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'ENTITIES') {\n                        log.debug('> ENTITIES');\n                        dxf.entities = parseEntities(false);\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'TABLES') {\n                        log.debug('> TABLES');\n                        dxf.tables = parseTables();\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'EOF') {\n                        log.debug('EOF');\n                    }\n                    else {\n                        log.warn('Skipping section \\'%s\\'', curr.value);\n                    }\n                }\n                else {\n                    curr = scanner.next();\n                }\n                // If is a new section\n            }\n        }\n        /**\n         *\n         * @return {object} header\n         */\n        function parseHeader() {\n            // interesting variables:\n            //  $ACADVER, $VIEWDIR, $VIEWSIZE, $VIEWCTR, $TDCREATE, $TDUPDATE\n            // http://www.autodesk.com/techpubs/autocad/acadr14/dxf/header_section_al_u05_c.htm\n            // Also see VPORT table entries\n            let currVarName = null;\n            let currVarValue = null;\n            const header = {};\n            // loop through header variables\n            curr = scanner.next();\n            while (true) {\n                if (groupIs(curr, 0, 'ENDSEC')) {\n                    if (currVarName)\n                        header[currVarName] = currVarValue;\n                    break;\n                }\n                else if (curr.code === 9) {\n                    if (currVarName)\n                        header[currVarName] = currVarValue;\n                    currVarName = curr.value;\n                    // Filter here for particular variables we are interested in\n                }\n                else {\n                    if (curr.code === 10) {\n                        currVarValue = { x: curr.value };\n                    }\n                    else if (curr.code === 20) {\n                        currVarValue.y = curr.value;\n                    }\n                    else if (curr.code === 30) {\n                        currVarValue.z = curr.value;\n                    }\n                    else {\n                        currVarValue = curr.value;\n                    }\n                }\n                curr = scanner.next();\n            }\n            // console.log(util.inspect(header, { colors: true, depth: null }));\n            curr = scanner.next(); // swallow up ENDSEC\n            return header;\n        }\n        /**\n         *\n         */\n        function parseBlocks() {\n            const blocks = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                if (groupIs(curr, 0, 'ENDSEC')) {\n                    break;\n                }\n                if (groupIs(curr, 0, 'BLOCK')) {\n                    log.debug('block {');\n                    const block = parseBlock();\n                    log.debug('}');\n                    ensureHandle(block);\n                    if (!block.name)\n                        log.error('block with handle \"' + block.handle + '\" is missing a name.');\n                    else\n                        blocks[block.name] = block;\n                }\n                else {\n                    logUnhandledGroup(curr);\n                    curr = scanner.next();\n                }\n            }\n            return blocks;\n        }\n        function parseBlock() {\n            const block = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                switch (curr.code) {\n                    case 1:\n                        block.xrefPath = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 2:\n                        block.name = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 3:\n                        block.name2 = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 5:\n                        block.handle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 8:\n                        block.layer = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 10:\n                        block.position = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 67:\n                        block.paperSpace = (curr.value && curr.value == 1) ? true : false;\n                        curr = scanner.next();\n                        break;\n                    case 70:\n                        if (curr.value != 0) {\n                            //if(curr.value & BLOCK_ANONYMOUS_FLAG) console.log('  Anonymous block');\n                            //if(curr.value & BLOCK_NON_CONSTANT_FLAG) console.log('  Non-constant attributes');\n                            //if(curr.value & BLOCK_XREF_FLAG) console.log('  Is xref');\n                            //if(curr.value & BLOCK_XREF_OVERLAY_FLAG) console.log('  Is xref overlay');\n                            //if(curr.value & BLOCK_EXTERNALLY_DEPENDENT_FLAG) console.log('  Is externally dependent');\n                            //if(curr.value & BLOCK_RESOLVED_OR_DEPENDENT_FLAG) console.log('  Is resolved xref or dependent of an xref');\n                            //if(curr.value & BLOCK_REFERENCED_XREF) console.log('  This definition is a referenced xref');\n                            block.type = curr.value;\n                        }\n                        curr = scanner.next();\n                        break;\n                    case 100:\n                        // ignore class markers\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        block.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        if (curr.value == 'ENDBLK')\n                            break;\n                        block.entities = parseEntities(true);\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                }\n                if (groupIs(curr, 0, 'ENDBLK')) {\n                    curr = scanner.next();\n                    break;\n                }\n            }\n            return block;\n        }\n        /**\n         * parseTables\n         * @return {Object} Object representing tables\n         */\n        function parseTables() {\n            const tables = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                if (groupIs(curr, 0, 'ENDSEC'))\n                    break;\n                if (groupIs(curr, 0, 'TABLE')) {\n                    curr = scanner.next();\n                    const tableDefinition = tableDefinitions[curr.value];\n                    if (tableDefinition) {\n                        log.debug(curr.value + ' Table {');\n                        tables[tableDefinitions[curr.value].tableName] = parseTable(curr);\n                        log.debug('}');\n                    }\n                    else {\n                        log.debug('Unhandled Table ' + curr.value);\n                    }\n                }\n                else {\n                    // else ignored\n                    curr = scanner.next();\n                }\n            }\n            curr = scanner.next();\n            return tables;\n        }\n        const END_OF_TABLE_VALUE = 'ENDTAB';\n        function parseTable(group) {\n            const tableDefinition = tableDefinitions[group.value];\n            const table = {};\n            let expectedCount = 0;\n            curr = scanner.next();\n            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\n                switch (curr.code) {\n                    case 5:\n                        table.handle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        table.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 100:\n                        if (curr.value === 'AcDbSymbolTable') {\n                            // ignore\n                            curr = scanner.next();\n                        }\n                        else {\n                            logUnhandledGroup(curr);\n                            curr = scanner.next();\n                        }\n                        break;\n                    case 70:\n                        expectedCount = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        if (curr.value === tableDefinition.dxfSymbolName) {\n                            table[tableDefinition.tableRecordsProperty] = tableDefinition.parseTableRecords();\n                        }\n                        else {\n                            logUnhandledGroup(curr);\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                }\n            }\n            const tableRecords = table[tableDefinition.tableRecordsProperty];\n            if (tableRecords) {\n                let actualCount = (() => {\n                    if (tableRecords.constructor === Array) {\n                        return tableRecords.length;\n                    }\n                    else if (typeof (tableRecords) === 'object') {\n                        return Object.keys(tableRecords).length;\n                    }\n                    return undefined;\n                })();\n                if (expectedCount !== actualCount)\n                    log.warn('Parsed ' + actualCount + ' ' + tableDefinition.dxfSymbolName + '\\'s but expected ' + expectedCount);\n            }\n            curr = scanner.next();\n            return table;\n        }\n        function parseViewPortRecords() {\n            const viewPorts = []; // Multiple table entries may have the same name indicating a multiple viewport configuration\n            let viewPort = {};\n            log.debug('ViewPort {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\n                switch (curr.code) {\n                    case 2: // layer name\n                        viewPort.name = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 10:\n                        viewPort.lowerLeftCorner = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 11:\n                        viewPort.upperRightCorner = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 12:\n                        viewPort.center = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 13:\n                        viewPort.snapBasePoint = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 14:\n                        viewPort.snapSpacing = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 15:\n                        viewPort.gridSpacing = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 16:\n                        viewPort.viewDirectionFromTarget = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 17:\n                        viewPort.viewTarget = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 42:\n                        viewPort.lensLength = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 43:\n                        viewPort.frontClippingPlane = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 44:\n                        viewPort.backClippingPlane = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 45:\n                        viewPort.viewHeight = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 50:\n                        viewPort.snapRotationAngle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 51:\n                        viewPort.viewTwistAngle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 79:\n                        viewPort.orthographicType = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 110:\n                        viewPort.ucsOrigin = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 111:\n                        viewPort.ucsXAxis = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 112:\n                        viewPort.ucsYAxis = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 110:\n                        viewPort.ucsOrigin = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 281:\n                        viewPort.renderMode = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 281:\n                        // 0 is one distant light, 1 is two distant lights\n                        viewPort.defaultLightingType = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 292:\n                        viewPort.defaultLightingOn = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        viewPort.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 63: // These are all ambient color. Perhaps should be a gradient when multiple are set.\n                    case 421:\n                    case 431:\n                        viewPort.ambientColor = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        // New ViewPort\n                        if (curr.value === 'VPORT') {\n                            log.debug('}');\n                            viewPorts.push(viewPort);\n                            log.debug('ViewPort {');\n                            viewPort = {};\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                        break;\n                }\n            }\n            // Note: do not call scanner.next() here,\n            //  parseTable() needs the current group\n            log.debug('}');\n            viewPorts.push(viewPort);\n            return viewPorts;\n        }\n        function parseLineTypes() {\n            const ltypes = {};\n            let ltype = {};\n            let length = 0;\n            let ltypeName;\n            log.debug('LType {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, 'ENDTAB')) {\n                switch (curr.code) {\n                    case 2:\n                        ltype.name = curr.value;\n                        ltypeName = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 3:\n                        ltype.description = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 73: // Number of elements for this line type (dots, dashes, spaces);\n                        length = curr.value;\n                        if (length > 0)\n                            ltype.pattern = [];\n                        curr = scanner.next();\n                        break;\n                    case 40: // total pattern length\n                        ltype.patternLength = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 49:\n                        ltype.pattern.push(curr.value);\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        log.debug('}');\n                        if (length > 0 && length !== ltype.pattern.length)\n                            log.warn('lengths do not match on LTYPE pattern');\n                        ltypes[ltypeName] = ltype;\n                        ltype = {};\n                        log.debug('LType {');\n                        curr = scanner.next();\n                        break;\n                    default:\n                        curr = scanner.next();\n                }\n            }\n            log.debug('}');\n            ltypes[ltypeName] = ltype;\n            return ltypes;\n        }\n        function parseLayers() {\n            const layers = {};\n            let layer = {};\n            let layerName;\n            log.debug('Layer {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, 'ENDTAB')) {\n                switch (curr.code) {\n                    case 2: // layer name\n                        layer.name = curr.value;\n                        layerName = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 62: // color, visibility\n                        layer.visible = curr.value >= 0;\n                        // TODO 0 and 256 are BYBLOCK and BYLAYER respectively. Need to handle these values for layers?.\n                        layer.colorIndex = Math.abs(curr.value);\n                        layer.color = getAcadColor(layer.colorIndex);\n                        curr = scanner.next();\n                        break;\n                    case 70: // frozen layer\n                        layer.frozen = ((curr.value & 1) != 0 || (curr.value & 2) != 0);\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        // New Layer\n                        if (curr.value === 'LAYER') {\n                            log.debug('}');\n                            layers[layerName] = layer;\n                            log.debug('Layer {');\n                            layer = {};\n                            layerName = undefined;\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                        break;\n                }\n            }\n            // Note: do not call scanner.next() here,\n            //  parseLayerTable() needs the current group\n            log.debug('}');\n            layers[layerName] = layer;\n            return layers;\n        }\n        const tableDefinitions = {\n            VPORT: {\n                tableRecordsProperty: 'viewPorts',\n                tableName: 'viewPort',\n                dxfSymbolName: 'VPORT',\n                parseTableRecords: parseViewPortRecords\n            },\n            LTYPE: {\n                tableRecordsProperty: 'lineTypes',\n                tableName: 'lineType',\n                dxfSymbolName: 'LTYPE',\n                parseTableRecords: parseLineTypes\n            },\n            LAYER: {\n                tableRecordsProperty: 'layers',\n                tableName: 'layer',\n                dxfSymbolName: 'LAYER',\n                parseTableRecords: parseLayers\n            }\n        };\n        /**\n         * Is called after the parser first reads the 0:ENTITIES group. The scanner\n         * should be on the start of the first entity already.\n         * @return {Array} the resulting entities\n         */\n        function parseEntities(forBlock) {\n            const entities = [];\n            const endingOnValue = forBlock ? 'ENDBLK' : 'ENDSEC';\n            if (!forBlock) {\n                curr = scanner.next();\n            }\n            while (true) {\n                if (curr.code === 0) {\n                    if (curr.value === endingOnValue) {\n                        break;\n                    }\n                    const handler = self._entityHandlers[curr.value];\n                    if (handler != null) {\n                        log.debug(curr.value + ' {');\n                        const entity = handler.parseEntity(scanner, curr);\n                        curr = scanner.lastReadGroup;\n                        log.debug('}');\n                        ensureHandle(entity);\n                        entities.push(entity);\n                    }\n                    else {\n                        log.warn('Unhandled entity ' + curr.value);\n                        curr = scanner.next();\n                        continue;\n                    }\n                }\n                else {\n                    // ignored lines from unsupported entity\n                    curr = scanner.next();\n                }\n            }\n            if (endingOnValue == 'ENDSEC')\n                curr = scanner.next(); // swallow up ENDSEC, but not ENDBLK\n            return entities;\n        }\n        /**\n         * Parses a 2D or 3D point, returning it as an object with x, y, and\n         * (sometimes) z property if it is 3D. It is assumed the current group\n         * is x of the point being read in, and scanner.next() will return the\n         * y. The parser will determine if there is a z point automatically.\n         * @return {Object} The 2D or 3D point as an object with x, y[, z]\n         */\n        function parsePoint(curr) {\n            const point = {};\n            let code = curr.code;\n            point.x = curr.value;\n            code += 10;\n            curr = scanner.next();\n            if (curr.code != code)\n                throw new Error('Expected code for point value to be ' + code +\n                    ' but got ' + curr.code + '.');\n            point.y = curr.value;\n            code += 10;\n            curr = scanner.next();\n            if (curr.code != code) {\n                scanner.rewind();\n                return point;\n            }\n            point.z = curr.value;\n            return point;\n        }\n        function ensureHandle(entity) {\n            if (!entity)\n                throw new TypeError('entity cannot be undefined or null');\n            if (!entity.handle)\n                entity.handle = lastHandle++;\n        }\n        parseAll();\n        return dxf;\n    }\n}\nfunction groupIs(group, code, value) {\n    return group.code === code && group.value === value;\n}\nfunction logUnhandledGroup(curr) {\n    log.debug('unhandled group ' + debugCode(curr));\n}\nfunction debugCode(curr) {\n    return curr.code + ':' + curr.value;\n}\n/**\n * Returns the truecolor value of the given AutoCad color index value\n * @return {Number} truecolor value as a number\n */\nfunction getAcadColor(index) {\n    return AUTO_CAD_COLOR_INDEX[index];\n}\n// const BLOCK_ANONYMOUS_FLAG = 1;\n// const BLOCK_NON_CONSTANT_FLAG = 2;\n// const BLOCK_XREF_FLAG = 4;\n// const BLOCK_XREF_OVERLAY_FLAG = 8;\n// const BLOCK_EXTERNALLY_DEPENDENT_FLAG = 16;\n// const BLOCK_RESOLVED_OR_DEPENDENT_FLAG = 32;\n// const BLOCK_REFERENCED_XREF = 64;\n/* Notes */\n// Code 6 of an entity indicates inheritance of properties (eg. color).\n//   BYBLOCK means inherits from block\n//   BYLAYER (default) mean inherits from layer\n","import DxfParser from './DxfParser';\nexport { default as DxfParser } from './DxfParser';\nexport default DxfParser;\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = level;\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          self.setLevel(defaultLevel, false);\n          clearPersistedLevel();\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n"],"names":["DxfArrayScanner","data","this","_pointer","_eof","_data","hasNext","Error","group","code","parseInt","value","parseGroupValue","trim","lastReadGroup","numberOfGroups","length","parseFloat","str","TypeError","parseBoolean","console","log","parsePoint","scanner","point","rewind","curr","next","x","y","z","checkCommonEntityProperties","entity","type","handle","lineType","layer","lineTypeScale","visible","colorIndex","color","index","Math","abs","AUTO_CAD_COLOR_INDEX","inPaperSpace","ownerHandle","materialObjectHandle","lineweight","extendedData","customStrings","push","applicationName","ThreeDface","ForEntityName","vertices","isEOF","shape","hasContinuousLinetypePattern","parse3dFaceVertices","helpers","vertexIsStarted","vertexIsFinished","i","vertex","Arc","center","radius","startAngle","PI","endAngle","angleLength","extrusionDirectionX","extrusionDirectionY","extrusionDirectionZ","Attdef","scale","textStyle","text","tag","prompt","startPoint","endPoint","thickness","textHeight","rotation","obliqueAngle","invisible","constant","verificationRequired","preset","backwards","mirrored","horizontalJustification","fieldLength","verticalJustification","Circle","Dimension","block","anchorPoint","middleOfText","insertionPoint","linearOrAngularPoint1","linearOrAngularPoint2","diameterOrRadiusPoint","arcPoint","dimensionType","attachmentPoint","actualMeasurement","angle","Ellipse","majorAxisEndPoint","axisRatio","name","Insert","xScale","yScale","zScale","position","columnCount","rowCount","columnSpacing","rowSpacing","extrusionDirection","Line","unshift","Lwpolyline","numberOfVertices","elevation","depth","parseLWPolylineVertices","width","n","startWidth","endWidth","bulge","Mtext","directionVector","height","drawingDirection","Point","Vertex","curveFittingVertex","curveFitTangent","splineVertex","splineControlPoint","threeDPolylineVertex","threeDPolylineMesh","polyfaceMeshVertex","faceA","faceB","faceC","faceD","Polyline","includesCurveFitVertices","includesSplineFitVertices","is3dPolyline","is3dPolygonMesh","is3dPolygonMeshClosed","isPolyfaceMesh","vertexParser","VertexParser","parseEntity","parseSeqEnd","parsePolylineVertices","Solid","points","Spline","controlPoints","fitPoints","startTangent","endTangent","knotValues","closed","periodic","rational","planar","linear","degreeOfSplineCurve","numberOfKnots","numberOfControlPoints","numberOfFitPoints","normalVector","Text","halign","valign","DxfParser","dxfParser","_entityHandlers","registerEntityHandler","Face","AttDef","LWPolyline","MText","source","_parse","error","handlerType","instance","parse","stream","dxfString","self","Promise","res","rej","on","chunk","err","dxf","lastHandle","dxfLinesArray","split","parseHeader","currVarName","currVarValue","header","groupIs","parseBlocks","blocks","parseBlock","ensureHandle","logUnhandledGroup","xrefPath","name2","paperSpace","entities","parseEntities","parseTables","tables","tableDefinitions","tableName","parseTable","END_OF_TABLE_VALUE","tableDefinition","table","expectedCount","dxfSymbolName","tableRecordsProperty","parseTableRecords","tableRecords","actualCount","constructor","Array","Object","keys","VPORT","viewPorts","viewPort","lowerLeftCorner","upperRightCorner","snapBasePoint","snapSpacing","gridSpacing","viewDirectionFromTarget","viewTarget","lensLength","frontClippingPlane","backClippingPlane","viewHeight","snapRotationAngle","viewTwistAngle","orthographicType","ucsOrigin","ucsXAxis","ucsYAxis","renderMode","defaultLightingType","defaultLightingOn","ambientColor","LTYPE","ltypeName","ltypes","ltype","description","pattern","patternLength","LAYER","layerName","layers","frozen","undefined","forBlock","endingOnValue","handler","debugCode","parseAll","root","definition","define","noop","undefinedType","isIE","window","navigator","test","userAgent","logMethods","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","traceForIE","trace","realMethod","replaceLoggingMethods","level","loggerName","methodFactory","debug","enableLoggingWhenConsoleArrives","defaultMethodFactory","Logger","defaultLevel","factory","currentLevel","storageKey","persistLevelIfPossible","levelNum","levelName","toUpperCase","localStorage","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","location","indexOf","exec","slice","levels","clearPersistedLevel","removeItem","getLevel","setLevel","persist","SILENT","setDefaultLevel","resetLevel","enableAll","TRACE","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","logger","_log","noConflict","getLoggers"],"sourceRoot":""}