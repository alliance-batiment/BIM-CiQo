{"version":3,"file":"9791.bundle.js","mappings":"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","sources":["webpack://ciqo/./node_modules/@parametricos/bcf-js/src/BcfReader.ts","webpack://ciqo/./node_modules/@parametricos/bcf-js/src/Helpers.ts","webpack://ciqo/./node_modules/@parametricos/bcf-js/src/index.ts","webpack://ciqo/./node_modules/@parametricos/bcf-js/src/schema/index.ts","webpack://ciqo/./node_modules/fast-xml-parser/src/json2xml.js","webpack://ciqo/./node_modules/fast-xml-parser/src/nimndata.js","webpack://ciqo/./node_modules/fast-xml-parser/src/node2json.js","webpack://ciqo/./node_modules/fast-xml-parser/src/node2json_str.js","webpack://ciqo/./node_modules/fast-xml-parser/src/parser.js","webpack://ciqo/./node_modules/fast-xml-parser/src/util.js","webpack://ciqo/./node_modules/fast-xml-parser/src/validator.js","webpack://ciqo/./node_modules/fast-xml-parser/src/xmlNode.js","webpack://ciqo/./node_modules/fast-xml-parser/src/xmlstr2xmlnode.js","webpack://ciqo/./node_modules/strnum/strnum.js","webpack://ciqo/./node_modules/unzipit/dist/unzipit.module.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/createClass.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/defineProperty.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/regeneratorRuntime.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/slicedToArray.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/typeof.js","webpack://ciqo/./module-federation/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"],"sourcesContent":["import {IMarkup, MarkupViewpoint} from \"./schema\";\r\nimport {Helpers} from \"./Helpers\";\r\nimport {VisualizationInfo} from \"./schema\";\r\nimport {Reader, TypedArray, unzip, Zip, ZipEntry, ZipInfo} from 'unzipit';\r\n\r\nexport class BcfReader{\r\n\r\n    bcf_archive: ZipInfo | undefined\r\n    topics: Topic[] = [];\r\n\r\n    read = async (src: string | ArrayBuffer | TypedArray | Blob | Reader) => {\r\n        try {\r\n            const topics: ZipEntry[] = [];\r\n\r\n            this.bcf_archive = await unzip(src);\r\n\r\n            const { entries } = this.bcf_archive;\r\n\r\n            for (const [name, entry] of Object.entries(entries)) {\r\n                if (name.endsWith('.bcf')) {\r\n                    topics.push(entry);\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < topics.length; i++) {\r\n                const t = topics[i]\r\n                const topic = new Topic(this, t);\r\n                await topic.read();\r\n                this.topics.push(topic);\r\n            }\r\n        }catch (e) {\r\n            console.log(\"Error in loading BCF archive. The error below was thrown.\")\r\n            console.error(e)\r\n        }\r\n    }\r\n\r\n    getEntry = (name: string) => {\r\n        return this.bcf_archive?.entries[name];\r\n    }\r\n}\r\n\r\nexport class Topic {\r\n\r\n    readonly reader: BcfReader;\r\n    readonly markup_file: ZipEntry;\r\n\r\n    markup: IMarkup | undefined;\r\n    viewpoints: VisualizationInfo[] = [];\r\n\r\n    constructor(reader: BcfReader, markup: ZipEntry) {\r\n        this.reader = reader;\r\n        this.markup_file = markup;\r\n    }\r\n\r\n    read = async () => {\r\n        await this.parseMarkup();\r\n        await this.parseViewpoints();\r\n    }\r\n\r\n\r\n\r\n    private parseMarkup = async () => {\r\n        this.markup = Helpers.GetMarkup(await this.markup_file.text());\r\n    }\r\n\r\n    private parseViewpoints = async () => {\r\n        if(!this.markup) return;\r\n\r\n        if(this.markup.viewpoints) {\r\n\r\n            const viewpoints = this.markup.viewpoints;\r\n\r\n            for (let i = 0; i < viewpoints.length; i++) {\r\n                const entry = viewpoints[i];\r\n                const key = this.markup.topic.guid + \"/\" + entry.viewpoint;\r\n                const file = this.reader.getEntry(key);\r\n\r\n                if (!file) throw new Error(\"Missing Visualization Info\");\r\n\r\n                const viewpoint = Helpers.GetViewpoint(await file.text());\r\n                this.viewpoints.push(viewpoint);\r\n                // Helpers.WriteJsonToFile(`./output/${name}/${id}/${entry.viewpoint}.json`, viewpoint);\r\n            }\r\n        }\r\n    }\r\n\r\n    getViewpointSnapshot = async (viewpoint: MarkupViewpoint) : Promise<Blob | undefined> => {\r\n        if(!viewpoint || !this.markup) return;\r\n        const entry = this.reader.getEntry(`${this.markup.topic.guid}/${viewpoint.snapshot}`);\r\n        if(entry){\r\n            return await entry.blob()\r\n        }\r\n    }\r\n}","import {IComment, IMarkup, MarkupViewpoint} from \"./schema\";\r\nimport parser from \"fast-xml-parser\";\r\nimport {\r\n    Component,\r\n    ComponentColoring,\r\n    Components,\r\n    ComponentVisibility,\r\n    ViewSetupHints,\r\n    VisualizationInfo\r\n} from \"./schema\";\r\n\r\nexport namespace Helpers {\r\n\r\n    const xmlParserOptions = {\r\n        attributeNamePrefix: \"@_\",\r\n        ignoreAttributes: false,\r\n        ignoreNameSpace: true,\r\n        allowBooleanAttributes: true,\r\n        parseNodeValue: true,\r\n        parseAttributeValue: true,\r\n        trimValues: true,\r\n    };\r\n\r\n    export function GetMarkup(xmlString: any): IMarkup {\r\n        const { Markup } = parser.parse(xmlString, xmlParserOptions);\r\n\r\n        return {\r\n            topic: {\r\n                guid: Markup.Topic['@_Guid'],\r\n                topic_type: Markup.Topic[\"@_TopicType\"],\r\n                topic_status: Markup.Topic[\"@_TopicStatus\"],\r\n                reference_link: Markup.Topic[\"ReferenceLink\"] && Helpers.ObjectToArray(Markup.Topic[\"ReferenceLink\"]),\r\n                title: Markup.Topic[\"Title\"],\r\n                priority: Markup.Topic[\"Priority\"],\r\n                index: Markup.Topic[\"Index\"],\r\n                labels: Markup.Topic[\"Labels\"] && Helpers.ObjectToArray(Markup.Topic[\"Labels\"]),\r\n                creation_date: Markup.Topic[\"CreationDate\"],\r\n                creation_author: Markup.Topic[\"CreationAuthor\"],\r\n                modified_date: Markup.Topic[\"ModifiedDate\"],\r\n                modified_author: Markup.Topic[\"ModifiedAuthor\"],\r\n                assigned_to: Markup.Topic[\"AssignedTo\"],\r\n                description: Markup.Topic[\"Description\"],\r\n                // bim_snippets: Markup.ITopic[\"BimSnippet\"] ? ,\r\n                // related_topics: Markup.ITopic[\"ReferenceLink\"],\r\n            },\r\n            comments: Helpers.GetComments(Markup.Comment),\r\n            viewpoints: Helpers.GetViewpoints(Markup.Viewpoints)\r\n        };\r\n    }\r\n\r\n    export function GetVisInfoComponent(xmlData: any): Component {\r\n        return {\r\n            ifc_guid: xmlData[\"@_IfcGuid\"]\r\n        }\r\n    }\r\n\r\n    export function GetViewpoint(xmlString: any): VisualizationInfo {\r\n        const { VisualizationInfo } = parser.parse(xmlString, xmlParserOptions);\r\n        const Vis = VisualizationInfo;\r\n\r\n        //Camera\r\n        const orthogonal_camera = Vis[\"OrthogonalCamera\"];\r\n        const perspective_camera = Vis[\"PerspectiveCamera\"];\r\n\r\n        //Extras\r\n        const lines = Vis[\"Lines\"];\r\n        const clipping_planes = Vis[\"ClippingPlanes\"];\r\n\r\n        const GetComponents = () : Components | undefined => {\r\n\r\n            if(!Vis[\"Components\"]) return undefined;\r\n            const components = Vis[\"Components\"];\r\n\r\n            const GetViewSetupHints = (): ViewSetupHints | undefined => {\r\n\r\n                if(!components[\"ViewSetupHints\"]) return undefined\r\n                const view_setup_hints = components[\"ViewSetupHints\"];\r\n\r\n                return {\r\n                    spaces_visible: view_setup_hints[\"@_SpacesVisible\"],\r\n                    spaces_boundaries_visible: view_setup_hints[\"@_SpacesBoundariesVisible\"],\r\n                    openings_visible: view_setup_hints[\"@_OpeningsVisible\"]\r\n                }\r\n            }\r\n\r\n            const GetVisibility = (): ComponentVisibility => {\r\n                if(!components[\"Visibility\"])\r\n                    throw new Error(\"Visibility not found.\")\r\n\r\n                const visibility = components[\"Visibility\"];\r\n                return {\r\n                    default_visibility: visibility[\"@_DefaultVisibility\"],\r\n                    exceptions:\r\n                        visibility[\"Exceptions\"] &&\r\n                        visibility[\"Exceptions\"][\"Component\"] &&\r\n                        Helpers.ObjectToArray(visibility[\"Exceptions\"][\"Component\"])?.map((exception: any) => {\r\n                            return Helpers.GetVisInfoComponent(exception)\r\n                        })\r\n                }\r\n            }\r\n\r\n            const GetSelection = () : Component[] | undefined => {\r\n                if(!components[\"Selection\"]) return undefined;\r\n\r\n                const selection = components[\"Selection\"];\r\n                const arr = Helpers.ObjectToArray(selection[\"Component\"]);\r\n                return arr?.map((exception: any) => {\r\n                    return Helpers.GetVisInfoComponent(exception)\r\n                })\r\n            }\r\n\r\n            const GetColoring = () : ComponentColoring[] | undefined => {\r\n\r\n                if(!components[\"Coloring\"]) return undefined;\r\n                const coloring = components[\"Coloring\"];\r\n\r\n                const colors = coloring[\"Color\"];\r\n                if(!colors) return undefined;\r\n\r\n                return Helpers.ObjectToArray(colors).map((color: any) => (\r\n                        {\r\n                            color: color[\"@_Color\"],\r\n                            components: Helpers.ObjectToArray(color[\"Component\"])\r\n                                .map((exception: any) => {\r\n                                    return Helpers.GetVisInfoComponent(exception)\r\n                                })\r\n                        }\r\n                    )\r\n                )\r\n            }\r\n\r\n            return {\r\n                view_setup_hints: GetViewSetupHints(),\r\n                visibility: GetVisibility(),\r\n                selection: GetSelection(),\r\n                coloring: GetColoring()\r\n            }\r\n        }\r\n\r\n        // Helpers.WriteJsonToFile(\"./parsed/viewpoint\" + Vis[\"@_Guid\"] + \".json\", Vis);\r\n\r\n        return {\r\n            guid: Vis[\"@_Guid\"],\r\n            components: GetComponents(),\r\n            orthogonal_camera: orthogonal_camera && {\r\n                camera_view_point: ParsePoint(orthogonal_camera[\"CameraViewPoint\"]),\r\n                camera_direction: ParsePoint(orthogonal_camera[\"CameraDirection\"]),\r\n                camera_up_vector: ParsePoint(orthogonal_camera[\"CameraUpVector\"]),\r\n                view_to_world_scale: orthogonal_camera[\"ViewToWorldScale\"]\r\n            },\r\n            perspective_camera: perspective_camera && {\r\n                camera_view_point: ParsePoint(perspective_camera[\"CameraViewPoint\"]),\r\n                camera_direction: ParsePoint(perspective_camera[\"CameraDirection\"]),\r\n                camera_up_vector: ParsePoint(perspective_camera[\"CameraUpVector\"]),\r\n                field_of_view: perspective_camera[\"FieldOfView\"]\r\n            },\r\n        };\r\n    }\r\n\r\n    export function GetViewpoints(data: any) {\r\n        if(!data) return;\r\n\r\n        const constructViewpoint = (data: any): MarkupViewpoint => {\r\n            return {\r\n                guid: data[\"@_Guid\"],\r\n                viewpoint: data[\"Viewpoint\"],\r\n                snapshot: data[\"Snapshot\"]\r\n            };\r\n        }\r\n\r\n        const viewpoints: MarkupViewpoint[] = []\r\n\r\n        if(Array.isArray(data)){\r\n            data.forEach((x) => {\r\n                viewpoints.push(constructViewpoint(x));\r\n            })\r\n        }else {\r\n            viewpoints.push(constructViewpoint(data))\r\n        }\r\n\r\n        return viewpoints;\r\n    }\r\n\r\n    export function GetComments(data: any) {\r\n        if(!data) return;\r\n\r\n        const constructComment = (data: any): IComment => {\r\n            return {\r\n                guid: data[\"@_Guid\"],\r\n                date: data[\"Date\"],\r\n                author: data[\"Author\"],\r\n                comment: data[\"Comment\"],\r\n                viewpoint: data?.Viewpoint?.[\"@_Guid\"],\r\n                modified_date: data[\"ModifiedDate\"],\r\n                modified_author: data[\"ModifiedAuthor\"]\r\n            };\r\n        }\r\n\r\n        const viewpoints: IComment[] = []\r\n\r\n        if(Array.isArray(data)){\r\n            data.forEach((x) => {\r\n                viewpoints.push(constructComment(x));\r\n            })\r\n        }else {\r\n            viewpoints.push(constructComment(data))\r\n        }\r\n\r\n        return viewpoints;\r\n    }\r\n\r\n    /**\r\n     * Returns an object as an array\r\n     * Can also accept array and returns new array if type is unknown\r\n     *\r\n     * @return data as an array\r\n     * @param data\r\n     */\r\n    export function ObjectToArray(data: any) {\r\n        return Array.isArray(data) ? data : [data]\r\n    }\r\n\r\n    export function ParsePoint(point: any){\r\n        return {\r\n            x: point.X,\r\n            y: point.Y,\r\n            z: point.Z\r\n        }\r\n    }\r\n}","export * from \"./BcfReader\"\r\nexport * from \"./schema\"","export * from './viewpoint'\r\nexport * from './markup'","'use strict';\n//parse Empty Node as self closing node\nconst buildOptions = require('./util').buildOptions;\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  format: false,\n  indentBy: '  ',\n  supressEmptyNode: false,\n  tagValueProcessor: function(a) {\n    return a;\n  },\n  attrValueProcessor: function(a) {\n    return a;\n  },\n};\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'cdataTagName',\n  'cdataPositionChar',\n  'format',\n  'indentBy',\n  'supressEmptyNode',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'rootNodeName', //when array as root\n];\n\nfunction Parser(options) {\n  this.options = buildOptions(options, defaultOptions, props);\n  if (this.options.ignoreAttributes || this.options.attrNodeName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n  if (this.options.cdataTagName) {\n    this.isCDATA = isCDATA;\n  } else {\n    this.isCDATA = function(/*a*/) {\n      return false;\n    };\n  }\n  this.replaceCDATAstr = replaceCDATAstr;\n  this.replaceCDATAarr = replaceCDATAarr;\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n\n  if (this.options.supressEmptyNode) {\n    this.buildTextNode = buildEmptyTextNode;\n    this.buildObjNode = buildEmptyObjNode;\n  } else {\n    this.buildTextNode = buildTextValNode;\n    this.buildObjNode = buildObjectNode;\n  }\n\n  this.buildTextValNode = buildTextValNode;\n  this.buildObjectNode = buildObjectNode;\n}\n\nParser.prototype.parse = function(jObj) {\n  if(Array.isArray(jObj) && this.options.rootNodeName && this.options.rootNodeName.length > 1){\n    jObj = {\n      [this.options.rootNodeName] : jObj\n    }\n  }\n  return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node\n    } else if (jObj[key] === null) {\n      val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += ' ' + attr + '=\"' + this.options.attrValueProcessor('' + jObj[key]) + '\"';\n      } else if (this.isCDATA(key)) {\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAstr('', jObj[key]);\n        }\n      } else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          if (jObj[this.options.cdataTagName]) {\n            //value will added while processing cdata\n          } else {\n            val += this.options.tagValueProcessor('' + jObj[key]);\n          }\n        } else {\n          val += this.buildTextNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      if (this.isCDATA(key)) {\n        val += this.indentate(level);\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAarr('', jObj[key]);\n        }\n      } else {\n        //nested nodes\n        const arrLen = jObj[key].length;\n        for (let j = 0; j < arrLen; j++) {\n          const item = jObj[key][j];\n          if (typeof item === 'undefined') {\n            // supress undefined node\n          } else if (item === null) {\n            val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          } else if (typeof item === 'object') {\n            val += this.processTextOrObjNode(item, key, level)\n          } else {\n            val += this.buildTextNode(item, key, '', level);\n          }\n        }\n      }\n    } else {\n      //nested node\n      if (this.options.attrNodeName && key === this.options.attrNodeName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += ' ' + Ks[j] + '=\"' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '\"';\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextNode(result.val, key, result.attrStr, level);\n  } else {\n    return this.buildObjNode(result.val, key, result.attrStr, level);\n  }\n}\n\nfunction replaceCDATAstr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;\n  } else {\n    return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);\n  }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;\n  } else {\n    for (let v in cdata) {\n      str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');\n    }\n    return str + this.newLine;\n  }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n  if (attrStr && val.indexOf('<') === -1) {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      '>' +\n      val +\n      //+ this.newLine\n      // + this.indentate(level)\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  } else {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      this.tagEndChar +\n      val +\n      //+ this.newLine\n      this.indentate(level) +\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  }\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n    //+ this.newLine\n  }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n  return (\n    this.indentate(level) +\n    '<' +\n    key +\n    attrStr +\n    '>' +\n    this.options.tagValueProcessor(val) +\n    '</' +\n    key +\n    this.tagEndChar\n  );\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildTextValNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n  }\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix)) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nfunction isCDATA(name) {\n  return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;\n","'use strict';\nconst char = function(a) {\n  return String.fromCharCode(a);\n};\n\nconst chars = {\n  nilChar: char(176),\n  missingChar: char(201),\n  nilPremitive: char(175),\n  missingPremitive: char(200),\n\n  emptyChar: char(178),\n  emptyValue: char(177), //empty Premitive\n\n  boundryChar: char(179),\n\n  objStart: char(198),\n  arrStart: char(204),\n  arrayEnd: char(185),\n};\n\nconst charsArr = [\n  chars.nilChar,\n  chars.nilPremitive,\n  chars.missingChar,\n  chars.missingPremitive,\n  chars.boundryChar,\n  chars.emptyChar,\n  chars.emptyValue,\n  chars.arrayEnd,\n  chars.objStart,\n  chars.arrStart,\n];\n\nconst _e = function(node, e_schema, options) {\n  if (typeof e_schema === 'string') {\n    //premitive\n    if (node && node[0] && node[0].val !== undefined) {\n      return getValue(node[0].val, e_schema);\n    } else {\n      return getValue(node, e_schema);\n    }\n  } else {\n    const hasValidData = hasData(node);\n    if (hasValidData === true) {\n      let str = '';\n      if (Array.isArray(e_schema)) {\n        //attributes can't be repeated. hence check in children tags only\n        str += chars.arrStart;\n        const itemSchema = e_schema[0];\n        //const itemSchemaType = itemSchema;\n        const arr_len = node.length;\n\n        if (typeof itemSchema === 'string') {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = getValue(node[arr_i].val, itemSchema);\n            str = processValue(str, r);\n          }\n        } else {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = _e(node[arr_i], itemSchema, options);\n            str = processValue(str, r);\n          }\n        }\n        str += chars.arrayEnd; //indicates that next item is not array item\n      } else {\n        //object\n        str += chars.objStart;\n        const keys = Object.keys(e_schema);\n        if (Array.isArray(node)) {\n          node = node[0];\n        }\n        for (let i in keys) {\n          const key = keys[i];\n          //a property defined in schema can be present either in attrsMap or children tags\n          //options.textNodeName will not present in both maps, take it's value from val\n          //options.attrNodeName will be present in attrsMap\n          let r;\n          if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n            r = _e(node.attrsMap[key], e_schema[key], options);\n          } else if (key === options.textNodeName) {\n            r = _e(node.val, e_schema[key], options);\n          } else {\n            r = _e(node.child[key], e_schema[key], options);\n          }\n          str = processValue(str, r);\n        }\n      }\n      return str;\n    } else {\n      return hasValidData;\n    }\n  }\n};\n\nconst getValue = function(a /*, type*/) {\n  switch (a) {\n    case undefined:\n      return chars.missingPremitive;\n    case null:\n      return chars.nilPremitive;\n    case '':\n      return chars.emptyValue;\n    default:\n      return a;\n  }\n};\n\nconst processValue = function(str, r) {\n  if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n    str += chars.boundryChar;\n  }\n  return str + r;\n};\n\nconst isAppChar = function(ch) {\n  return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n  if (jObj === undefined) {\n    return chars.missingChar;\n  } else if (jObj === null) {\n    return chars.nilChar;\n  } else if (\n    jObj.child &&\n    Object.keys(jObj.child).length === 0 &&\n    (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)\n  ) {\n    return chars.emptyChar;\n  } else {\n    return true;\n  }\n}\n\nconst x2j = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\n\nconst convert2nimn = function(node, e_schema, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n  return _e(node, e_schema, options);\n};\n\nexports.convert2nimn = convert2nimn;\n","'use strict';\n\nconst util = require('./util');\n\nconst convertToJson = function(node, options, parentTagName) {\n  const jObj = {};\n\n  // when no child node or attr is present\n  if (!options.alwaysCreateTextNode && (!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  }\n\n  // otherwise create a textnode if node has some text\n  if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName)\n    jObj[options.textNodeName] = asArray ? [node.val] : node.val;\n  }\n\n  util.merge(jObj, node.attrsMap, options.arrayMode);\n\n  const keys = Object.keys(node.child);\n  for (let index = 0; index < keys.length; index++) {\n    const tagName = keys[index];\n    if (node.child[tagName] && node.child[tagName].length > 1) {\n      jObj[tagName] = [];\n      for (let tag in node.child[tagName]) {\n        if (node.child[tagName].hasOwnProperty(tag)) {\n          jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));\n        }\n      }\n    } else {\n      const result = convertToJson(node.child[tagName][0], options, tagName);\n      const asArray = (options.arrayMode === true && typeof result === 'object') || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);\n      jObj[tagName] = asArray ? [result] : result;\n    }\n  }\n\n  //add value\n  return jObj;\n};\n\nexports.convertToJson = convertToJson;\n","'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst x2j = require('./xmlstr2xmlnode');\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n\n  options.indentBy = options.indentBy || '';\n  return _cToJsonStr(node, options, 0);\n};\n\nconst _cToJsonStr = function(node, options, level) {\n  let jObj = '{';\n\n  //traver through all the children\n  const keys = Object.keys(node.child);\n\n  for (let index = 0; index < keys.length; index++) {\n    const tagname = keys[index];\n    if (node.child[tagname] && node.child[tagname].length > 1) {\n      jObj += '\"' + tagname + '\" : [ ';\n      for (let tag in node.child[tagname]) {\n        jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';\n      }\n      jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last\n    } else {\n      jObj += '\"' + tagname + '\" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';\n    }\n  }\n  util.merge(jObj, node.attrsMap);\n  //add attrsMap as new children\n  if (util.isEmptyObject(jObj)) {\n    return util.isExist(node.val) ? node.val : '';\n  } else {\n    if (util.isExist(node.val)) {\n      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n        jObj += '\"' + options.textNodeName + '\" : ' + stringval(node.val);\n      }\n    }\n  }\n  //add value\n  if (jObj[jObj.length - 1] === ',') {\n    jObj = jObj.substr(0, jObj.length - 2);\n  }\n  return jObj + '}';\n};\n\nfunction stringval(v) {\n  if (v === true || v === false || !isNaN(v)) {\n    return v;\n  } else {\n    return '\"' + v + '\"';\n  }\n}\n\nfunction indentate(options, level) {\n  return options.indentBy.repeat(level);\n}\n\nexports.convertToJsonString = convertToJsonString;\n","'use strict';\n\nconst nodeToJson = require('./node2json');\nconst xmlToNodeobj = require('./xmlstr2xmlnode');\nconst x2xmlnode = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\nconst validator = require('./validator');\n\nexports.parse = function(xmlData, givenOptions = {}, validationOption) {\n  if( validationOption){\n    if(validationOption === true) validationOption = {}\n    \n    const result = validator.validate(xmlData, validationOption);\n    if (result !== true) {\n      throw Error( result.err.msg)\n    }\n  }\n  if(givenOptions.parseTrueNumberOnly \n    && givenOptions.parseNodeValue !== false\n    && !givenOptions.numParseOptions){\n    \n      givenOptions.numParseOptions = {\n        leadingZeros: false,\n      }\n  }\n  let options = buildOptions(givenOptions, x2xmlnode.defaultOptions, x2xmlnode.props);\n\n  const traversableObj = xmlToNodeobj.getTraversalObj(xmlData, options)\n  //print(traversableObj, \"  \");\n  return nodeToJson.convertToJson(traversableObj, options);\n};\nexports.convertTonimn = require('./nimndata').convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = require('./node2json_str').convertToJsonString;\nexports.validate = validator.validate;\nexports.j2xParser = require('./json2xml');\nexports.parseToNimn = function(xmlData, schema, options) {\n  return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);\n};\n\n\nfunction print(xmlNode, indentation){\n  if(xmlNode){\n    console.log(indentation + \"{\")\n    console.log(indentation + \"  \\\"tagName\\\": \\\"\" + xmlNode.tagname + \"\\\", \");\n    if(xmlNode.parent){\n      console.log(indentation + \"  \\\"parent\\\": \\\"\" + xmlNode.parent.tagname  + \"\\\", \");\n    }\n    console.log(indentation + \"  \\\"val\\\": \\\"\" + xmlNode.val  + \"\\\", \");\n    console.log(indentation + \"  \\\"attrs\\\": \" + JSON.stringify(xmlNode.attrsMap,null,4)  + \", \");\n\n    if(xmlNode.child){\n      console.log(indentation + \"\\\"child\\\": {\")\n      const indentation2 = indentation + indentation;\n      Object.keys(xmlNode.child).forEach( function(key) {\n        const node = xmlNode.child[key];\n\n        if(Array.isArray(node)){\n          console.log(indentation +  \"\\\"\"+key+\"\\\" :[\")\n          node.forEach( function(item,index) {\n            //console.log(indentation + \" \\\"\"+index+\"\\\" : [\")\n            print(item, indentation2);\n          })\n          console.log(indentation + \"],\")  \n        }else{\n          console.log(indentation + \" \\\"\"+key+\"\\\" : {\")\n          print(node, indentation2);\n          console.log(indentation + \"},\")  \n        }\n      });\n      console.log(indentation + \"},\")\n    }\n    console.log(indentation + \"},\")\n  }\n}\n","'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options, defaultOptions, props) {\n  let newOptions = {};\n  if (!options) {\n    return defaultOptions; //if there are not options\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    if (options[props[i]] !== undefined) {\n      newOptions[props[i]] = options[props[i]];\n    } else {\n      newOptions[props[i]] = defaultOptions[props[i]];\n    }\n  }\n  return newOptions;\n};\n\n/**\n * Check if a tag name should be treated as array\n *\n * @param tagName the node tagname\n * @param arrayMode the array mode option\n * @param parentTagName the parent tag name\n * @returns {boolean} true if node should be parsed as array\n */\nexports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {\n  if (arrayMode === false) {\n    return false;\n  } else if (arrayMode instanceof RegExp) {\n    return arrayMode.test(tagName);\n  } else if (typeof arrayMode === 'function') {\n    return !!arrayMode(tagName, parentTagName);\n  }\n\n  return arrayMode === \"strict\";\n}\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n};\n\nconst props = ['allowBooleanAttributes'];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = util.buildOptions(options, defaultOptions, props);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n\n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if (xmlData[i] === ' ' || xmlData[i] === '\\t' || xmlData[i] === '\\n' || xmlData[i] === '\\r') {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","'use strict';\n\nmodule.exports = function(tagname, parent, val) {\n  this.tagname = tagname;\n  this.parent = parent;\n  this.child = {}; //child tags\n  this.attrsMap = {}; //attributes map\n  this.val = val; //text only\n  this.addChild = function(child) {\n    if (Array.isArray(this.child[child.tagname])) {\n      //already presents\n      this.child[child.tagname].push(child);\n    } else {\n      this.child[child.tagname] = [child];\n    }\n  };\n};\n","'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst toNumber = require(\"strnum\");\n\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false, //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true, //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  numParseOptions: {\n    hex: true,\n    leadingZeros: true\n  },\n  tagValueProcessor: function(a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function(a, attrName) {\n    return a;\n  },\n  stopNodes: [],\n  alwaysCreateTextNode: false\n  //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'ignoreNameSpace',\n  'allowBooleanAttributes',\n  'parseNodeValue',\n  'parseAttributeValue',\n  'arrayMode',\n  'trimValues',\n  'cdataTagName',\n  'cdataPositionChar',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'parseTrueNumberOnly',\n  'numParseOptions',\n  'stopNodes',\n  'alwaysCreateTextNode'\n];\nexports.props = props;\n\n/**\n * Trim -> valueProcessor -> parse value\n * @param {string} tagName\n * @param {string} val\n * @param {object} options\n */\nfunction processTagValue(tagName, val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.numParseOptions);\n  }\n\n  return val;\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(\n            matches[i][4],\n            options.parseAttributeValue,\n            options.numParseOptions\n          );\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nconst getTraversalObj = function(xmlData, options) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n  options = buildOptions(options, defaultOptions, props);\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n\n//function match(xmlData){\n  for(let i=0; i< xmlData.length; i++){\n    const ch = xmlData[i];\n    if(ch === '<'){\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        /* if (currentNode.parent) {\n          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);\n        } */\n        if(currentNode){\n          if(currentNode.val){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData , options);\n          }else{\n            currentNode.val = processTagValue(tagName, textData , options);\n          }\n        }\n\n        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n          currentNode.child = []\n          if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}\n          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1)\n        }\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\")\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"-->\", i, \"Comment is not closed.\")\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\")\n        const tagExp = xmlData.substring(i, closeIndex);\n        if(tagExp.indexOf(\"[\") >= 0){\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        }else{\n          i = closeIndex;\n        }\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n        if(textData){\n          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData , options);\n          textData = \"\";\n        }\n\n        if (options.cdataTagName) {\n          //add cdata node\n          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);\n          currentNode.addChild(childNode);\n          //for backtracking\n          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n          //add rest value to parent node\n          if (tagExp) {\n            childNode.val = tagExp;\n          }\n        } else {\n          currentNode.val = (currentNode.val || '') + (tagExp || '');\n        }\n\n        i = closeIndex + 2;\n      }else {//Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i+1)\n        let tagExp = result.data;\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        let shouldBuildAttributesMap = true;\n        if(separatorIndex !== -1){\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);\n          }\n        }\n\n        //save text to parent node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue( currentNode.tagname, textData, options);\n          }\n        }\n\n        if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){//selfClosing tag\n\n          if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          }else{\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n\n          const childNode = new xmlNode(tagName, currentNode, '');\n          if(tagName !== tagExp){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n        }else{//opening tag\n\n          const childNode = new xmlNode( tagName, currentNode );\n          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n            childNode.startIndex=closeIndex;\n          }\n          if(tagName !== tagExp && shouldBuildAttributesMap){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n        textData = \"\";\n        i = closeIndex;\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj;\n}\n\nfunction closingIndexForOpeningTag(data, i){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === '>') {\n        return {\n          data: tagExp,\n          index: index\n        }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n// const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat = window.parseFloat;\n}\n\n  \nconst consider = {\n    hex :  true,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    // const options = Object.assign({}, consider);\n    // if(opt.leadingZeros === false){\n    //     options.leadingZeros = false;\n    // }else if(opt.hex === false){\n    //     options.hex = false;\n    // }\n\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    // if(trimmedStr === \"0.0\") return 0;\n    // else if(trimmedStr === \"+0.0\") return 0;\n    // else if(trimmedStr === \"-0.0\") return -0;\n\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n    // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            const eNotation = match[4] || match[6];\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(eNotation){ //given number has enotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    // const decimalPart = match[5].substr(1);\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n\n                    \n                    // const p = numStr.indexOf(\".\");\n                    // const givenIntPart = numStr.substr(0,p);\n                    // const givenDecPart = numStr.substr(p+1);\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    // if(numTrimmedByZeros === numStr){\n                    //     if(options.leadingZeros) return num;\n                    //     else return str;\n                    // }else return str;\n                    if(numTrimmedByZeros === numStr) return num;\n                    else if(sign+numTrimmedByZeros === numStr) return num;\n                    else return str;\n                }\n\n                if(trimmedStr === numStr) return num;\n                else if(trimmedStr === sign+numStr) return num;\n                // else{\n                //     //number with +/- sign\n                //     trimmedStr.test(/[-+][0-9]);\n\n                // }\n                return str;\n            }\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n            \n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\nmodule.exports = toNumber\n","/* unzipit@1.4.0, license MIT */\n/* global SharedArrayBuffer, process */\n\nfunction readBlobAsArrayBuffer(blob) {\n  if (blob.arrayBuffer) {\n    return blob.arrayBuffer();\n  }\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', () => {\n      resolve(reader.result);\n    });\n    reader.addEventListener('error', reject);\n    reader.readAsArrayBuffer(blob);\n  });\n}\n\nasync function readBlobAsUint8Array(blob) {\n  const arrayBuffer = await readBlobAsArrayBuffer(blob);\n  return new Uint8Array(arrayBuffer);\n}\n\nfunction isBlob(v) {\n  return typeof Blob !== 'undefined' && v instanceof Blob;\n}\n\nfunction isSharedArrayBuffer(b) {\n  return typeof SharedArrayBuffer !== 'undefined' && b instanceof SharedArrayBuffer;\n}\n\nconst isNode =\n    (typeof process !== 'undefined') &&\n    process.versions &&\n    (typeof process.versions.node !== 'undefined') &&\n    (typeof process.versions.electron === 'undefined');\n\nfunction isTypedArraySameAsArrayBuffer(typedArray) {\n  return typedArray.byteOffset === 0 && typedArray.byteLength === typedArray.buffer.byteLength;\n}\n\nclass ArrayBufferReader {\n  constructor(arrayBufferOrView) {\n    this.typedArray = (arrayBufferOrView instanceof ArrayBuffer || isSharedArrayBuffer(arrayBufferOrView))\n       ? new Uint8Array(arrayBufferOrView)\n       : new Uint8Array(arrayBufferOrView.buffer, arrayBufferOrView.byteOffset, arrayBufferOrView.byteLength);\n  }\n  async getLength() {\n    return this.typedArray.byteLength;\n  }\n  async read(offset, length) {\n    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + offset, length);\n  }\n}\n\nclass BlobReader {\n  constructor(blob) {\n    this.blob = blob;\n  }\n  async getLength() {\n    return this.blob.size;\n  }\n  async read(offset, length) {\n    const blob = this.blob.slice(offset, offset + length);\n    const arrayBuffer = await readBlobAsArrayBuffer(blob);\n    return new Uint8Array(arrayBuffer);\n  }\n  async sliceAsBlob(offset, length, type = '') {\n    return this.blob.slice(offset, offset + length, type);\n  }\n}\n\nclass HTTPRangeReader {\n  constructor(url) {\n    this.url = url;\n  }\n  async getLength() {\n    if (this.length === undefined) {\n      const req = await fetch(this.url, { method: 'HEAD' });\n      if (!req.ok) {\n        throw new Error(`failed http request ${this.url}, status: ${req.status}: ${req.statusText}`);\n      }\n      this.length = parseInt(req.headers.get('content-length'));\n      if (Number.isNaN(this.length)) {\n        throw Error('could not get length');\n      }\n    }\n    return this.length;\n  }\n  async read(offset, size) {\n    if (size === 0) {\n      return new Uint8Array(0);\n    }\n    const req = await fetch(this.url, {\n      headers: {\n        Range: `bytes=${offset}-${offset + size - 1}`,\n      },\n    });\n    if (!req.ok) {\n      throw new Error(`failed http request ${this.url}, status: ${req.status} offset: ${offset} size: ${size}: ${req.statusText}`);\n    }\n    const buffer = await req.arrayBuffer();\n    return new Uint8Array(buffer);\n  }\n}\n\nfunction inflate(data, buf) {\n\tvar u8=Uint8Array;\n\tif(data[0]==3 && data[1]==0) return (buf ? buf : new u8(0));\n\tvar bitsF = _bitsF, bitsE = _bitsE, decodeTiny = _decodeTiny, get17 = _get17;\n\t\n\tvar noBuf = (buf==null);\n\tif(noBuf) buf = new u8((data.length>>>2)<<3);\n\t\n\tvar BFINAL=0, BTYPE=0, HLIT=0, HDIST=0, HCLEN=0, ML=0, MD=0; \t\n\tvar off = 0, pos = 0;\n\tvar lmap, dmap;\n\t\n\twhile(BFINAL==0) {\t\t\n\t\tBFINAL = bitsF(data, pos  , 1);\n\t\tBTYPE  = bitsF(data, pos+1, 2);  pos+=3;\n\t\t//console.log(BFINAL, BTYPE);\n\t\t\n\t\tif(BTYPE==0) {\n\t\t\tif((pos&7)!=0) pos+=8-(pos&7);\n\t\t\tvar p8 = (pos>>>3)+4, len = data[p8-4]|(data[p8-3]<<8);  //console.log(len);//bitsF(data, pos, 16), \n\t\t\tif(noBuf) buf=_check(buf, off+len);\n\t\t\tbuf.set(new u8(data.buffer, data.byteOffset+p8, len), off);\n\t\t\t//for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\n\t\t\t//for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\n\t\t\tpos = ((p8+len)<<3);  off+=len;  continue;\n\t\t}\n\t\tif(noBuf) buf=_check(buf, off+(1<<17));  // really not enough in many cases (but PNG and ZIP provide buffer in advance)\n\t\tif(BTYPE==1) {  lmap = U.flmap;  dmap = U.fdmap;  ML = (1<<9)-1;  MD = (1<<5)-1;   }\n\t\tif(BTYPE==2) {\n\t\t\tHLIT  = bitsE(data, pos   , 5)+257;  \n\t\t\tHDIST = bitsE(data, pos+ 5, 5)+  1;  \n\t\t\tHCLEN = bitsE(data, pos+10, 4)+  4;  pos+=14;\n\t\t\tfor(var i=0; i<38; i+=2) {  U.itree[i]=0;  U.itree[i+1]=0;  }\n\t\t\tvar tl = 1;\n\t\t\tfor(var i=0; i<HCLEN; i++) {  var l=bitsE(data, pos+i*3, 3);  U.itree[(U.ordr[i]<<1)+1] = l;  if(l>tl)tl=l;  }     pos+=3*HCLEN;  //console.log(itree);\n\t\t\tmakeCodes(U.itree, tl);\n\t\t\tcodes2map(U.itree, tl, U.imap);\n\t\t\t\n\t\t\tlmap = U.lmap;  dmap = U.dmap;\n\t\t\t\n\t\t\tpos = decodeTiny(U.imap, (1<<tl)-1, HLIT+HDIST, data, pos, U.ttree);\n\t\t\tvar mx0 = _copyOut(U.ttree,    0, HLIT , U.ltree);  ML = (1<<mx0)-1;\n\t\t\tvar mx1 = _copyOut(U.ttree, HLIT, HDIST, U.dtree);  MD = (1<<mx1)-1;\n\t\t\t\n\t\t\t//var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\n\t\t\tmakeCodes(U.ltree, mx0);\n\t\t\tcodes2map(U.ltree, mx0, lmap);\n\t\t\t\n\t\t\t//var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\n\t\t\tmakeCodes(U.dtree, mx1);\n\t\t\tcodes2map(U.dtree, mx1, dmap);\n\t\t}\n\t\t//var ooff=off, opos=pos;\n\t\twhile(true) {\n\t\t\tvar code = lmap[get17(data, pos) & ML];  pos += code&15;\n\t\t\tvar lit = code>>>4;  //U.lhst[lit]++;  \n\t\t\tif((lit>>>8)==0) {  buf[off++] = lit;  }\n\t\t\telse if(lit==256) {  break;  }\n\t\t\telse {\n\t\t\t\tvar end = off+lit-254;\n\t\t\t\tif(lit>264) { var ebs = U.ldef[lit-257];  end = off + (ebs>>>3) + bitsE(data, pos, ebs&7);  pos += ebs&7;  }\n\t\t\t\t//dst[end-off]++;\n\t\t\t\t\n\t\t\t\tvar dcode = dmap[get17(data, pos) & MD];  pos += dcode&15;\n\t\t\t\tvar dlit = dcode>>>4;\n\t\t\t\tvar dbs = U.ddef[dlit], dst = (dbs>>>4) + bitsF(data, pos, dbs&15);  pos += dbs&15;\n\t\t\t\t\n\t\t\t\t//var o0 = off-dst, stp = Math.min(end-off, dst);\n\t\t\t\t//if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\n\t\t\t\t//if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\n\t\t\t\t//if(dst==1) buf.fill(buf[off-1], off, end);  else\n\t\t\t\tif(noBuf) buf=_check(buf, off+(1<<17));\n\t\t\t\twhile(off<end) {  buf[off]=buf[off++-dst];    buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  }   \n\t\t\t\toff=end;\n\t\t\t\t//while(off!=end) {  buf[off]=buf[off++-dst];  }\n\t\t\t}\n\t\t}\n\t\t//console.log(off-ooff, (pos-opos)>>>3);\n\t}\n\t//console.log(dst);\n\t//console.log(tlen, dlen, off-tlen+tcnt);\n\treturn buf.length==off ? buf : buf.slice(0,off);\n}\nfunction _check(buf, len) {\n\tvar bl=buf.length;  if(len<=bl) return buf;\n\tvar nbuf = new Uint8Array(Math.max(bl<<1,len));  nbuf.set(buf,0);\n\t//for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\n\treturn nbuf;\n}\n\nfunction _decodeTiny(lmap, LL, len, data, pos, tree) {\n\tvar bitsE = _bitsE, get17 = _get17;\n\tvar i = 0;\n\twhile(i<len) {\n\t\tvar code = lmap[get17(data, pos)&LL];  pos+=code&15;\n\t\tvar lit = code>>>4; \n\t\tif(lit<=15) {  tree[i]=lit;  i++;  }\n\t\telse {\n\t\t\tvar ll = 0, n = 0;\n\t\t\tif(lit==16) {\n\t\t\t\tn = (3  + bitsE(data, pos, 2));  pos += 2;  ll = tree[i-1];\n\t\t\t}\n\t\t\telse if(lit==17) {\n\t\t\t\tn = (3  + bitsE(data, pos, 3));  pos += 3;\n\t\t\t}\n\t\t\telse if(lit==18) {\n\t\t\t\tn = (11 + bitsE(data, pos, 7));  pos += 7;\n\t\t\t}\n\t\t\tvar ni = i+n;\n\t\t\twhile(i<ni) {  tree[i]=ll;  i++; }\n\t\t}\n\t}\n\treturn pos;\n}\nfunction _copyOut(src, off, len, tree) {\n\tvar mx=0, i=0, tl=tree.length>>>1;\n\twhile(i<len) {  var v=src[i+off];  tree[(i<<1)]=0;  tree[(i<<1)+1]=v;  if(v>mx)mx=v;  i++;  }\n\twhile(i<tl ) {  tree[(i<<1)]=0;  tree[(i<<1)+1]=0;  i++;  }\n\treturn mx;\n}\n\nfunction makeCodes(tree, MAX_BITS) {  // code, length\n\tvar max_code = tree.length;\n\tvar code, bits, n, i, len;\n\t\n\tvar bl_count = U.bl_count;  for(var i=0; i<=MAX_BITS; i++) bl_count[i]=0;\n\tfor(i=1; i<max_code; i+=2) bl_count[tree[i]]++;\n\t\n\tvar next_code = U.next_code;\t// smallest code for each length\n\t\n\tcode = 0;\n\tbl_count[0] = 0;\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\tcode = (code + bl_count[bits-1]) << 1;\n\t\tnext_code[bits] = code;\n\t}\n\t\n\tfor (n = 0; n < max_code; n+=2) {\n\t\tlen = tree[n+1];\n\t\tif (len != 0) {\n\t\t\ttree[n] = next_code[len];\n\t\t\tnext_code[len]++;\n\t\t}\n\t}\n}\nfunction codes2map(tree, MAX_BITS, map) {\n\tvar max_code = tree.length;\n\tvar r15 = U.rev15;\n\tfor(var i=0; i<max_code; i+=2) if(tree[i+1]!=0)  {\n\t\tvar lit = i>>1;\n\t\tvar cl = tree[i+1], val = (lit<<4)|cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\n\t\tvar rest = (MAX_BITS-cl), i0 = tree[i]<<rest, i1 = i0 + (1<<rest);\n\t\t//tree[i]=r15[i0]>>>(15-MAX_BITS);\n\t\twhile(i0!=i1) {\n\t\t\tvar p0 = r15[i0]>>>(15-MAX_BITS);\n\t\t\tmap[p0]=val;  i0++;\n\t\t}\n\t}\n}\nfunction revCodes(tree, MAX_BITS) {\n\tvar r15 = U.rev15, imb = 15-MAX_BITS;\n\tfor(var i=0; i<tree.length; i+=2) {  var i0 = (tree[i]<<(MAX_BITS-tree[i+1]));  tree[i] = r15[i0]>>>imb;  }\n}\n\nfunction _bitsE(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8)                        )>>>(pos&7))&((1<<length)-1);  }\nfunction _bitsF(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16))>>>(pos&7))&((1<<length)-1);  }\n/*\nfunction _get9(dt, pos) {\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\n} */\nfunction _get17(dt, pos) {\t// return at least 17 meaningful bytes\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) )>>>(pos&7);\n}\nconst U = function(){\n\tvar u16=Uint16Array, u32=Uint32Array;\n\treturn {\n\t\tnext_code : new u16(16),\n\t\tbl_count  : new u16(16),\n\t\tordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\n\t\tof0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\n\t\texb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\n\t\tldef : new u16(32),\n\t\tdf0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\n\t\tdxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\n\t\tddef : new u32(32),\n\t\tflmap: new u16(  512),  fltree: [],\n\t\tfdmap: new u16(   32),  fdtree: [],\n\t\tlmap : new u16(32768),  ltree : [],  ttree:[],\n\t\tdmap : new u16(32768),  dtree : [],\n\t\timap : new u16(  512),  itree : [],\n\t\t//rev9 : new u16(  512)\n\t\trev15: new u16(1<<15),\n\t\tlhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\n\t\tlits : new u32(15000),\n\t\tstrt : new u16(1<<16),\n\t\tprev : new u16(1<<15)\n\t};  \n} ();\n\n(function(){\t\n\tvar len = 1<<15;\n\tfor(var i=0; i<len; i++) {\n\t\tvar x = i;\n\t\tx = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\n\t\tx = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\n\t\tx = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\n\t\tx = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\n\t\tU.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\n\t}\n\t\n\tfunction pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\n\t\n\tfor(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\n\t\n\tpushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\n\t/*\n\tvar i = 0;\n\tfor(; i<=143; i++) U.fltree.push(0,8);\n\tfor(; i<=255; i++) U.fltree.push(0,9);\n\tfor(; i<=279; i++) U.fltree.push(0,7);\n\tfor(; i<=287; i++) U.fltree.push(0,8);\n\t*/\n\tmakeCodes(U.fltree, 9);\n\tcodes2map(U.fltree, 9, U.flmap);\n\trevCodes (U.fltree, 9);\n\t\n\tpushV(U.fdtree,32,5);\n\t//for(i=0;i<32; i++) U.fdtree.push(0,5);\n\tmakeCodes(U.fdtree, 5);\n\tcodes2map(U.fdtree, 5, U.fdmap);\n\trevCodes (U.fdtree, 5);\n\t\n\tpushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\n\t/*\n\tfor(var i=0; i< 19; i++) U.itree.push(0,0);\n\tfor(var i=0; i<286; i++) U.ltree.push(0,0);\n\tfor(var i=0; i< 30; i++) U.dtree.push(0,0);\n\tfor(var i=0; i<320; i++) U.ttree.push(0,0);\n\t*/\n})();\n\nconst crc = {\r\n\ttable : ( function() {\r\n\t   var tab = new Uint32Array(256);\r\n\t   for (var n=0; n<256; n++) {\r\n\t\t\tvar c = n;\r\n\t\t\tfor (var k=0; k<8; k++) {\r\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\r\n\t\t\t\telse        c = c >>> 1;\r\n\t\t\t}\r\n\t\t\ttab[n] = c;  }    \r\n\t\treturn tab;  })(),\r\n\tupdate : function(c, buf, off, len) {\r\n\t\tfor (var i=0; i<len; i++)  c = crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\r\n\t\treturn c;\r\n\t},\r\n\tcrc : function(b,o,l)  {  return crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\r\n};\r\n\r\nfunction inflateRaw(file, buf) {  return inflate(file, buf);  }\n\n/* global module */\n\nconst config = {\n  numWorkers: 1,\n  workerURL: '',\n  useWorkers: false,\n};\n\nlet nextId = 0;\n\n// Requests are put on a queue.\n// We don't send the request to the worker until the worker\n// is finished. This probably adds a small amount of latency\n// but the issue is imagine you have 2 workers. You give worker\n// A x seconds of work to do and worker B y seconds of work to\n// do. You don't know which will finish first. If you give\n// the worker with more work to do the request then you'll\n// waste time.\n\n// note: we can't check `workers.length` for deciding if\n// we've reached `config.numWorkers` because creation the worker\n// is async which means other requests to make workers might\n// come in before a worker gets added to `workers`\nlet numWorkers = 0;\nlet canUseWorkers = true;   // gets set to false if we can't start a worker\nconst workers = [];\nconst availableWorkers = [];\nconst waitingForWorkerQueue = [];\nconst currentlyProcessingIdToRequestMap = new Map();\n\nfunction handleResult(e) {\n  makeWorkerAvailable(e.target);\n  const {id, error, data} = e.data;\n  const request = currentlyProcessingIdToRequestMap.get(id);\n  currentlyProcessingIdToRequestMap.delete(id);\n  if (error) {\n    request.reject(error);\n  } else {\n    request.resolve(data);\n  }\n}\n\n// Because Firefox uses non-standard onerror to signal an error.\nfunction startWorker(url) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(url);\n    worker.onmessage = (e) => {\n      if (e.data === 'start') {\n        worker.onerror = undefined;\n        worker.onmessage = undefined;\n        resolve(worker);\n      } else {\n        reject(new Error(`unexpected message: ${e.data}`));\n      }\n    };\n    worker.onerror = reject;\n  });\n}\n\nfunction dynamicRequire(mod, request) {\n  return mod.require(request);\n}\n\nconst workerHelper = (function() {\n  if (isNode) {\n    // We need to use `dynamicRequire` because `require` on it's own will be optimized by webpack.\n    const {Worker} = dynamicRequire(module, 'worker_threads');\n    return {\n      async createWorker(url) {\n        return new Worker(url);\n      },\n      addEventListener(worker, fn) {\n        worker.on('message', (data) => {\n          fn({target: worker, data});\n        });\n      },\n      async terminate(worker) {\n        await worker.terminate();\n      },\n    };\n  } else {\n    return {\n      async createWorker(url) {\n        // I don't understand this security issue\n        // Apparently there is some iframe setting or http header\n        // that prevents cross domain workers. But, I can manually\n        // download the text and do it. I reported this to Chrome\n        // and they said it was fine so \\_()_/\n        try {\n          const worker = await startWorker(url);\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker:', url);\n        }\n\n        let text;\n        try {\n          const req = await fetch(url, {mode: 'cors'});\n          if (!req.ok) {\n            throw new Error(`could not load: ${url}`);\n          }\n          text = await req.text();\n          url = URL.createObjectURL(new Blob([text], {type: 'application/javascript'}));\n          const worker = await startWorker(url);\n          config.workerURL = url;  // this is a hack. What's a better way to structure this code?\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker via fetch:', url);\n        }\n\n        if (text !== undefined) {\n          try {\n            url = `data:application/javascript;base64,${btoa(text)}`;\n            const worker = await startWorker(url);\n            config.workerURL = url;\n            return worker;\n          } catch (e) {\n            console.warn('could not load worker via dataURI');\n          }\n        }\n\n        console.warn('workers will not be used');\n        throw new Error('can not start workers');\n      },\n      addEventListener(worker, fn) {\n        worker.addEventListener('message', fn);\n      },\n      async terminate(worker) {\n        worker.terminate();\n      },\n    };\n  }\n}());\n\nfunction makeWorkerAvailable(worker) {\n  availableWorkers.push(worker);\n  processWaitingForWorkerQueue();\n}\n\nasync function getAvailableWorker() {\n  if (availableWorkers.length === 0 && numWorkers < config.numWorkers) {\n    ++numWorkers;  // see comment at numWorkers declaration\n    try {\n      const worker = await workerHelper.createWorker(config.workerURL);\n      workers.push(worker);\n      availableWorkers.push(worker);\n      workerHelper.addEventListener(worker, handleResult);\n    } catch (e) {\n      // set this global out-of-band (needs refactor)\n      canUseWorkers = false;\n    }\n  }\n  return availableWorkers.pop();\n}\n\n// @param {Uint8Array} src\n// @param {number} uncompressedSize\n// @param {string} [type] mime-type\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\nfunction inflateRawLocal(src, uncompressedSize, type, resolve) {\n  const dst = new Uint8Array(uncompressedSize);\n  inflateRaw(src, dst);\n  resolve(type\n     ? new Blob([dst], {type})\n     : dst.buffer);\n}\n\nasync function processWaitingForWorkerQueue() {\n  if (waitingForWorkerQueue.length === 0) {\n    return;\n  }\n\n  if (config.useWorkers && canUseWorkers) {\n    const worker = await getAvailableWorker();\n    // canUseWorkers might have been set out-of-band (need refactor)\n    if (canUseWorkers) {\n      if (worker) {\n        if (waitingForWorkerQueue.length === 0) {\n          // the queue might be empty while we awaited for a worker.\n          makeWorkerAvailable(worker);\n          return;\n        }\n        const {id, src, uncompressedSize, type, resolve, reject} = waitingForWorkerQueue.shift();\n        currentlyProcessingIdToRequestMap.set(id, {id, resolve, reject});\n        const transferables = [];\n        // NOTE: Originally I thought you could transfer an ArrayBuffer.\n        // The code on this side is often using views into the entire file\n        // which means if we transferred we'd lose the entire file. That sucks\n        // because it means there's an expensive copy to send the uncompressed\n        // data to the worker.\n        //\n        // Also originally I thought we could send a Blob but we'd need to refactor\n        // the code in unzipit/readEntryData as currently it reads the uncompressed\n        // bytes.\n        //\n        //if (!isBlob(src) && !isSharedArrayBuffer(src)) {\n        //  transferables.push(src);\n        //}\n        worker.postMessage({\n          type: 'inflate',\n          data: {\n            id,\n            type,\n            src,\n            uncompressedSize,\n          },\n        }, transferables);\n      }\n      return;\n    }\n  }\n\n  // inflate locally\n  // We loop here because what happens if many requests happen at once\n  // the first N requests will try to async make a worker. Other requests\n  // will then be on the queue. But if we fail to make workers then there\n  // are pending requests.\n  while (waitingForWorkerQueue.length) {\n    const {src, uncompressedSize, type, resolve} = waitingForWorkerQueue.shift();\n    let data = src;\n    if (isBlob(src)) {\n      data = await readBlobAsUint8Array(src);\n    }\n    inflateRawLocal(data, uncompressedSize, type, resolve);\n  }\n}\n\nfunction setOptions(options) {\n  config.workerURL = options.workerURL || config.workerURL;\n  // there's no reason to set the workerURL if you're not going to use workers\n  if (options.workerURL) {\n    config.useWorkers = true;\n  }\n  config.useWorkers = options.useWorkers !== undefined ? options.useWorkers : config.useWorkers;\n  config.numWorkers = options.numWorkers || config.numWorkers;\n}\n\n// It has to take non-zero time to put a large typed array in a Blob since the very\n// next instruction you could change the contents of the array. So, if you're reading\n// the zip file for images/video/audio then all you want is a Blob on which to get a URL.\n// so that operation of putting the data in a Blob should happen in the worker.\n//\n// Conversely if you want the data itself then you want an ArrayBuffer immediately\n// since the worker can transfer its ArrayBuffer zero copy.\n//\n// @param {Uint8Array|Blob} src\n// @param {number} uncompressedSize\n// @param {string} [type] falsy or mimeType string (eg: 'image/png')\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\nfunction inflateRawAsync(src, uncompressedSize, type) {\n  return new Promise((resolve, reject) => {\n    // note: there is potential an expensive copy here. In order for the data\n    // to make it into the worker we need to copy the data to the worker unless\n    // it's a Blob or a SharedArrayBuffer.\n    //\n    // Solutions:\n    //\n    // 1. A minor enhancement, if `uncompressedSize` is small don't call the worker.\n    //\n    //    might be a win period as their is overhead calling the worker\n    //\n    // 2. Move the entire library to the worker\n    //\n    //    Good, Maybe faster if you pass a URL, Blob, or SharedArrayBuffer? Not sure about that\n    //    as those are also easy to transfer. Still slow if you pass an ArrayBuffer\n    //    as the ArrayBuffer has to be copied to the worker.\n    //\n    // I guess benchmarking is really the only thing to try.\n    waitingForWorkerQueue.push({src, uncompressedSize, type, resolve, reject, id: nextId++});\n    processWaitingForWorkerQueue();\n  });\n}\n\nfunction clearArray(arr) {\n  arr.splice(0, arr.length);\n}\n\nasync function cleanup() {\n  for (const worker of workers) {\n    await workerHelper.terminate(worker);\n  }\n  clearArray(workers);\n  clearArray(availableWorkers);\n  clearArray(waitingForWorkerQueue);\n  currentlyProcessingIdToRequestMap.clear();\n  numWorkers = 0;\n  canUseWorkers = true;\n}\n\n/*\nclass Zip {\n  constructor(reader) {\n    comment,  // the comment for this entry\n    commentBytes, // the raw comment for this entry\n  }\n}\n*/\n\nfunction dosDateTimeToDate(date, time) {\n  const day = date & 0x1f; // 1-31\n  const month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  const year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  const millisecond = 0;\n  const second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  const minute = time >> 5 & 0x3f; // 0-59\n  const hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nclass ZipEntry {\n  constructor(reader, rawEntry) {\n    this._reader = reader;\n    this._rawEntry = rawEntry;\n    this.name = rawEntry.name;\n    this.nameBytes = rawEntry.nameBytes;\n    this.size = rawEntry.uncompressedSize;\n    this.compressedSize = rawEntry.compressedSize;\n    this.comment = rawEntry.comment;\n    this.commentBytes = rawEntry.commentBytes;\n    this.compressionMethod = rawEntry.compressionMethod;\n    this.lastModDate = dosDateTimeToDate(rawEntry.lastModFileDate, rawEntry.lastModFileTime);\n    this.isDirectory = rawEntry.uncompressedSize === 0 && rawEntry.name.endsWith('/');\n    this.encrypted = !!(rawEntry.generalPurposeBitFlag & 0x1);\n    this.externalFileAttributes = rawEntry.externalFileAttributes;\n    this.versionMadeBy = rawEntry.versionMadeBy;\n  }\n  // returns a promise that returns a Blob for this entry\n  async blob(type = 'application/octet-stream') {\n    return await readEntryDataAsBlob(this._reader, this._rawEntry, type);\n  }\n  // returns a promise that returns an ArrayBuffer for this entry\n  async arrayBuffer() {\n    return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);\n  }\n  // returns text, assumes the text is valid utf8. If you want more options decode arrayBuffer yourself\n  async text() {\n    const buffer = await this.arrayBuffer();\n    return decodeBuffer(new Uint8Array(buffer));\n  }\n  // returns text with JSON.parse called on it. If you want more options decode arrayBuffer yourself\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n}\n\nconst EOCDR_WITHOUT_COMMENT_SIZE = 22;\nconst MAX_COMMENT_SIZE = 0xffff; // 2-byte size\nconst EOCDR_SIGNATURE = 0x06054b50;\nconst ZIP64_EOCDR_SIGNATURE = 0x06064b50;\n\nasync function readAs(reader, offset, length) {\n  return await reader.read(offset, length);\n}\n\n// The point of this function is we want to be able to pass the data\n// to a worker as fast as possible so when decompressing if the data\n// is already a blob and we can get a blob then get a blob.\n//\n// I'm not sure what a better way to refactor this is. We've got examples\n// of multiple readers. Ideally, for every type of reader we could ask\n// it, \"give me a type that is zero copy both locally and when sent to a worker\".\n//\n// The problem is the worker would also have to know the how to handle this\n// opaque type. I suppose the correct solution is to register different\n// reader handlers in the worker so BlobReader would register some\n// `handleZeroCopyType<BlobReader>`. At the moment I don't feel like\n// refactoring. As it is you just pass in an instance of the reader\n// but instead you'd have to register the reader and some how get the\n// source for the `handleZeroCopyType` handler function into the worker.\n// That sounds like a huge PITA, requiring you to put the implementation\n// in a separate file so the worker can load it or some other workaround\n// hack.\n//\n// For now this hack works even if it's not generic.\nasync function readAsBlobOrTypedArray(reader, offset, length, type) {\n  if (reader.sliceAsBlob) {\n    return await reader.sliceAsBlob(offset, length, type);\n  }\n  return await reader.read(offset, length);\n}\n\nconst crc$1 = {\n  unsigned() {\n    return 0;\n  },\n};\n\nfunction getUint16LE(uint8View, offset) {\n  return uint8View[offset    ] +\n         uint8View[offset + 1] * 0x100;\n}\n\nfunction getUint32LE(uint8View, offset) {\n  return uint8View[offset    ] +\n         uint8View[offset + 1] * 0x100 +\n         uint8View[offset + 2] * 0x10000 +\n         uint8View[offset + 3] * 0x1000000;\n}\n\nfunction getUint64LE(uint8View, offset) {\n  return getUint32LE(uint8View, offset) +\n         getUint32LE(uint8View, offset + 4) * 0x100000000;\n}\n\n/* eslint-disable no-irregular-whitespace */\n// const decodeCP437 = (function() {\n//   const cp437 = '\\u0000 !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';\n//\n//   return function(uint8view) {\n//     return Array.from(uint8view).map(v => cp437[v]).join('');\n//   };\n// }());\n/* eslint-enable no-irregular-whitespace */\n\nconst utf8Decoder = new TextDecoder();\nfunction decodeBuffer(uint8View, isUTF8) {  /* eslint-disable-line no-unused-vars */ /* lgtm [js/superfluous-trailing-arguments] */\n  if (isSharedArrayBuffer(uint8View.buffer)) {\n    uint8View = new Uint8Array(uint8View);\n  }\n  return utf8Decoder.decode(uint8View);\n  /*\n  AFAICT the UTF8 flat is not set so it's 100% up to the user\n  to self decode if their file is not utf8 filenames\n  return isUTF8\n      ? utf8Decoder.decode(uint8View)\n      : decodeCP437(uint8View);\n  */\n}\n\nasync function findEndOfCentralDirector(reader, totalLength) {\n  const size = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, totalLength);\n  const readStart = totalLength - size;\n  const data = await readAs(reader, readStart, size);\n  for (let i = size - EOCDR_WITHOUT_COMMENT_SIZE; i >= 0; --i) {\n    if (getUint32LE(data, i) !== EOCDR_SIGNATURE) {\n      continue;\n    }\n\n    // 0 - End of central directory signature\n    const eocdr = new Uint8Array(data.buffer, data.byteOffset + i, data.byteLength - i);\n    // 4 - Number of this disk\n    const diskNumber = getUint16LE(eocdr, 4);\n    if (diskNumber !== 0) {\n      throw new Error(`multi-volume zip files are not supported. This is volume: ${diskNumber}`);\n    }\n\n    // 6 - Disk where central directory starts\n    // 8 - Number of central directory records on this disk\n    // 10 - Total number of central directory records\n    const entryCount = getUint16LE(eocdr, 10);\n    // 12 - Size of central directory (bytes)\n    const centralDirectorySize = getUint32LE(eocdr, 12);\n    // 16 - Offset of start of central directory, relative to start of archive\n    const centralDirectoryOffset = getUint32LE(eocdr, 16);\n    // 20 - Comment length\n    const commentLength = getUint16LE(eocdr, 20);\n    const expectedCommentLength = eocdr.length - EOCDR_WITHOUT_COMMENT_SIZE;\n    if (commentLength !== expectedCommentLength) {\n      throw new Error(`invalid comment length. expected: ${expectedCommentLength}, actual: ${commentLength}`);\n    }\n\n    // 22 - Comment\n    // the encoding is always cp437.\n    const commentBytes = new Uint8Array(eocdr.buffer, eocdr.byteOffset + 22, commentLength);\n    const comment = decodeBuffer(commentBytes);\n\n    if (entryCount === 0xffff || centralDirectoryOffset === 0xffffffff) {\n      return await readZip64CentralDirectory(reader, readStart + i, comment, commentBytes);\n    } else {\n      return await readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n    }\n  }\n\n  throw new Error('could not find end of central directory. maybe not zip file');\n}\n\nconst END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 0x07064b50;\n\nasync function readZip64CentralDirectory(reader, offset, comment, commentBytes) {\n  // ZIP64 Zip64 end of central directory locator\n  const zip64EocdlOffset = offset - 20;\n  const eocdl = await readAs(reader, zip64EocdlOffset, 20);\n\n  // 0 - zip64 end of central dir locator signature\n  if (getUint32LE(eocdl, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory locator signature');\n  }\n\n  // 4 - number of the disk with the start of the zip64 end of central directory\n  // 8 - relative offset of the zip64 end of central directory record\n  const zip64EocdrOffset = getUint64LE(eocdl, 8);\n  // 16 - total number of disks\n\n  // ZIP64 end of central directory record\n  const zip64Eocdr = await readAs(reader, zip64EocdrOffset, 56);\n\n  // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n  if (getUint32LE(zip64Eocdr, 0) !== ZIP64_EOCDR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory record signature');\n  }\n  // 4 - size of zip64 end of central directory record                8 bytes\n  // 12 - version made by                                             2 bytes\n  // 14 - version needed to extract                                   2 bytes\n  // 16 - number of this disk                                         4 bytes\n  // 20 - number of the disk with the start of the central directory  4 bytes\n  // 24 - total number of entries in the central directory on this disk         8 bytes\n  // 32 - total number of entries in the central directory            8 bytes\n  const entryCount = getUint64LE(zip64Eocdr, 32);\n  // 40 - size of the central directory                               8 bytes\n  const centralDirectorySize = getUint64LE(zip64Eocdr, 40);\n  // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n  const centralDirectoryOffset = getUint64LE(zip64Eocdr, 48);\n  // 56 - zip64 extensible data sector                                (variable size)\n  return readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n}\n\nconst CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 0x02014b50;\n\nasync function readEntries(reader, centralDirectoryOffset, centralDirectorySize, rawEntryCount, comment, commentBytes) {\n  let readEntryCursor = 0;\n  const allEntriesBuffer = await readAs(reader, centralDirectoryOffset, centralDirectorySize);\n  const rawEntries = [];\n\n  for (let e = 0; e < rawEntryCount; ++e) {\n    const buffer = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + 46);\n    // 0 - Central directory file header signature\n    const signature = getUint32LE(buffer, 0);\n    if (signature !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE) {\n      throw new Error(`invalid central directory file header signature: 0x${signature.toString(16)}`);\n    }\n    const rawEntry = {\n      // 4 - Version made by\n      versionMadeBy: getUint16LE(buffer, 4),\n      // 6 - Version needed to extract (minimum)\n      versionNeededToExtract: getUint16LE(buffer, 6),\n      // 8 - General purpose bit flag\n      generalPurposeBitFlag: getUint16LE(buffer, 8),\n      // 10 - Compression method\n      compressionMethod: getUint16LE(buffer, 10),\n      // 12 - File last modification time\n      lastModFileTime: getUint16LE(buffer, 12),\n      // 14 - File last modification date\n      lastModFileDate: getUint16LE(buffer, 14),\n      // 16 - CRC-32\n      crc32: getUint32LE(buffer, 16),\n      // 20 - Compressed size\n      compressedSize: getUint32LE(buffer, 20),\n      // 24 - Uncompressed size\n      uncompressedSize: getUint32LE(buffer, 24),\n      // 28 - File name length (n)\n      fileNameLength: getUint16LE(buffer, 28),\n      // 30 - Extra field length (m)\n      extraFieldLength: getUint16LE(buffer, 30),\n      // 32 - File comment length (k)\n      fileCommentLength: getUint16LE(buffer, 32),\n      // 34 - Disk number where file starts\n      // 36 - Internal file attributes\n      internalFileAttributes: getUint16LE(buffer, 36),\n      // 38 - External file attributes\n      externalFileAttributes: getUint32LE(buffer, 38),\n      // 42 - Relative offset of local file header\n      relativeOffsetOfLocalHeader: getUint32LE(buffer, 42),\n    };\n\n    if (rawEntry.generalPurposeBitFlag & 0x40) {\n      throw new Error('strong encryption is not supported');\n    }\n\n    readEntryCursor += 46;\n\n    const data = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + rawEntry.fileNameLength + rawEntry.extraFieldLength + rawEntry.fileCommentLength);\n    rawEntry.nameBytes = data.slice(0, rawEntry.fileNameLength);\n    rawEntry.name = decodeBuffer(rawEntry.nameBytes);\n\n    // 46+n - Extra field\n    const fileCommentStart = rawEntry.fileNameLength + rawEntry.extraFieldLength;\n    const extraFieldBuffer = data.slice(rawEntry.fileNameLength, fileCommentStart);\n    rawEntry.extraFields = [];\n    let i = 0;\n    while (i < extraFieldBuffer.length - 3) {\n      const headerId = getUint16LE(extraFieldBuffer, i + 0);\n      const dataSize = getUint16LE(extraFieldBuffer, i + 2);\n      const dataStart = i + 4;\n      const dataEnd = dataStart + dataSize;\n      if (dataEnd > extraFieldBuffer.length) {\n        throw new Error('extra field length exceeds extra field buffer size');\n      }\n      rawEntry.extraFields.push({\n        id: headerId,\n        data: extraFieldBuffer.slice(dataStart, dataEnd),\n      });\n      i = dataEnd;\n    }\n\n    // 46+n+m - File comment\n    rawEntry.commentBytes = data.slice(fileCommentStart, fileCommentStart + rawEntry.fileCommentLength);\n    rawEntry.comment = decodeBuffer(rawEntry.commentBytes);\n\n    readEntryCursor += data.length;\n\n    if (rawEntry.uncompressedSize            === 0xffffffff ||\n        rawEntry.compressedSize              === 0xffffffff ||\n        rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n      // ZIP64 format\n      // find the Zip64 Extended Information Extra Field\n      const zip64ExtraField = rawEntry.extraFields.find(e => e.id === 0x0001);\n      if (!zip64ExtraField) {\n        throw new Error('expected zip64 extended information extra field');\n      }\n      const zip64EiefBuffer = zip64ExtraField.data;\n      let index = 0;\n      // 0 - Original Size          8 bytes\n      if (rawEntry.uncompressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include uncompressed size');\n        }\n        rawEntry.uncompressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 8 - Compressed Size        8 bytes\n      if (rawEntry.compressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include compressed size');\n        }\n        rawEntry.compressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 16 - Relative Header Offset 8 bytes\n      if (rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include relative header offset');\n        }\n        rawEntry.relativeOffsetOfLocalHeader = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 24 - Disk Start Number      4 bytes\n    }\n\n    // check for Info-ZIP Unicode Path Extra Field (0x7075)\n    // see https://github.com/thejoshwolfe/yauzl/issues/33\n    const nameField = rawEntry.extraFields.find(e =>\n        e.id === 0x7075 &&\n        e.data.length >= 6 && // too short to be meaningful\n        e.data[0] === 1 &&    // Version       1 byte      version of this extra field, currently 1\n        getUint32LE(e.data, 1), crc$1.unsigned(rawEntry.nameBytes)); // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n                                                                   // > If the CRC check fails, this UTF-8 Path Extra Field should be\n                                                                   // > ignored and the File Name field in the header should be used instead.\n    if (nameField) {\n        // UnicodeName Variable UTF-8 version of the entry File Name\n        rawEntry.fileName = decodeBuffer(nameField.data.slice(5));\n    }\n\n    // validate file size\n    if (rawEntry.compressionMethod === 0) {\n      let expectedCompressedSize = rawEntry.uncompressedSize;\n      if ((rawEntry.generalPurposeBitFlag & 0x1) !== 0) {\n        // traditional encryption prefixes the file data with a header\n        expectedCompressedSize += 12;\n      }\n      if (rawEntry.compressedSize !== expectedCompressedSize) {\n        throw new Error(`compressed size mismatch for stored file: ${rawEntry.compressedSize} != ${expectedCompressedSize}`);\n      }\n    }\n    rawEntries.push(rawEntry);\n  }\n  const zip = {\n    comment,\n    commentBytes,\n  };\n  return {\n    zip,\n    entries: rawEntries.map(e => new ZipEntry(reader, e)),\n  };\n}\n\nasync function readEntryDataHeader(reader, rawEntry) {\n  if (rawEntry.generalPurposeBitFlag & 0x1) {\n    throw new Error('encrypted entries not supported');\n  }\n  const buffer = await readAs(reader, rawEntry.relativeOffsetOfLocalHeader, 30);\n  // note: maybe this should be passed in or cached on entry\n  // as it's async so there will be at least one tick (not sure about that)\n  const totalLength = await reader.getLength();\n\n  // 0 - Local file header signature = 0x04034b50\n  const signature = getUint32LE(buffer, 0);\n  if (signature !== 0x04034b50) {\n    throw new Error(`invalid local file header signature: 0x${signature.toString(16)}`);\n  }\n\n  // all this should be redundant\n  // 4 - Version needed to extract (minimum)\n  // 6 - General purpose bit flag\n  // 8 - Compression method\n  // 10 - File last modification time\n  // 12 - File last modification date\n  // 14 - CRC-32\n  // 18 - Compressed size\n  // 22 - Uncompressed size\n  // 26 - File name length (n)\n  const fileNameLength = getUint16LE(buffer, 26);\n  // 28 - Extra field length (m)\n  const extraFieldLength = getUint16LE(buffer, 28);\n  // 30 - File name\n  // 30+n - Extra field\n  const localFileHeaderEnd = rawEntry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n  let decompress;\n  if (rawEntry.compressionMethod === 0) {\n    // 0 - The file is stored (no compression)\n    decompress = false;\n  } else if (rawEntry.compressionMethod === 8) {\n    // 8 - The file is Deflated\n    decompress = true;\n  } else {\n    throw new Error(`unsupported compression method: ${rawEntry.compressionMethod}`);\n  }\n  const fileDataStart = localFileHeaderEnd;\n  const fileDataEnd = fileDataStart + rawEntry.compressedSize;\n  if (rawEntry.compressedSize !== 0) {\n    // bounds check now, because the read streams will probably not complain loud enough.\n    // since we're dealing with an unsigned offset plus an unsigned size,\n    // we only have 1 thing to check for.\n    if (fileDataEnd > totalLength) {\n      throw new Error(`file data overflows file bounds: ${fileDataStart} +  ${rawEntry.compressedSize}  > ${totalLength}`);\n    }\n  }\n  return {\n    decompress,\n    fileDataStart,\n  };\n}\n\nasync function readEntryDataAsArrayBuffer(reader, rawEntry) {\n  const {decompress, fileDataStart} = await readEntryDataHeader(reader, rawEntry);\n  if (!decompress) {\n    const dataView = await readAs(reader, fileDataStart, rawEntry.compressedSize);\n    // make copy?\n    //\n    // 1. The source is a Blob/file. In this case we'll get back TypedArray we can just hand to the user\n    // 2. The source is a TypedArray. In this case we'll get back TypedArray that is a view into a larger buffer\n    //    but because ultimately this is used to return an ArrayBuffer to `someEntry.arrayBuffer()`\n    //    we need to return copy since we need the `ArrayBuffer`, not the TypedArray to exactly match the data.\n    //    Note: We could add another API function `bytes()` or something that returned a `Uint8Array`\n    //    instead of an `ArrayBuffer`. This would let us skip a copy here. But this case only happens for uncompressed\n    //    data. That seems like a rare enough case that adding a new API is not worth it? Or is it? A zip of jpegs or mp3s\n    //    might not be compressed. For now that's a TBD.\n    return isTypedArraySameAsArrayBuffer(dataView) ? dataView.buffer : dataView.slice().buffer;\n  }\n  // see comment in readEntryDateAsBlob\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize);\n  return result;\n}\n\nasync function readEntryDataAsBlob(reader, rawEntry, type) {\n  const {decompress, fileDataStart} = await readEntryDataHeader(reader, rawEntry);\n  if (!decompress) {\n    const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize, type);\n    if (isBlob(typedArrayOrBlob)) {\n      return typedArrayOrBlob;\n    }\n    return new Blob([isSharedArrayBuffer(typedArrayOrBlob.buffer) ? new Uint8Array(typedArrayOrBlob) : typedArrayOrBlob], {type});\n  }\n  // Here's the issue with this mess (should refactor?)\n  // if the source is a blob then we really want to pass a blob to inflateRawAsync to avoid a large\n  // copy if we're going to a worker.\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize, type);\n  return result;\n}\n\nfunction setOptions$1(options) {\n  setOptions(options);\n}\n\nasync function unzipRaw(source) {\n  let reader;\n  if (typeof Blob !== 'undefined' && source instanceof Blob) {\n    reader = new BlobReader(source);\n  } else if (source instanceof ArrayBuffer || (source && source.buffer && source.buffer instanceof ArrayBuffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (isSharedArrayBuffer(source) || isSharedArrayBuffer(source.buffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (typeof source === 'string') {\n    const req = await fetch(source);\n    if (!req.ok) {\n      throw new Error(`failed http request ${source}, status: ${req.status}: ${req.statusText}`);\n    }\n    const blob = await req.blob();\n    reader = new BlobReader(blob);\n  } else if (typeof source.getLength === 'function' && typeof source.read === 'function') {\n    reader = source;\n  } else {\n    throw new Error('unsupported source type');\n  }\n\n  const totalLength = await reader.getLength();\n\n  if (totalLength > Number.MAX_SAFE_INTEGER) {\n    throw new Error(`file too large. size: ${totalLength}. Only file sizes up 4503599627370496 bytes are supported`);\n  }\n\n  return await findEndOfCentralDirector(reader, totalLength);\n}\n\n// If the names are not utf8 you should use unzipitRaw\nasync function unzip(source) {\n  const {zip, entries} = await unzipRaw(source);\n  return {\n    zip,\n    entries: Object.fromEntries(entries.map(v => [v.name, v])),\n  };\n}\n\nfunction cleanup$1() {\n  cleanup();\n}\n\nexport { HTTPRangeReader, cleanup$1 as cleanup, setOptions$1 as setOptions, unzip, unzipRaw };\n","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\n\nfunction _regeneratorRuntime() {\n  \"use strict\";\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n\n  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  var exports = {},\n      Op = Object.prototype,\n      hasOwn = Op.hasOwnProperty,\n      $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n      iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n      asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n      toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n        generator = Object.create(protoGenerator.prototype),\n        context = new Context(tryLocsList || []);\n    return generator._invoke = function (innerFn, self, context) {\n      var state = \"suspendedStart\";\n      return function (method, arg) {\n        if (\"executing\" === state) throw new Error(\"Generator is already running\");\n\n        if (\"completed\" === state) {\n          if (\"throw\" === method) throw arg;\n          return doneResult();\n        }\n\n        for (context.method = method, context.arg = arg;;) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n            if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n            context.dispatchException(context.arg);\n          } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n          state = \"executing\";\n          var record = tryCatch(innerFn, self, context);\n\n          if (\"normal\" === record.type) {\n            if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          }\n\n          \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n        }\n      };\n    }(innerFn, self, context), generator;\n  }\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {}\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n      NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n            value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n\n      reject(record.arg);\n    }\n\n    var previousPromise;\n\n    this._invoke = function (method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    };\n  }\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          for (; ++i < iterable.length;) {\n            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n          }\n\n          return next.value = undefined, next.done = !0, next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    return {\n      next: doneResult\n    };\n  }\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {\n        \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n      }\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n            record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n              hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      }\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\n\nmodule.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithHoles = require(\"./arrayWithHoles.js\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\n\nvar nonIterableRest = require(\"./nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\n\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["BcfReader","topics","read","src","__awaiter","unzipit_1","this","bcf_archive","entries","Object","name","entry","endsWith","push","i","length","t","topic","Topic","console","log","error","getEntry","_a","exports","reader","markup","viewpoints","parseMarkup","parseViewpoints","Helpers_1","markup_file","text","GetMarkup","key","guid","viewpoint","file","Error","GetViewpoint","getViewpointSnapshot","snapshot","blob","Helpers","xmlParserOptions","attributeNamePrefix","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","trimValues","ParsePoint","point","x","X","y","Y","z","Z","xmlString","Markup","fast_xml_parser_1","parse","topic_type","topic_status","reference_link","ObjectToArray","title","priority","index","labels","creation_date","creation_author","modified_date","modified_author","assigned_to","description","comments","GetComments","Comment","GetViewpoints","Viewpoints","xmlData","ifc_guid","Vis","VisualizationInfo","orthogonal_camera","perspective_camera","components","view_setup_hints","spaces_visible","spaces_boundaries_visible","openings_visible","GetViewSetupHints","visibility","default_visibility","exceptions","map","exception","GetVisInfoComponent","GetVisibility","selection","arr","GetSelection","coloring","colors","color","GetColoring","GetComponents","camera_view_point","camera_direction","camera_up_vector","view_to_world_scale","field_of_view","data","constructViewpoint","Array","isArray","forEach","constructComment","date","author","comment","Viewpoint","__exportStar","buildOptions","require","defaultOptions","attrNodeName","textNodeName","cdataTagName","cdataPositionChar","format","indentBy","supressEmptyNode","tagValueProcessor","a","attrValueProcessor","props","Parser","options","isAttribute","attrPrefixLen","isCDATA","replaceCDATAstr","replaceCDATAarr","processTextOrObjNode","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","object","level","result","j2x","undefined","keys","val","attrStr","str","cdata","replace","join","v","indexOf","repeat","startsWith","substr","prototype","jObj","rootNodeName","Date","attr","arrLen","j","item","Ks","L","module","char","String","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","objStart","arrStart","arrayEnd","charsArr","_e","node","e_schema","getValue","hasValidData","child","attrsMap","itemSchema","arr_len","arr_i","r","processValue","isAppChar","ch","x2j","convert2nimn","util","convertToJson","parentTagName","alwaysCreateTextNode","isEmptyObject","isExist","asArray","isTagNameInArrayMode","tagname","arrayMode","merge","tagName","tag","hasOwnProperty","_cToJsonStr","isNaN","convertToJsonString","nodeToJson","xmlToNodeobj","x2xmlnode","validator","givenOptions","validationOption","validate","err","msg","parseTrueNumberOnly","numParseOptions","leadingZeros","traversableObj","getTraversalObj","convertTonimn","j2xParser","parseToNimn","schema","nameStartChar","nameRegexp","regexName","RegExp","obj","target","len","newOptions","test","isName","string","match","exec","getAllMatches","regex","matches","allmatches","startIndex","lastIndex","readPI","start","getErrorObject","getLineNumberForPosition","readCommentAndCDATA","angleBracketsCount","tags","tagFound","reachedRoot","tagStartPos","closingTag","trim","substring","readAttributeStr","value","attrStrStart","isValid","validateAttributeString","code","line","tagClosed","otg","pop","openPos","col","afterAmp","validateAmpersand","JSON","stringify","startChar","validAttrStrRegxp","attrNames","getPositionFromMatch","attrName","validateAttrName","re","validateNumberAmpersand","count","message","lineNumber","lines","split","parent","addChild","xmlNode","toNumber","Number","parseInt","window","parseFloat","hex","stopNodes","processTagValue","parseValue","resolveNameSpace","prefix","charAt","shouldParse","newval","attrsRegx","buildAttributesMap","attrs","attrCollection","closingIndexForOpeningTag","attrBoundary","tagExp","findClosingIndex","errMsg","closingIndex","xmlObj","currentNode","textData","closeIndex","colonIndex","includes","childNode","separatorIndex","shouldBuildAttributesMap","lastIndexOf","hexRegex","numRegex","consider","decimalPoint","eNotation","trimZeros","numStr","assign","trimmedStr","skipLike","sign","numTrimmedByZeros","num","search","readBlobAsArrayBuffer","arrayBuffer","Promise","resolve","reject","FileReader","addEventListener","readAsArrayBuffer","readBlobAsUint8Array","Uint8Array","isBlob","Blob","isSharedArrayBuffer","b","SharedArrayBuffer","isNode","process","versions","electron","isTypedArraySameAsArrayBuffer","typedArray","byteOffset","byteLength","buffer","ArrayBufferReader","arrayBufferOrView","ArrayBuffer","offset","BlobReader","size","slice","type","HTTPRangeReader","url","fetch","method","req","ok","status","statusText","headers","get","Range","_check","buf","bl","nbuf","Math","max","set","_decodeTiny","lmap","LL","pos","tree","bitsE","_bitsE","get17","_get17","lit","ll","n","ni","_copyOut","off","mx","tl","makeCodes","MAX_BITS","bits","max_code","bl_count","U","next_code","codes2map","r15","rev15","cl","rest","i0","i1","revCodes","imb","dt","_bitsF","u16","Uint16Array","u32","Uint32Array","ordr","of0","exb","ldef","df0","dxb","ddef","flmap","fltree","fdmap","fdtree","ltree","ttree","dmap","dtree","imap","itree","lhst","dhst","ihst","lits","strt","prev","pushV","tgt","sv","crc","table","tab","c","k","update","o","l","inflateRaw","u8","bitsF","decodeTiny","noBuf","BFINAL","BTYPE","HLIT","HDIST","HCLEN","ML","MD","mx0","mx1","end","ebs","dcode","dlit","dbs","dst","p8","inflate","config","numWorkers","workerURL","useWorkers","nextId","canUseWorkers","workers","availableWorkers","waitingForWorkerQueue","currentlyProcessingIdToRequestMap","Map","handleResult","e","makeWorkerAvailable","id","request","delete","startWorker","worker","Worker","onmessage","onerror","workerHelper","createWorker","fn","on","terminate","warn","mode","URL","createObjectURL","btoa","processWaitingForWorkerQueue","getAvailableWorker","inflateRawLocal","uncompressedSize","shift","transferables","postMessage","inflateRawAsync","clearArray","splice","clear","ZipEntry","rawEntry","time","_reader","_rawEntry","nameBytes","compressedSize","commentBytes","compressionMethod","lastModDate","lastModFileDate","lastModFileTime","isDirectory","encrypted","generalPurposeBitFlag","externalFileAttributes","versionMadeBy","readEntryDataAsBlob","readEntryDataAsArrayBuffer","decodeBuffer","EOCDR_WITHOUT_COMMENT_SIZE","EOCDR_SIGNATURE","ZIP64_EOCDR_SIGNATURE","readAs","readAsBlobOrTypedArray","sliceAsBlob","crc$1","getUint16LE","uint8View","getUint32LE","getUint64LE","utf8Decoder","TextDecoder","isUTF8","decode","findEndOfCentralDirector","totalLength","min","readStart","eocdr","diskNumber","entryCount","centralDirectorySize","centralDirectoryOffset","commentLength","expectedCommentLength","readZip64CentralDirectory","readEntries","END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE","zip64EocdlOffset","eocdl","zip64EocdrOffset","zip64Eocdr","CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE","rawEntryCount","readEntryCursor","allEntriesBuffer","rawEntries","subarray","signature","toString","versionNeededToExtract","crc32","fileNameLength","extraFieldLength","fileCommentLength","internalFileAttributes","relativeOffsetOfLocalHeader","fileCommentStart","extraFieldBuffer","extraFields","headerId","dataSize","dataEnd","dataStart","zip64ExtraField","find","zip64EiefBuffer","nameField","fileName","expectedCompressedSize","zip","readEntryDataHeader","getLength","localFileHeaderEnd","decompress","fileDataEnd","fileDataStart","dataView","typedArrayOrBlob","setOptions$1","setOptions","unzipRaw","source","MAX_SAFE_INTEGER","unzip","fromEntries","cleanup$1","cleanup","arr2","__esModule","instance","Constructor","TypeError","_defineProperties","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","_i","Symbol","iterator","_s","_arr","_n","_d","call","next","done","_typeof","_regeneratorRuntime","Op","hasOwn","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","arg","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","invoke","__await","then","unwrapped","previousPromise","callInvokeWithMethodAndArg","info","resultName","nextLoc","pushTryEntry","locs","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","displayName","isGeneratorFunction","genFun","ctor","constructor","mark","setPrototypeOf","__proto__","awrap","async","iter","reverse","skipTempReset","stop","rootRecord","rval","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","arrayLikeToArray","minLen","from"],"sourceRoot":""}