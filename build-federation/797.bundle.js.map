{"version":3,"file":"797.bundle.js","mappings":"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","sources":["webpack://ciqo/./node_modules/three-mesh-bvh/src/core/Constants.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/core/buildFunctions.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/math/MathUtilities.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/math/OrientedBox.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/core/castFunctions.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/core/MeshBVH.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/debug/Debug.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/gpu/VertexAttributeTexture.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/gpu/shaderFunctions.js","webpack://ciqo/./node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js"],"sourcesContent":["// Split strategy constants\r\nexport const CENTER = 0;\r\nexport const AVERAGE = 1;\r\nexport const SAH = 2;\r\n\r\n// Traversal constants\r\nexport const NOT_INTERSECTED = 0;\r\nexport const INTERSECTED = 1;\r\nexport const CONTAINED = 2;\r\n\r\n// SAH cost constants\r\n// TODO: hone these costs more. The relative difference between them should be the\r\n// difference in measured time to perform a triangle intersection vs traversing\r\n// bounds.\r\nexport const TRIANGLE_INTERSECT_COST = 1.25;\r\nexport const TRAVERSAL_COST = 1;\r\n\r\n\r\n// Build constants\r\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\r\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\r\n\r\n// EPSILON for computing floating point error during build\r\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\r\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\r\n\r\n","export class MeshBVHNode {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// internal nodes have boundingData, left, right, and splitAxis\r\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\r\n\r\n\t}\r\n\r\n}\r\n","export function arrayToBox( nodeIndex32, array, target ) {\r\n\r\n\ttarget.min.x = array[ nodeIndex32 ];\r\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\r\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\r\n\r\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\r\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\r\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\nexport function getLongestEdgeIndex( bounds ) {\r\n\r\n\tlet splitDimIdx = - 1;\r\n\tlet splitDist = - Infinity;\r\n\r\n\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\r\n\t\tif ( dist > splitDist ) {\r\n\r\n\t\t\tsplitDist = dist;\r\n\t\t\tsplitDimIdx = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn splitDimIdx;\r\n\r\n}\r\n\r\n// copys bounds a into bounds b\r\nexport function copyBounds( source, target ) {\r\n\r\n\ttarget.set( source );\r\n\r\n}\r\n\r\n// sets bounds target to the union of bounds a and b\r\nexport function unionBounds( a, b, target ) {\r\n\r\n\tlet aVal, bVal;\r\n\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\tconst d3 = d + 3;\r\n\r\n\t\t// set the minimum values\r\n\t\taVal = a[ d ];\r\n\t\tbVal = b[ d ];\r\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\r\n\r\n\t\t// set the max values\r\n\t\taVal = a[ d3 ];\r\n\t\tbVal = b[ d3 ];\r\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// expands the given bounds by the provided triangle bounds\r\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\r\n\r\n\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\r\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\r\n\r\n\t\tconst tMin = tCenter - tHalf;\r\n\t\tconst tMax = tCenter + tHalf;\r\n\r\n\t\tif ( tMin < bounds[ d ] ) {\r\n\r\n\t\t\tbounds[ d ] = tMin;\r\n\r\n\t\t}\r\n\r\n\t\tif ( tMax > bounds[ d + 3 ] ) {\r\n\r\n\t\t\tbounds[ d + 3 ] = tMax;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// compute bounds surface area\r\nexport function computeSurfaceArea( bounds ) {\r\n\r\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\r\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\r\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\r\n\r\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\r\n\r\n}\r\n","import { BufferAttribute } from 'three';\r\nimport { MeshBVHNode } from './MeshBVHNode.js';\r\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\r\nimport {\r\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\r\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\r\n} from './Constants.js';\r\n\r\nfunction ensureIndex( geo, options ) {\r\n\r\n\tif ( ! geo.index ) {\r\n\r\n\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\t\tlet index;\r\n\t\tif ( vertexCount > 65535 ) {\r\n\r\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\r\n\r\n\t\t}\r\n\r\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\r\n\r\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\tindex[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\r\n// region in the geometry index that belongs to a different set of material groups requires\r\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\r\n// with triangle indices belongs to another group. For example, if the groups were like this:\r\n//\r\n// [-------------------------------------------------------------]\r\n// |__________________|\r\n//   g0 = [0, 20]  |______________________||_____________________|\r\n//                      g1 = [16, 40]           g2 = [41, 60]\r\n//\r\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\r\nfunction getRootIndexRanges( geo ) {\r\n\r\n\tif ( ! geo.groups || ! geo.groups.length ) {\r\n\r\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\r\n\r\n\t}\r\n\r\n\tconst ranges = [];\r\n\tconst rangeBoundaries = new Set();\r\n\tfor ( const group of geo.groups ) {\r\n\r\n\t\trangeBoundaries.add( group.start );\r\n\t\trangeBoundaries.add( group.start + group.count );\r\n\r\n\t}\r\n\r\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\r\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\r\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\r\n\r\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\r\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\r\n\r\n\t}\r\n\r\n\treturn ranges;\r\n\r\n}\r\n\r\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\r\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\r\n// These are computed together to avoid redundant accesses to bounds array.\r\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\r\n\r\n\tlet minx = Infinity;\r\n\tlet miny = Infinity;\r\n\tlet minz = Infinity;\r\n\tlet maxx = - Infinity;\r\n\tlet maxy = - Infinity;\r\n\tlet maxz = - Infinity;\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tconst includeCentroid = centroidTarget !== null;\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tconst hx = triangleBounds[ i + 1 ];\r\n\t\tconst lx = cx - hx;\r\n\t\tconst rx = cx + hx;\r\n\t\tif ( lx < minx ) minx = lx;\r\n\t\tif ( rx > maxx ) maxx = rx;\r\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\r\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tconst hy = triangleBounds[ i + 3 ];\r\n\t\tconst ly = cy - hy;\r\n\t\tconst ry = cy + hy;\r\n\t\tif ( ly < miny ) miny = ly;\r\n\t\tif ( ry > maxy ) maxy = ry;\r\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\r\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tconst hz = triangleBounds[ i + 5 ];\r\n\t\tconst lz = cz - hz;\r\n\t\tconst rz = cz + hz;\r\n\t\tif ( lz < minz ) minz = lz;\r\n\t\tif ( rz > maxz ) maxz = rz;\r\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\r\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\ttarget[ 0 ] = minx;\r\n\ttarget[ 1 ] = miny;\r\n\ttarget[ 2 ] = minz;\r\n\r\n\ttarget[ 3 ] = maxx;\r\n\ttarget[ 4 ] = maxy;\r\n\ttarget[ 5 ] = maxz;\r\n\r\n\tif ( includeCentroid ) {\r\n\r\n\t\tcentroidTarget[ 0 ] = cminx;\r\n\t\tcentroidTarget[ 1 ] = cminy;\r\n\t\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\t\tcentroidTarget[ 3 ] = cmaxx;\r\n\t\tcentroidTarget[ 4 ] = cmaxy;\r\n\t\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// A stand alone function for retrieving the centroid bounds.\r\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tif ( cx < cminx ) cminx = cx;\r\n\t\tif ( cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tif ( cy < cminy ) cminy = cy;\r\n\t\tif ( cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tif ( cz < cminz ) cminz = cz;\r\n\t\tif ( cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\tcentroidTarget[ 0 ] = cminx;\r\n\tcentroidTarget[ 1 ] = cminy;\r\n\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\tcentroidTarget[ 3 ] = cmaxx;\r\n\tcentroidTarget[ 4 ] = cmaxy;\r\n\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n}\r\n\r\n\r\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\r\n// will be on the left and elements on the right side of the split will be on the right. returns the index\r\n// of the first element on the right side, or offset + count if there are no elements on the right side.\r\nfunction partition( index, triangleBounds, offset, count, split ) {\r\n\r\n\tlet left = offset;\r\n\tlet right = offset + count - 1;\r\n\tconst pos = split.pos;\r\n\tconst axisOffset = split.axis * 2;\r\n\r\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\r\n\twhile ( true ) {\r\n\r\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\r\n\r\n\t\t\tleft ++;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\r\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\r\n\r\n\t\t\tright --;\r\n\r\n\t\t}\r\n\r\n\t\tif ( left < right ) {\r\n\r\n\t\t\t// we need to swap all of the information associated with the triangles at index\r\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\r\n\t\t\t// and perhaps the SAH planes\r\n\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tlet t0 = index[ left * 3 + i ];\r\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\r\n\t\t\t\tindex[ right * 3 + i ] = t0;\r\n\r\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\r\n\r\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tleft ++;\r\n\t\t\tright --;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn left;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst BIN_COUNT = 32;\r\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\r\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\r\n\r\n\treturn {\r\n\r\n\t\tcount: 0,\r\n\t\tbounds: new Float32Array( 6 ),\r\n\t\trightCacheBounds: new Float32Array( 6 ),\r\n\t\tleftCacheBounds: new Float32Array( 6 ),\r\n\t\tcandidate: 0,\r\n\r\n\t};\r\n\r\n} );\r\nconst leftBounds = new Float32Array( 6 );\r\n\r\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\r\n\r\n\tlet axis = - 1;\r\n\tlet pos = 0;\r\n\r\n\t// Center\r\n\tif ( strategy === CENTER ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === AVERAGE ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === SAH ) {\r\n\r\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\r\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\r\n\r\n\t\t// iterate over all axes\r\n\t\tconst cStart = offset * 6;\r\n\t\tconst cEnd = ( offset + count ) * 6;\r\n\t\tfor ( let a = 0; a < 3; a ++ ) {\r\n\r\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\r\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\r\n\t\t\tconst axisLength = axisRight - axisLeft;\r\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\r\n\r\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\r\n\t\t\t// the triangle positions because it will be faster.\r\n\t\t\tif ( count < BIN_COUNT / 4 ) {\r\n\r\n\t\t\t\t// initialize the bin candidates\r\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\r\n\t\t\t\ttruncatedBins.length = count;\r\n\r\n\t\t\t\t// set the candidates\r\n\t\t\t\tlet b = 0;\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ b ];\r\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tbin.count = 0;\r\n\r\n\t\t\t\t\tconst {\r\n\t\t\t\t\t\tbounds,\r\n\t\t\t\t\t\tleftCacheBounds,\r\n\t\t\t\t\t\trightCacheBounds,\r\n\t\t\t\t\t} = bin;\r\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\r\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\r\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t\tbounds[ d ] = Infinity;\r\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttruncatedBins.sort( binsSort );\r\n\r\n\t\t\t\t// remove redundant splits\r\n\t\t\t\tlet splitCount = count;\r\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\r\n\r\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\r\n\t\t\t\t\t\tsplitCount --;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\r\n\r\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\r\n\r\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\r\n\t\t\t\t\t\t\tbin.count ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// expand all the bounds\r\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\tconst leftCount = bin.count;\r\n\t\t\t\t\tconst rightCount = count - bin.count;\r\n\r\n\t\t\t\t\t// check the cost of this split\r\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\r\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\r\n\r\n\t\t\t\t\tlet leftProb = 0;\r\n\t\t\t\t\tif ( leftCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet rightProb = 0;\r\n\t\t\t\t\tif ( rightCount !== 0 ) {\r\n\r\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\r\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = a;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\t\t\t\t\t\tpos = bin.candidate;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset the bins\r\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tbin.count = 0;\r\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\r\n\r\n\t\t\t\t\tconst bounds = bin.bounds;\r\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\t\t\t\t\tbounds[ d ] = Infinity;\r\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterate over all center positions\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\r\n\r\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\r\n\r\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\r\n\t\t\t\t\t// considered to be on the right side of the split\r\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\r\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\r\n\r\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\r\n\t\t\t\t\tbin.count ++;\r\n\r\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\r\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\r\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\r\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\r\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet leftCount = 0;\r\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tconst binCount = bin.count;\r\n\t\t\t\t\tconst bounds = bin.bounds;\r\n\r\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\r\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\r\n\r\n\t\t\t\t\t// dont do anything with the bounds if the new bounds have no triangles\r\n\t\t\t\t\tif ( binCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tif ( leftCount === 0 ) {\r\n\r\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tleftCount += binCount;\r\n\r\n\t\t\t\t\t// check the cost of this split\r\n\t\t\t\t\tlet leftProb = 0;\r\n\t\t\t\t\tlet rightProb = 0;\r\n\r\n\t\t\t\t\tif ( leftCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst rightCount = count - leftCount;\r\n\t\t\t\t\tif ( rightCount !== 0 ) {\r\n\r\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\r\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = a;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\t\t\t\t\t\tpos = bin.candidate;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\r\n\r\n\t}\r\n\r\n\treturn { axis, pos };\r\n\r\n}\r\n\r\n// returns the average coordinate on the specified axis of the all the provided triangles\r\nfunction getAverage( triangleBounds, offset, count, axis ) {\r\n\r\n\tlet avg = 0;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\r\n\r\n\t}\r\n\r\n\treturn avg / count;\r\n\r\n}\r\n\r\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\r\n// result is an array of size tris.length * 6 where triangle i maps to a\r\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\r\n// representing the center and half-extent in each dimension of triangle i\r\nfunction computeTriangleBounds( geo, fullBounds ) {\r\n\r\n\tconst posAttr = geo.attributes.position;\r\n\tconst index = geo.index.array;\r\n\tconst triCount = index.length / 3;\r\n\tconst triangleBounds = new Float32Array( triCount * 6 );\r\n\tconst normalized = posAttr.normalized;\r\n\r\n\t// used for non-normalized positions\r\n\tconst posArr = posAttr.array;\r\n\r\n\t// support for an interleaved position buffer\r\n\tconst bufferOffset = posAttr.offset || 0;\r\n\tlet stride = 3;\r\n\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tstride = posAttr.data.stride;\r\n\r\n\t}\r\n\r\n\t// used for normalized positions\r\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\r\n\r\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\r\n\r\n\t\tconst tri3 = tri * 3;\r\n\t\tconst tri6 = tri * 6;\r\n\r\n\t\tlet ai, bi, ci;\r\n\r\n\t\tif ( normalized ) {\r\n\r\n\t\t\tai = index[ tri3 + 0 ];\r\n\t\t\tbi = index[ tri3 + 1 ];\r\n\t\t\tci = index[ tri3 + 2 ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tai = index[ tri3 + 0 ] * stride + bufferOffset;\r\n\t\t\tbi = index[ tri3 + 1 ] * stride + bufferOffset;\r\n\t\t\tci = index[ tri3 + 2 ] * stride + bufferOffset;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\tlet a, b, c;\r\n\r\n\t\t\tif ( normalized ) {\r\n\r\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\r\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\r\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ta = posArr[ ai + el ];\r\n\t\t\t\tb = posArr[ bi + el ];\r\n\t\t\t\tc = posArr[ ci + el ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet min = a;\r\n\t\t\tif ( b < min ) min = b;\r\n\t\t\tif ( c < min ) min = c;\r\n\r\n\t\t\tlet max = a;\r\n\t\t\tif ( b > max ) max = b;\r\n\t\t\tif ( c > max ) max = c;\r\n\r\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\r\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\r\n\t\t\t// worked with.\r\n\t\t\tconst halfExtents = ( max - min ) / 2;\r\n\t\t\tconst el2 = el * 2;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\r\n\r\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\r\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn triangleBounds;\r\n\r\n}\r\n\r\nexport function buildTree( geo, options ) {\r\n\r\n\tfunction triggerProgress( trianglesProcessed ) {\r\n\r\n\t\tif ( onProgress ) {\r\n\r\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\r\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\r\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\r\n\r\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\r\n\r\n\t\t\treachedMaxDepth = true;\r\n\t\t\tif ( verbose ) {\r\n\r\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\r\n\t\t\t\tconsole.warn( geo );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// early out if we've met our capacity\r\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\t// Find where to split the volume\r\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\r\n\t\tif ( split.axis === - 1 ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\r\n\r\n\t\t// create the two new child nodes\r\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnode.splitAxis = split.axis;\r\n\r\n\t\t\t// create the left child and compute its bounding box\r\n\t\t\tconst left = new MeshBVHNode();\r\n\t\t\tconst lstart = offset;\r\n\t\t\tconst lcount = splitOffset - offset;\r\n\t\t\tnode.left = left;\r\n\t\t\tleft.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t\t// repeat for right\r\n\t\t\tconst right = new MeshBVHNode();\r\n\t\t\tconst rstart = splitOffset;\r\n\t\t\tconst rcount = count - lcount;\r\n\t\t\tnode.right = right;\r\n\t\t\tright.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n\tensureIndex( geo, options );\r\n\r\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\r\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\r\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\r\n\tconst fullBounds = new Float32Array( 6 );\r\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\r\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\r\n\tconst indexArray = geo.index.array;\r\n\tconst maxDepth = options.maxDepth;\r\n\tconst verbose = options.verbose;\r\n\tconst maxLeafTris = options.maxLeafTris;\r\n\tconst strategy = options.strategy;\r\n\tconst onProgress = options.onProgress;\r\n\tconst totalTriangles = geo.index.count / 3;\r\n\tlet reachedMaxDepth = false;\r\n\r\n\tconst roots = [];\r\n\tconst ranges = getRootIndexRanges( geo );\r\n\r\n\tif ( ranges.length === 1 ) {\r\n\r\n\t\tconst range = ranges[ 0 ];\r\n\t\tconst root = new MeshBVHNode();\r\n\t\troot.boundingData = fullBounds;\r\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\r\n\r\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\troots.push( root );\r\n\r\n\t} else {\r\n\r\n\t\tfor ( let range of ranges ) {\r\n\r\n\t\t\tconst root = new MeshBVHNode();\r\n\t\t\troot.boundingData = new Float32Array( 6 );\r\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\r\n\r\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\t\troots.push( root );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn roots;\r\n\r\n}\r\n\r\nexport function buildPackedTree( geo, options ) {\r\n\r\n\t// boundingData  \t\t\t\t: 6 float32\r\n\t// right / offset \t\t\t\t: 1 uint32\r\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\r\n\tconst roots = buildTree( geo, options );\r\n\r\n\tlet float32Array;\r\n\tlet uint32Array;\r\n\tlet uint16Array;\r\n\tconst packedRoots = [];\r\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\tfor ( let i = 0; i < roots.length; i ++ ) {\r\n\r\n\t\tconst root = roots[ i ];\r\n\t\tlet nodeCount = countNodes( root );\r\n\r\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\r\n\t\tfloat32Array = new Float32Array( buffer );\r\n\t\tuint32Array = new Uint32Array( buffer );\r\n\t\tuint16Array = new Uint16Array( buffer );\r\n\t\tpopulateBuffer( 0, root );\r\n\t\tpackedRoots.push( buffer );\r\n\r\n\t}\r\n\r\n\treturn packedRoots;\r\n\r\n\tfunction countNodes( node ) {\r\n\r\n\t\tif ( node.count ) {\r\n\r\n\t\t\treturn 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction populateBuffer( byteOffset, node ) {\r\n\r\n\t\tconst stride4Offset = byteOffset / 4;\r\n\t\tconst stride2Offset = byteOffset / 2;\r\n\t\tconst isLeaf = ! ! node.count;\r\n\t\tconst boundingData = node.boundingData;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = node.offset;\r\n\t\t\tconst count = node.count;\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\r\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\r\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\r\n\t\t\treturn byteOffset + BYTES_PER_NODE;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = node.left;\r\n\t\t\tconst right = node.right;\r\n\t\t\tconst splitAxis = node.splitAxis;\r\n\r\n\t\t\tlet nextUnusedPointer;\r\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\r\n\r\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\r\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\r\n\r\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\r\n\t\t\treturn nextUnusedPointer;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { Vector3 } from 'three';\r\n\r\nexport class SeparatingAxisBounds {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.min = Infinity;\r\n\t\tthis.max = - Infinity;\r\n\r\n\t}\r\n\r\n\tsetFromPointsField( points, field ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = p[ field ];\r\n\t\t\tmin = val < min ? val : min;\r\n\t\t\tmax = val > max ? val : max;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tsetFromPoints( axis, points ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = axis.dot( p );\r\n\t\t\tmin = val < min ? val : min;\r\n\t\t\tmax = val > max ? val : max;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tisSeparated( other ) {\r\n\r\n\t\treturn this.min > other.max || other.min > this.max;\r\n\r\n\t}\r\n\r\n}\r\n\r\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\r\n\r\n\tconst p = new Vector3();\r\n\treturn function setFromBox( axis, box ) {\r\n\r\n\t\tconst boxMin = box.min;\r\n\t\tconst boxMax = box.max;\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\r\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\r\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\r\n\r\n\t\t\t\t\tconst val = axis.dot( p );\r\n\t\t\t\t\tmin = Math.min( val, min );\r\n\t\t\t\t\tmax = Math.max( val, max );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const areIntersecting = ( function () {\r\n\r\n\tconst cacheSatBounds = new SeparatingAxisBounds();\r\n\treturn function areIntersecting( shape1, shape2 ) {\r\n\r\n\t\tconst points1 = shape1.points;\r\n\t\tconst satAxes1 = shape1.satAxes;\r\n\t\tconst satBounds1 = shape1.satBounds;\r\n\r\n\t\tconst points2 = shape2.points;\r\n\t\tconst satAxes2 = shape2.satAxes;\r\n\t\tconst satBounds2 = shape2.satBounds;\r\n\r\n\t\t// check axes of the first shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check axes of the second shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\r\n\r\nexport const closestPointLineToLine = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\r\n\tconst dir1 = new Vector3();\r\n\tconst dir2 = new Vector3();\r\n\tconst v02 = new Vector3();\r\n\treturn function closestPointLineToLine( l1, l2, result ) {\r\n\r\n\t\tconst v0 = l1.start;\r\n\t\tconst v10 = dir1;\r\n\t\tconst v2 = l2.start;\r\n\t\tconst v32 = dir2;\r\n\r\n\t\tv02.subVectors( v0, v2 );\r\n\t\tdir1.subVectors( l1.end, l1.start );\r\n\t\tdir2.subVectors( l2.end, l2.start );\r\n\r\n\t\t// float d0232 = v02.Dot(v32);\r\n\t\tconst d0232 = v02.dot( v32 );\r\n\r\n\t\t// float d3210 = v32.Dot(v10);\r\n\t\tconst d3210 = v32.dot( v10 );\r\n\r\n\t\t// float d3232 = v32.Dot(v32);\r\n\t\tconst d3232 = v32.dot( v32 );\r\n\r\n\t\t// float d0210 = v02.Dot(v10);\r\n\t\tconst d0210 = v02.dot( v10 );\r\n\r\n\t\t// float d1010 = v10.Dot(v10);\r\n\t\tconst d1010 = v10.dot( v10 );\r\n\r\n\t\t// float denom = d1010*d3232 - d3210*d3210;\r\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\r\n\r\n\t\tlet d, d2;\r\n\t\tif ( denom !== 0 ) {\r\n\r\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\r\n\r\n\t\t} else {\r\n\r\n\t\t\td = 0;\r\n\r\n\t\t}\r\n\r\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\r\n\r\n\t\tresult.x = d;\r\n\t\tresult.y = d2;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const closestPointsSegmentToSegment = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\r\n\tconst paramResult = new Vector2();\r\n\tconst temp1 = new Vector3();\r\n\tconst temp2 = new Vector3();\r\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\r\n\r\n\t\tclosestPointLineToLine( l1, l2, paramResult );\r\n\r\n\t\tlet d = paramResult.x;\r\n\t\tlet d2 = paramResult.y;\r\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\tl1.at( d, target1 );\r\n\t\t\tl2.at( d2, target2 );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d >= 0 && d <= 1 ) {\r\n\r\n\t\t\t// Only d2 is out of bounds.\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tl2.at( 0, target2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl2.at( 1, target2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\t// Only d is out of bounds.\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tl1.at( 0, target1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl1.at( 1, target1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Both u and u2 are out of bounds.\r\n\t\t\tlet p;\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tp = l1.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp = l1.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet p2;\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tp2 = l2.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp2 = l2.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst closestPoint = temp1;\r\n\t\t\tconst closestPoint2 = temp2;\r\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\r\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\r\n\r\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\r\n\r\n\t\t\t\ttarget1.copy( closestPoint );\r\n\t\t\t\ttarget2.copy( p2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget1.copy( p );\r\n\t\t\t\ttarget2.copy( closestPoint2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nexport const sphereIntersectTriangle = ( function () {\r\n\r\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\r\n\tconst closestPointTemp = new Vector3();\r\n\tconst projectedPointTemp = new Vector3();\r\n\tconst planeTemp = new Plane();\r\n\tconst lineTemp = new Line3();\r\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\r\n\r\n\t\tconst { radius, center } = sphere;\r\n\t\tconst { a, b, c } = triangle;\r\n\r\n\t\t// phase 1\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = b;\r\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = b;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\t// phase 2\r\n\t\tconst plane = triangle.getPlane( planeTemp );\r\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\r\n\t\tif ( dp <= radius ) {\r\n\r\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\r\n\t\t\tconst cp = triangle.containsPoint( pp );\r\n\t\t\tif ( cp ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\r\n\r\nconst DIST_EPSILON = 1e-15;\r\nfunction isNearZero( value ) {\r\n\r\n\treturn Math.abs( value ) < DIST_EPSILON;\r\n\r\n}\r\n\r\nexport class ExtendedTriangle extends Triangle {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isExtendedTriangle = true;\r\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.points = [ this.a, this.b, this.c ];\r\n\t\tthis.sphere = new Sphere();\r\n\t\tthis.plane = new Plane();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn sphereIntersectTriangle( sphere, this );\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst a = this.a;\r\n\t\tconst b = this.b;\r\n\t\tconst c = this.c;\r\n\t\tconst points = this.points;\r\n\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst satBounds = this.satBounds;\r\n\r\n\t\tconst axis0 = satAxes[ 0 ];\r\n\t\tconst sab0 = satBounds[ 0 ];\r\n\t\tthis.getNormal( axis0 );\r\n\t\tsab0.setFromPoints( axis0, points );\r\n\r\n\t\tconst axis1 = satAxes[ 1 ];\r\n\t\tconst sab1 = satBounds[ 1 ];\r\n\t\taxis1.subVectors( a, b );\r\n\t\tsab1.setFromPoints( axis1, points );\r\n\r\n\t\tconst axis2 = satAxes[ 2 ];\r\n\t\tconst sab2 = satBounds[ 2 ];\r\n\t\taxis2.subVectors( b, c );\r\n\t\tsab2.setFromPoints( axis2, points );\r\n\r\n\t\tconst axis3 = satAxes[ 3 ];\r\n\t\tconst sab3 = satBounds[ 3 ];\r\n\t\taxis3.subVectors( c, a );\r\n\t\tsab3.setFromPoints( axis3, points );\r\n\r\n\t\tthis.sphere.setFromPoints( this.points );\r\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t}\r\n\r\n}\r\n\r\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\r\n\r\n\tconst point1 = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\tconst edge = new Line3();\r\n\r\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\r\n\r\n\t\tconst { start, end } = segment;\r\n\t\tconst points = this.points;\r\n\t\tlet distSq;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check the triangle edges\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst nexti = ( i + 1 ) % 3;\r\n\t\t\tedge.start.copy( points[ i ] );\r\n\t\t\tedge.end.copy( points[ nexti ] );\r\n\r\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\r\n\r\n\t\t\tdistSq = point1.distanceToSquared( point2 );\r\n\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check end points\r\n\t\tthis.closestPointToPoint( start, point1 );\r\n\t\tdistSq = start.distanceToSquared( point1 );\r\n\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\tclosestDistanceSq = distSq;\r\n\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\tif ( target2 ) target2.copy( start );\r\n\r\n\t\t}\r\n\r\n\t\tthis.closestPointToPoint( end, point1 );\r\n\t\tdistSq = end.distanceToSquared( point1 );\r\n\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\tclosestDistanceSq = distSq;\r\n\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\tif ( target2 ) target2.copy( end );\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri2 = new ExtendedTriangle();\r\n\tconst arr1 = new Array( 3 );\r\n\tconst arr2 = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\tconst dir1 = new Vector3();\r\n\tconst dir2 = new Vector3();\r\n\tconst tempDir = new Vector3();\r\n\tconst edge = new Line3();\r\n\tconst edge1 = new Line3();\r\n\tconst edge2 = new Line3();\r\n\r\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\r\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\r\n\treturn function intersectsTriangle( other, target = null ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! other.isExtendedTriangle ) {\r\n\r\n\t\t\tsaTri2.copy( other );\r\n\t\t\tsaTri2.update();\r\n\t\t\tother = saTri2;\r\n\r\n\t\t} else if ( other.needsUpdate ) {\r\n\r\n\t\t\tother.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst plane1 = this.plane;\r\n\t\tconst plane2 = other.plane;\r\n\r\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\r\n\r\n\t\t\t// perform separating axis intersection test only for coplanar triangles\r\n\t\t\tconst satBounds1 = this.satBounds;\r\n\t\t\tconst satAxes1 = this.satAxes;\r\n\t\t\tarr2[ 0 ] = other.a;\r\n\t\t\tarr2[ 1 ] = other.b;\r\n\t\t\tarr2[ 2 ] = other.c;\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\r\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst satBounds2 = other.satBounds;\r\n\t\t\tconst satAxes2 = other.satAxes;\r\n\t\t\tarr1[ 0 ] = this.a;\r\n\t\t\tarr1[ 1 ] = this.b;\r\n\t\t\tarr1[ 2 ] = this.c;\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\r\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check crossed axes\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sa1 = satAxes1[ i ];\r\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\r\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\r\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\r\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( target ) {\r\n\r\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\r\n\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\r\n\r\n\t\t\t\ttarget.start.set( 0, 0, 0 );\r\n\t\t\t\ttarget.end.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// find the edge that intersects the other triangle plane\r\n\t\t\tconst points1 = this.points;\r\n\t\t\tlet found1 = false;\r\n\t\t\tlet count1 = 0;\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tconst p = points1[ i ];\r\n\t\t\t\tconst pNext = points1[ ( i + 1 ) % 3 ];\r\n\r\n\t\t\t\tedge.start.copy( p );\r\n\t\t\t\tedge.end.copy( pNext );\r\n\t\t\t\tedge.delta( dir1 );\r\n\r\n\t\t\t\tconst targetPoint = found1 ? edge1.start : edge1.end;\r\n\t\t\t\tconst startIntersects = isNearZero( plane2.distanceToPoint( p ) );\r\n\t\t\t\tif ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {\r\n\r\n\t\t\t\t\t// if the edge lies on the plane then take the line\r\n\t\t\t\t\tedge1.copy( edge );\r\n\t\t\t\t\tcount1 = 2;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\r\n\t\t\t\tconst doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;\r\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\r\n\r\n\t\t\t\t\tcount1 ++;\r\n\t\t\t\t\tif ( found1 ) {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfound1 = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( count1 === 1 && this.containsPoint( edge1.end ) ) {\r\n\r\n\t\t\t\tif ( target ) {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge1.end );\r\n\t\t\t\t\ttarget.end.copy( edge1.end );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else if ( count1 !== 2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// find the other triangles edge that intersects this plane\r\n\t\t\tconst points2 = other.points;\r\n\t\t\tlet found2 = false;\r\n\t\t\tlet count2 = 0;\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tconst p = points2[ i ];\r\n\t\t\t\tconst pNext = points2[ ( i + 1 ) % 3 ];\r\n\r\n\t\t\t\tedge.start.copy( p );\r\n\t\t\t\tedge.end.copy( pNext );\r\n\t\t\t\tedge.delta( dir2 );\r\n\r\n\t\t\t\tconst targetPoint = found2 ? edge2.start : edge2.end;\r\n\t\t\t\tconst startIntersects = isNearZero( plane1.distanceToPoint( p ) );\r\n\t\t\t\tif ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {\r\n\r\n\t\t\t\t\t// if the edge lies on the plane then take the line\r\n\t\t\t\t\tedge2.copy( edge );\r\n\t\t\t\t\tcount2 = 2;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\r\n\t\t\t\tconst doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;\r\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\r\n\r\n\t\t\t\t\tcount2 ++;\r\n\t\t\t\t\tif ( found2 ) {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfound2 = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\r\n\r\n\t\t\t\tif ( target ) {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge2.end );\r\n\t\t\t\t\ttarget.end.copy( edge2.end );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else if ( count2 !== 2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// find swap the second edge so both lines are running the same direction\r\n\t\t\tedge1.delta( dir1 );\r\n\t\t\tedge2.delta( dir2 );\r\n\r\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\r\n\r\n\t\t\t\tlet tmp = edge2.start;\r\n\t\t\t\tedge2.start = edge2.end;\r\n\t\t\t\tedge2.end = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if the edges are overlapping\r\n\t\t\tconst s1 = edge1.start.dot( dir1 );\r\n\t\t\tconst e1 = edge1.end.dot( dir1 );\r\n\t\t\tconst s2 = edge2.start.dot( dir1 );\r\n\t\t\tconst e2 = edge2.end.dot( dir1 );\r\n\t\t\tconst separated1 = e1 < s2;\r\n\t\t\tconst separated2 = s1 < e2;\r\n\r\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// assign the target output\r\n\t\t\tif ( target ) {\r\n\r\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\r\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge1.start );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge2.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\r\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\r\n\r\n\t\t\t\t\ttarget.end.copy( edge1.end );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttarget.end.copy( edge2.end );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nExtendedTriangle.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\r\n\r\n\tconst point = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\tconst cornerFields = [ 'a', 'b', 'c' ];\r\n\tconst line1 = new Line3();\r\n\tconst line2 = new Line3();\r\n\r\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\r\n\r\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\r\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\r\n\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\r\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check all point distances\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tlet dist;\r\n\t\t\tconst field = cornerFields[ i ];\r\n\t\t\tconst otherVec = other[ field ];\r\n\t\t\tthis.closestPointToPoint( otherVec, point );\r\n\r\n\t\t\tdist = otherVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tconst thisVec = this[ field ];\r\n\t\t\tother.closestPointToPoint( thisVec, point );\r\n\r\n\t\t\tdist = thisVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\r\n\t\t\t\tif ( target2 ) target2.copy( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst f11 = cornerFields[ i ];\r\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\r\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\r\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\r\n\r\n\t\t\t\tconst f21 = cornerFields[ i2 ];\r\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\r\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\r\n\r\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\r\n\r\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Box3, Vector3, Matrix4, Line3 } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\r\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\r\n\r\nexport class OrientedBox extends Box3 {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isOrientedBox = true;\r\n\t\tthis.matrix = new Matrix4();\r\n\t\tthis.invMatrix = new Matrix4();\r\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\r\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t}\r\n\r\n\tset( min, max, matrix ) {\r\n\r\n\t\tsuper.set( min, max );\r\n\t\tthis.matrix.copy( matrix );\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tsuper.copy( other );\r\n\t\tthis.matrix.copy( other.matrix );\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\nOrientedBox.prototype.update = ( function () {\r\n\r\n\treturn function update() {\r\n\r\n\t\tconst matrix = this.matrix;\r\n\t\tconst min = this.min;\r\n\t\tconst max = this.max;\r\n\r\n\t\tconst points = this.points;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\r\n\t\t\t\t\tconst v = points[ i ];\r\n\t\t\t\t\tv.x = x ? max.x : min.x;\r\n\t\t\t\t\tv.y = y ? max.y : min.y;\r\n\t\t\t\t\tv.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tv.applyMatrix4( matrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst minVec = points[ 0 ];\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst index = 1 << i;\r\n\t\t\tconst pi = points[ index ];\r\n\r\n\t\t\taxis.subVectors( minVec, pi );\r\n\t\t\tsb.setFromPoints( axis, points );\r\n\r\n\t\t}\r\n\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\r\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\r\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\r\n\r\n\t\tthis.invMatrix.copy( this.matrix ).invert();\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsBox = ( function () {\r\n\r\n\tconst aabbBounds = new SeparatingAxisBounds();\r\n\treturn function intersectsBox( box ) {\r\n\r\n\t\t// TODO: should this be doing SAT against the AABB?\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\r\n\t\taabbBounds.min = min.x;\r\n\t\taabbBounds.max = max.x;\r\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.y;\r\n\t\taabbBounds.max = max.y;\r\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.z;\r\n\t\taabbBounds.max = max.z;\r\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\taabbBounds.setFromBox( axis, box );\r\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri = new ExtendedTriangle();\r\n\tconst pointsArr = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\treturn function intersectsTriangle( triangle ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! triangle.isExtendedTriangle ) {\r\n\r\n\t\t\tsaTri.copy( triangle );\r\n\t\t\tsaTri.update();\r\n\t\t\ttriangle = saTri;\r\n\r\n\t\t} else if ( triangle.needsUpdate ) {\r\n\r\n\t\t\ttriangle.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\r\n\t\tpointsArr[ 0 ] = triangle.a;\r\n\t\tpointsArr[ 1 ] = triangle.b;\r\n\t\tpointsArr[ 2 ] = triangle.c;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst sa = satAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\tconst triSatBounds = triangle.satBounds;\r\n\t\tconst triSatAxes = triangle.satAxes;\r\n\t\tconst points = this.points;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = triSatBounds[ i ];\r\n\t\t\tconst sa = triSatAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check crossed axes\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sa1 = satAxes[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\r\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\r\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\r\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.closestPointToPoint = ( function () {\r\n\r\n\treturn function closestPointToPoint( point, target1 ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\ttarget1\r\n\t\t\t.copy( point )\r\n\t\t\t.applyMatrix4( this.invMatrix )\r\n\t\t\t.clamp( this.min, this.max )\r\n\t\t\t.applyMatrix4( this.matrix );\r\n\r\n\t\treturn target1;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.distanceToBox = ( function () {\r\n\r\n\tconst xyzFields = [ 'x', 'y', 'z' ];\r\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\r\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\r\n\r\n\tconst point1 = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\r\n\t// early out if we find a value below threshold\r\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.intersectsBox( box ) ) {\r\n\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tbox.getCenter( point2 );\r\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\r\n\r\n\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tconst threshold2 = threshold * threshold;\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst points = this.points;\r\n\r\n\r\n\t\t// iterate over every edge and compare distances\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check over all these points\r\n\t\tfor ( let i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tpoint2.copy( p ).clamp( min, max );\r\n\r\n\t\t\tconst dist = p.distanceToSquared( point2 );\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( p );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate and check all line segment distances\r\n\t\tlet count = 0;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\r\n\r\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\r\n\r\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\r\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\r\n\r\n\t\t\t\t\t// get obb line segments\r\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst p1 = points[ index ];\r\n\t\t\t\t\tconst p2 = points[ index2 ];\r\n\t\t\t\t\tconst line1 = segments1[ count ];\r\n\t\t\t\t\tline1.set( p1, p2 );\r\n\r\n\r\n\t\t\t\t\t// get aabb line segments\r\n\t\t\t\t\tconst f1 = xyzFields[ i ];\r\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\r\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\r\n\t\t\t\t\tconst line2 = segments2[ count ];\r\n\t\t\t\t\tconst start = line2.start;\r\n\t\t\t\t\tconst end = line2.end;\r\n\r\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\r\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\r\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tcount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check all the other boxes point\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\r\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\r\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\r\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 12; i ++ ) {\r\n\r\n\t\t\tconst l1 = segments1[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\r\n\r\n\t\t\t\tconst l2 = segments2[ i2 ];\r\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\r\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\r\n\r\n// Ripped and modified From THREE.js Mesh raycast\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\r\nconst vA = /* @__PURE__ */ new Vector3();\r\nconst vB = /* @__PURE__ */ new Vector3();\r\nconst vC = /* @__PURE__ */ new Vector3();\r\n\r\nconst uvA = /* @__PURE__ */ new Vector2();\r\nconst uvB = /* @__PURE__ */ new Vector2();\r\nconst uvC = /* @__PURE__ */ new Vector2();\r\n\r\nconst intersectionPoint = /* @__PURE__ */ new Vector3();\r\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\r\n\r\n\tlet intersect;\r\n\tif ( side === BackSide ) {\r\n\r\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t} else {\r\n\r\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\r\n\r\n\t}\r\n\r\n\tif ( intersect === null ) return null;\r\n\r\n\tconst distance = ray.origin.distanceTo( point );\r\n\r\n\treturn {\r\n\r\n\t\tdistance: distance,\r\n\t\tpoint: point.clone(),\r\n\r\n\t};\r\n\r\n}\r\n\r\nfunction checkBufferGeometryIntersection( ray, position, uv, a, b, c, side ) {\r\n\r\n\tvA.fromBufferAttribute( position, a );\r\n\tvB.fromBufferAttribute( position, b );\r\n\tvC.fromBufferAttribute( position, c );\r\n\r\n\tconst intersection = checkIntersection( ray, vA, vB, vC, intersectionPoint, side );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tif ( uv ) {\r\n\r\n\t\t\tuvA.fromBufferAttribute( uv, a );\r\n\t\t\tuvB.fromBufferAttribute( uv, b );\r\n\t\t\tuvC.fromBufferAttribute( uv, c );\r\n\r\n\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst face = {\r\n\t\t\ta: a,\r\n\t\t\tb: b,\r\n\t\t\tc: c,\r\n\t\t\tnormal: new Vector3(),\r\n\t\t\tmaterialIndex: 0\r\n\t\t};\r\n\r\n\t\tTriangle.getNormal( vA, vB, vC, face.normal );\r\n\r\n\t\tintersection.face = face;\r\n\t\tintersection.faceIndex = a;\r\n\r\n\t}\r\n\r\n\treturn intersection;\r\n\r\n}\r\n\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\r\nfunction intersectTri( geo, side, ray, tri, intersections ) {\r\n\r\n\tconst triOffset = tri * 3;\r\n\tconst a = geo.index.getX( triOffset );\r\n\tconst b = geo.index.getX( triOffset + 1 );\r\n\tconst c = geo.index.getX( triOffset + 2 );\r\n\r\n\tconst intersection = checkBufferGeometryIntersection( ray, geo.attributes.position, geo.attributes.uv, a, b, c, side );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tintersection.faceIndex = tri;\r\n\t\tif ( intersections ) intersections.push( intersection );\r\n\t\treturn intersection;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n}\r\n\r\nexport { intersectTri };\r\n","import { intersectTri } from './ThreeRayIntersectUtilities.js';\n\nexport function intersectTris( geo, side, ray, offset, count, intersections ) {\n\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tintersectTri( geo, side, ray, i, intersections );\n\n\t}\n\n}\n\nexport function intersectClosestTri( geo, side, ray, offset, count ) {\n\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tconst intersection = intersectTri( geo, side, ray, i );\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n","\r\nimport { Vector2, Vector3, Triangle } from 'three';\r\n\r\n// sets the vertices of triangle `tri` with the 3 vertices after i\r\nexport function setTriangle( tri, i, index, pos ) {\r\n\r\n\tconst ta = tri.a;\r\n\tconst tb = tri.b;\r\n\tconst tc = tri.c;\r\n\r\n\tlet i0 = i;\r\n\tlet i1 = i + 1;\r\n\tlet i2 = i + 2;\r\n\tif ( index ) {\r\n\r\n\t\ti0 = index.getX( i );\r\n\t\ti1 = index.getX( i + 1 );\r\n\t\ti2 = index.getX( i + 2 );\r\n\r\n\t}\r\n\r\n\tta.x = pos.getX( i0 );\r\n\tta.y = pos.getY( i0 );\r\n\tta.z = pos.getZ( i0 );\r\n\r\n\ttb.x = pos.getX( i1 );\r\n\ttb.y = pos.getY( i1 );\r\n\ttb.z = pos.getZ( i1 );\r\n\r\n\ttc.x = pos.getX( i2 );\r\n\ttc.y = pos.getY( i2 );\r\n\ttc.z = pos.getZ( i2 );\r\n\r\n}\r\n\r\nexport function iterateOverTriangles(\r\n\toffset,\r\n\tcount,\r\n\tgeometry,\r\n\tintersectsTriangleFunc,\r\n\tcontained,\r\n\tdepth,\r\n\ttriangle\r\n) {\r\n\r\n\tconst index = geometry.index;\r\n\tconst pos = geometry.attributes.position;\r\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\r\n\r\n\t\tsetTriangle( triangle, i * 3, index, pos );\r\n\t\ttriangle.needsUpdate = true;\r\n\r\n\t\tif ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\nconst tempV1 = /* @__PURE__ */ new Vector3();\r\nconst tempV2 = /* @__PURE__ */ new Vector3();\r\nconst tempV3 = /* @__PURE__ */ new Vector3();\r\nconst tempUV1 = /* @__PURE__ */ new Vector2();\r\nconst tempUV2 = /* @__PURE__ */ new Vector2();\r\nconst tempUV3 = /* @__PURE__ */ new Vector2();\r\n\r\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\r\n\r\n\tconst indices = geometry.getIndex().array;\r\n\tconst positions = geometry.getAttribute( 'position' );\r\n\tconst uvs = geometry.getAttribute( 'uv' );\r\n\r\n\tconst a = indices[ triangleIndex * 3 ];\r\n\tconst b = indices[ triangleIndex * 3 + 1 ];\r\n\tconst c = indices[ triangleIndex * 3 + 2 ];\r\n\r\n\ttempV1.fromBufferAttribute( positions, a );\r\n\ttempV2.fromBufferAttribute( positions, b );\r\n\ttempV3.fromBufferAttribute( positions, c );\r\n\r\n\t// find the associated material index\r\n\tlet materialIndex = 0;\r\n\tconst groups = geometry.groups;\r\n\tconst firstVertexIndex = triangleIndex * 3;\r\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\t\tconst { start, count } = group;\r\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\r\n\r\n\t\t\tmaterialIndex = group.materialIndex;\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// extract uvs\r\n\tlet uv = null;\r\n\tif ( uvs ) {\r\n\r\n\t\ttempUV1.fromBufferAttribute( uvs, a );\r\n\t\ttempUV2.fromBufferAttribute( uvs, b );\r\n\t\ttempUV3.fromBufferAttribute( uvs, c );\r\n\r\n\t\tif ( target && target.uv ) uv = target.uv;\r\n\t\telse uv = new Vector2();\r\n\r\n\t\tTriangle.getUV( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\r\n\r\n\t}\r\n\r\n\t// adjust the provided target or create a new one\r\n\tif ( target ) {\r\n\r\n\t\tif ( ! target.face ) target.face = { };\r\n\t\ttarget.face.a = a;\r\n\t\ttarget.face.b = b;\r\n\t\ttarget.face.c = c;\r\n\t\ttarget.face.materialIndex = materialIndex;\r\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\r\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\r\n\r\n\t\tif ( ! target.uv ) target.uv = new Vector2();\r\n\t\ttarget.uv.copy( uv );\r\n\r\n\t\treturn target;\r\n\r\n\t} else {\r\n\r\n\t\treturn {\r\n\t\t\tface: {\r\n\t\t\t\ta: a,\r\n\t\t\t\tb: b,\r\n\t\t\t\tc: c,\r\n\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\r\n\t\t\t},\r\n\t\t\tuv: uv\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","export class PrimitivePool {\r\n\r\n\tconstructor( getNewPrimitive ) {\r\n\r\n\t\tthis._getNewPrimitive = getNewPrimitive;\r\n\t\tthis._primitives = [];\r\n\r\n\t}\r\n\r\n\tgetPrimitive() {\r\n\r\n\t\tconst primitives = this._primitives;\r\n\t\tif ( primitives.length === 0 ) {\r\n\r\n\t\t\treturn this._getNewPrimitive();\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn primitives.pop();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treleasePrimitive( primitive ) {\r\n\r\n\t\tthis._primitives.push( primitive );\r\n\r\n\t}\r\n\r\n}\r\n","export function IS_LEAF( n16, uint16Array ) {\r\n\r\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\r\n\r\n}\r\n\r\nexport function OFFSET( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 6 ];\r\n\r\n}\r\n\r\nexport function COUNT( n16, uint16Array ) {\r\n\r\n\treturn uint16Array[ n16 + 14 ];\r\n\r\n}\r\n\r\nexport function LEFT_NODE( n32 ) {\r\n\r\n\treturn n32 + 8;\r\n\r\n}\r\n\r\nexport function RIGHT_NODE( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 6 ];\r\n\r\n}\r\n\r\nexport function SPLIT_AXIS( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 7 ];\r\n\r\n}\r\n\r\nexport function BOUNDING_DATA_INDEX( n32 ) {\r\n\r\n\treturn n32;\r\n\r\n}\r\n","import { Box3, Vector3, Matrix4 } from 'three';\r\nimport { CONTAINED } from './Constants.js';\r\n\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\r\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\r\nimport { setTriangle } from '../utils/TriangleUtilities.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\r\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\r\n\r\nconst boundingBox = new Box3();\r\nconst boxIntersection = new Vector3();\r\nconst xyzFields = [ 'x', 'y', 'z' ];\r\n\r\nexport function raycast( nodeIndex32, geometry, side, ray, intersects ) {\r\n\r\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\tintersectTris( geometry, side, ray, offset, count, intersects );\r\n\r\n\t} else {\r\n\r\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\r\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\r\n\r\n\t\t\traycast( leftIndex, geometry, side, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\r\n\r\n\t\t\traycast( rightIndex, geometry, side, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function raycastFirst( nodeIndex32, geometry, side, ray ) {\r\n\r\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\r\n\r\n\t} else {\r\n\r\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\r\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\r\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\r\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\r\n\t\tconst rayDir = ray.direction[ xyzAxis ];\r\n\t\tconst leftToRight = rayDir >= 0;\r\n\r\n\t\t// c1 is the child to check first\r\n\t\tlet c1, c2;\r\n\t\tif ( leftToRight ) {\r\n\r\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\r\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\r\n\r\n\t\t}\r\n\r\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\r\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\r\n\r\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\r\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\r\n\t\tif ( c1Result ) {\r\n\r\n\t\t\t// check if the point is within the second bounds\r\n\t\t\t// \"point\" is in the local frame of the bvh\r\n\t\t\tconst point = c1Result.point[ xyzAxis ];\r\n\t\t\tconst isOutside = leftToRight ?\r\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\r\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\r\n\r\n\t\t\tif ( isOutside ) {\r\n\r\n\t\t\t\treturn c1Result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// either there was no intersection in the first node, or there could still be a closer\r\n\t\t// intersection in the second, so check the second node and then take the better of the two\r\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\r\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\r\n\r\n\t\tif ( c1Result && c2Result ) {\r\n\r\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn c1Result || c2Result || null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport const shapecast = ( function () {\r\n\r\n\tlet _box1, _box2;\r\n\tconst boxStack = [];\r\n\tconst boxPool = new PrimitivePool( () => new Box3() );\r\n\r\n\treturn function shapecast( ...args ) {\r\n\r\n\t\t_box1 = boxPool.getPrimitive();\r\n\t\t_box2 = boxPool.getPrimitive();\r\n\t\tboxStack.push( _box1, _box2 );\r\n\r\n\t\tconst result = shapecastTraverse( ...args );\r\n\r\n\t\tboxPool.releasePrimitive( _box1 );\r\n\t\tboxPool.releasePrimitive( _box2 );\r\n\t\tboxStack.pop();\r\n\t\tboxStack.pop();\r\n\r\n\t\tconst length = boxStack.length;\r\n\t\tif ( length > 0 ) {\r\n\r\n\t\t\t_box2 = boxStack[ length - 1 ];\r\n\t\t\t_box1 = boxStack[ length - 2 ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\tfunction shapecastTraverse(\r\n\t\tnodeIndex32,\r\n\t\tgeometry,\r\n\t\tintersectsBoundsFunc,\r\n\t\tintersectsRangeFunc,\r\n\t\tnodeScoreFunc = null,\r\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\r\n\t\tdepth = 0\r\n\t) {\r\n\r\n\t\t// Define these inside the function so it has access to the local variables needed\r\n\t\t// when converting to the buffer equivalents\r\n\t\tfunction getLeftOffset( nodeIndex32 ) {\r\n\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\r\n\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\t\t// adjust offset to point to the right node\r\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// return the end offset of the triangle range\r\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t}\r\n\r\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\r\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\r\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tlet c1 = left;\r\n\t\t\tlet c2 = right;\r\n\r\n\t\t\tlet score1, score2;\r\n\t\t\tlet box1, box2;\r\n\t\t\tif ( nodeScoreFunc ) {\r\n\r\n\t\t\t\tbox1 = _box1;\r\n\t\t\t\tbox2 = _box2;\r\n\r\n\t\t\t\t// bounding data is not offset\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\r\n\r\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\r\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\r\n\r\n\t\t\t\tif ( score2 < score1 ) {\r\n\r\n\t\t\t\t\tc1 = right;\r\n\t\t\t\t\tc2 = left;\r\n\r\n\t\t\t\t\tconst temp = score1;\r\n\t\t\t\t\tscore1 = score2;\r\n\t\t\t\t\tscore2 = temp;\r\n\r\n\t\t\t\t\tbox1 = box2;\r\n\t\t\t\t\t// box2 is always set before use below\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check box 1 intersection\r\n\t\t\tif ( ! box1 ) {\r\n\r\n\t\t\t\tbox1 = _box1;\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\r\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\r\n\r\n\t\t\tlet c1StopTraversal;\r\n\t\t\tif ( c1Intersection === CONTAINED ) {\r\n\r\n\t\t\t\tconst offset = getLeftOffset( c1 );\r\n\t\t\t\tconst end = getRightEndOffset( c1 );\r\n\t\t\t\tconst count = end - offset;\r\n\r\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc1StopTraversal =\r\n\t\t\t\t\tc1Intersection &&\r\n\t\t\t\t\tshapecastTraverse(\r\n\t\t\t\t\t\tc1,\r\n\t\t\t\t\t\tgeometry,\r\n\t\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\t\tdepth + 1\r\n\t\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c1StopTraversal ) return true;\r\n\r\n\t\t\t// Check box 2 intersection\r\n\t\t\t// cached box2 will have been overwritten by previous traversal\r\n\t\t\tbox2 = _box2;\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\r\n\r\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\r\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\r\n\r\n\t\t\tlet c2StopTraversal;\r\n\t\t\tif ( c2Intersection === CONTAINED ) {\r\n\r\n\t\t\t\tconst offset = getLeftOffset( c2 );\r\n\t\t\t\tconst end = getRightEndOffset( c2 );\r\n\t\t\t\tconst count = end - offset;\r\n\r\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc2StopTraversal =\r\n\t\t\t\t\tc2Intersection &&\r\n\t\t\t\t\tshapecastTraverse(\r\n\t\t\t\t\t\tc2,\r\n\t\t\t\t\t\tgeometry,\r\n\t\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\t\tdepth + 1\r\n\t\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c2StopTraversal ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} )();\r\n\r\nexport const intersectsGeometry = ( function () {\r\n\r\n\tconst triangle = new ExtendedTriangle();\r\n\tconst triangle2 = new ExtendedTriangle();\r\n\tconst invertedMat = new Matrix4();\r\n\r\n\tconst obb = new OrientedBox();\r\n\tconst obb2 = new OrientedBox();\r\n\r\n\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\r\n\r\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\tif ( cachedObb === null ) {\r\n\r\n\t\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\t\tcachedObb = obb;\r\n\r\n\t\t}\r\n\r\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst thisGeometry = geometry;\r\n\t\t\tconst thisIndex = thisGeometry.index;\r\n\t\t\tconst thisPos = thisGeometry.attributes.position;\r\n\r\n\t\t\tconst index = otherGeometry.index;\r\n\t\t\tconst pos = otherGeometry.attributes.position;\r\n\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\r\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\r\n\t\t\t// here.\r\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\r\n\r\n\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\r\n\t\t\t\tobb2.matrix.copy( invertedMat );\r\n\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\r\n\r\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\r\n\r\n\t\t\t\t\tintersectsTriangle: tri => {\r\n\r\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\treturn res;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\r\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\r\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = nodeIndex32 + 8;\r\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\r\n\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\r\n\t\t\tconst leftIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( leftIntersection ) return true;\r\n\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\r\n\t\t\tconst rightIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( rightIntersection ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nfunction intersectRay( nodeIndex32, array, ray, target ) {\r\n\r\n\tarrayToBox( nodeIndex32, array, boundingBox );\r\n\treturn ray.intersectBox( boundingBox, target );\r\n\r\n}\r\n\r\nconst bufferStack = [];\r\nlet _prevBuffer;\r\nlet _float32Array;\r\nlet _uint16Array;\r\nlet _uint32Array;\r\nexport function setBuffer( buffer ) {\r\n\r\n\tif ( _prevBuffer ) {\r\n\r\n\t\tbufferStack.push( _prevBuffer );\r\n\r\n\t}\r\n\r\n\t_prevBuffer = buffer;\r\n\t_float32Array = new Float32Array( buffer );\r\n\t_uint16Array = new Uint16Array( buffer );\r\n\t_uint32Array = new Uint32Array( buffer );\r\n\r\n}\r\n\r\nexport function clearBuffer() {\r\n\r\n\t_prevBuffer = null;\r\n\t_float32Array = null;\r\n\t_uint16Array = null;\r\n\t_uint32Array = null;\r\n\r\n\tif ( bufferStack.length ) {\r\n\r\n\t\tsetBuffer( bufferStack.pop() );\r\n\r\n\t}\r\n\r\n}\r\n","import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\r\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\r\nimport { buildPackedTree } from './buildFunctions.js';\r\nimport {\r\n\traycast,\r\n\traycastFirst,\r\n\tshapecast,\r\n\tintersectsGeometry,\r\n\tsetBuffer,\r\n\tclearBuffer,\r\n} from './castFunctions.js';\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\r\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\r\n\r\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\r\n\r\nconst aabb = /* @__PURE__ */ new Box3();\r\nconst aabb2 = /* @__PURE__ */ new Box3();\r\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst obb2 = /* @__PURE__ */ new OrientedBox();\r\nconst temp = /* @__PURE__ */ new Vector3();\r\nconst temp1 = /* @__PURE__ */ new Vector3();\r\nconst temp2 = /* @__PURE__ */ new Vector3();\r\nconst temp3 = /* @__PURE__ */ new Vector3();\r\nconst temp4 = /* @__PURE__ */ new Vector3();\r\nconst tempBox = /* @__PURE__ */ new Box3();\r\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\r\n\r\nexport class MeshBVH {\r\n\r\n\tstatic serialize( bvh, options = {} ) {\r\n\r\n\t\tif ( options.isBufferGeometry ) {\r\n\r\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\r\n\r\n\t\t\treturn MeshBVH.serialize(\r\n\t\t\t\targuments[ 0 ],\r\n\t\t\t\t{\r\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tcloneBuffers: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst geometry = bvh.geometry;\r\n\t\tconst rootData = bvh._roots;\r\n\t\tconst indexAttribute = geometry.getIndex();\r\n\t\tlet result;\r\n\t\tif ( options.cloneBuffers ) {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData.map( root => root.slice() ),\r\n\t\t\t\tindex: indexAttribute.array.slice(),\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData,\r\n\t\t\t\tindex: indexAttribute.array,\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tstatic deserialize( data, geometry, options = {} ) {\r\n\r\n\t\tif ( typeof options === 'boolean' ) {\r\n\r\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\r\n\r\n\t\t\treturn MeshBVH.deserialize(\r\n\t\t\t\targuments[ 0 ],\r\n\t\t\t\targuments[ 1 ],\r\n\t\t\t\t{\r\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tsetIndex: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst { index, roots } = data;\r\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\r\n\t\tbvh._roots = roots;\r\n\r\n\t\tif ( options.setIndex ) {\r\n\r\n\t\t\tconst indexAttribute = geometry.getIndex();\r\n\t\t\tif ( indexAttribute === null ) {\r\n\r\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\r\n\t\t\t\tgeometry.setIndex( newIndex );\r\n\r\n\t\t\t} else if ( indexAttribute.array !== index ) {\r\n\r\n\t\t\t\tindexAttribute.array.set( index );\r\n\t\t\t\tindexAttribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvh;\r\n\r\n\t}\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\tstrategy: CENTER,\r\n\t\t\tmaxDepth: 40,\r\n\t\t\tmaxLeafTris: 10,\r\n\t\t\tverbose: true,\r\n\t\t\tuseSharedArrayBuffer: false,\r\n\t\t\tsetBoundingBox: true,\r\n\t\t\tonProgress: null,\r\n\r\n\t\t\t// undocumented options\r\n\r\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\r\n\t\t\t[ SKIP_GENERATION ]: false,\r\n\r\n\t\t}, options );\r\n\r\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis._roots = null;\r\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\r\n\r\n\t\t\tthis._roots = buildPackedTree( geometry, options );\r\n\r\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\r\n\r\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// retain references to the geometry so we can use them it without having to\r\n\t\t// take a geometry reference in every function.\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\trefit( nodeIndices = null ) {\r\n\r\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst indexArr = geometry.index.array;\r\n\t\tconst posAttr = geometry.attributes.position;\r\n\r\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\t\tlet byteOffset = 0;\r\n\t\tconst roots = this._roots;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer = roots[ i ];\r\n\t\t\tuint32Array = new Uint32Array( buffer );\r\n\t\t\tuint16Array = new Uint16Array( buffer );\r\n\t\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t\t_traverse( 0, byteOffset );\r\n\t\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\t\tlet minx = Infinity;\r\n\t\t\t\tlet miny = Infinity;\r\n\t\t\t\tlet minz = Infinity;\r\n\t\t\t\tlet maxx = - Infinity;\r\n\t\t\t\tlet maxy = - Infinity;\r\n\t\t\t\tlet maxz = - Infinity;\r\n\r\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst index = indexArr[ i ];\r\n\t\t\t\t\tconst x = posAttr.getX( index );\r\n\t\t\t\t\tconst y = posAttr.getY( index );\r\n\t\t\t\t\tconst z = posAttr.getZ( index );\r\n\r\n\t\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + 8;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\t\tconst offsetRight = right + byteOffset;\r\n\t\t\t\tlet forceChildren = force;\r\n\t\t\t\tlet includesLeft = false;\r\n\t\t\t\tlet includesRight = false;\r\n\r\n\t\t\t\tif ( nodeIndices ) {\r\n\r\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\r\n\t\t\t\t\t// then we assume that all children need to be updated.\r\n\t\t\t\t\tif ( ! forceChildren ) {\r\n\r\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\r\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\r\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tincludesLeft = true;\r\n\t\t\t\t\tincludesRight = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\r\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\r\n\r\n\t\t\t\tlet leftChange = false;\r\n\t\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rightChange = false;\r\n\t\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst didChange = leftChange || rightChange;\r\n\t\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn didChange;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttraverse( callback, rootIndex = 0 ) {\r\n\r\n\t\tconst buffer = this._roots[ rootIndex ];\r\n\t\tconst uint32Array = new Uint32Array( buffer );\r\n\t\tconst uint16Array = new Uint16Array( buffer );\r\n\t\t_traverse( 0 );\r\n\r\n\t\tfunction _traverse( node32Index, depth = 0 ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// TODO: use node functions here\r\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\r\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\r\n\r\n\t\t\t\tif ( ! stopTraversal ) {\r\n\r\n\t\t\t\t\t_traverse( left, depth + 1 );\r\n\t\t\t\t\t_traverse( right, depth + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Core Cast Functions */\r\n\traycast( ray, materialOrSide = FrontSide ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst intersects = [];\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\t\t\tconst startCount = intersects.length;\r\n\r\n\t\t\tsetBuffer( roots[ i ] );\r\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\r\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n\traycastFirst( ray, materialOrSide = FrontSide ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tlet closestResult = null;\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\r\n\t\t\tsetBuffer( roots[ i ] );\r\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\t\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet result = false;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tif ( callbacks instanceof Function ) {\r\n\r\n\t\t\tif ( _intersectsTriangleFunc ) {\r\n\r\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\r\n\t\t\t\t// indices here.\r\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\r\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\r\n\r\n\t\t\t\t\tconst i3 = index * 3;\r\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\r\n\r\n\t\t\t\t};\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcallbacks = {\r\n\r\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\r\n\t\t\t\tintersectsBounds: callbacks,\r\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\r\n\t\t\t\tintersectsRange: null,\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tlet {\r\n\t\t\tboundsTraverseOrder,\r\n\t\t\tintersectsBounds,\r\n\t\t\tintersectsRange,\r\n\t\t\tintersectsTriangle,\r\n\t\t} = callbacks;\r\n\r\n\t\tif ( intersectsRange && intersectsTriangle ) {\r\n\r\n\t\t\tconst originalIntersectsRange = intersectsRange;\r\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\r\n\r\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t};\r\n\r\n\t\t} else if ( ! intersectsRange ) {\r\n\r\n\t\t\tif ( intersectsTriangle ) {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\r\n\r\n\t\t\t\t\treturn contained;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet result = false;\r\n\t\tlet byteOffset = 0;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += root.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\r\n\r\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\r\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\r\n\r\n\t\tlet {\r\n\t\t\tintersectsRanges,\r\n\t\t\tintersectsTriangles,\r\n\t\t} = callbacks;\r\n\r\n\t\tconst indexAttr = this.geometry.index;\r\n\t\tconst positionAttr = this.geometry.attributes.position;\r\n\r\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\r\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\r\n\r\n\t\ttempMatrix.copy( matrixToLocal ).invert();\r\n\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tconst triangle2 = trianglePool.getPrimitive();\r\n\r\n\t\tif ( intersectsTriangles ) {\r\n\r\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\r\n\r\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\r\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\r\n\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( intersectsRanges ) {\r\n\r\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\r\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\totherBvh.getBoundingBox( aabb2 );\r\n\t\taabb2.applyMatrix4( matrixToLocal );\r\n\t\tconst result = this.shapecast( {\r\n\r\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\r\n\r\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\r\n\r\n\t\t\t\taabb.copy( box );\r\n\t\t\t\taabb.applyMatrix4( tempMatrix );\r\n\t\t\t\treturn otherBvh.shapecast( {\r\n\r\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\r\n\r\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\r\n\r\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\t\ttrianglePool.releasePrimitive( triangle2 );\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/* Derived Cast Functions */\r\n\tintersectsBox( box, boxToMesh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToMesh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst pos = geometry.attributes.position;\r\n\t\tconst index = geometry.index;\r\n\t\tconst otherPos = otherGeometry.attributes.position;\r\n\t\tconst otherIndex = otherGeometry.index;\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tconst triangle2 = trianglePool.getPrimitive();\r\n\r\n\t\tlet tempTarget1 = temp1;\r\n\t\tlet tempTargetDest1 = temp2;\r\n\t\tlet tempTarget2 = null;\r\n\t\tlet tempTargetDest2 = null;\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttempTarget2 = temp3;\r\n\t\t\ttempTargetDest2 = temp4;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tlet closestDistanceTriIndex = null;\r\n\t\tlet closestDistanceOtherTriIndex = null;\r\n\t\ttempMatrix.copy( geometryToBvh ).invert();\r\n\t\tobb2.matrix.copy( tempMatrix );\r\n\t\tthis.shapecast(\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\treturn obb.distanceToBox( box );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\r\n\r\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\r\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\r\n\t\t\t\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\r\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\r\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsRange: ( offset, count ) => {\r\n\r\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\r\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\r\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\r\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\r\n\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\r\n\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\r\n\r\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\r\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\r\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\r\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\t\ttrianglePool.releasePrimitive( triangle2 );\r\n\r\n\t\tif ( closestDistance === Infinity ) return null;\r\n\r\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\r\n\t\telse target1.point.copy( tempTargetDest1 );\r\n\t\ttarget1.distance = closestDistance,\r\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\r\n\t\t\telse target2.point.copy( tempTargetDest2 );\r\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\r\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\r\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\r\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\r\n\r\n\t\t}\r\n\r\n\t\treturn target1;\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\t// early out if under minThreshold\r\n\t\t// skip checking if over maxThreshold\r\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t\t// returns Infinity if no value found\r\n\t\tconst minThresholdSq = minThreshold * minThreshold;\r\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\t\tlet closestDistanceTriIndex = null;\r\n\t\tthis.shapecast(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\r\n\t\t\t\t\treturn temp.distanceToSquared( point );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\r\n\r\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\r\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\ttemp1.copy( temp );\r\n\t\t\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\tif ( closestDistanceSq === Infinity ) return null;\r\n\r\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\r\n\r\n\t\tif ( ! target.point ) target.point = temp1.clone();\r\n\t\telse target.point.copy( temp1 );\r\n\t\ttarget.distance = closestDistance,\r\n\t\ttarget.faceIndex = closestDistanceTriIndex;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\ttarget.makeEmpty();\r\n\r\n\t\tconst roots = this._roots;\r\n\t\troots.forEach( buffer => {\r\n\r\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\r\n\t\t\ttarget.union( tempBox );\r\n\r\n\t\t} );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n","import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\n\r\nconst boundingBox = /* @__PURE__ */ new Box3();\r\nclass MeshBVHRootVisualizer extends Object3D {\r\n\r\n\tget isMesh() {\r\n\r\n\t\treturn ! this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLineSegments() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLine() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, material, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.material = material;\r\n\t\tthis.geometry = new BufferGeometry();\r\n\t\tthis.name = 'MeshBVHRootVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._group = group;\r\n\r\n\t}\r\n\r\n\traycast() {}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\r\n\t\tconst group = this._group;\r\n\t\tgeometry.dispose();\r\n\t\tthis.visible = false;\r\n\t\tif ( boundsTree ) {\r\n\r\n\t\t\t// count the number of bounds required\r\n\t\t\tconst targetDepth = this.depth - 1;\r\n\t\t\tconst displayParents = this.displayParents;\r\n\t\t\tlet boundsCount = 0;\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\r\n\r\n\t\t\t\tif ( depth === targetDepth || isLeaf ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else if ( displayParents ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\t// fill in the position buffer with the bounds corners\r\n\t\t\tlet posIndex = 0;\r\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\r\n\r\n\t\t\t\tconst terminate = depth === targetDepth || isLeaf;\r\n\t\t\t\tif ( terminate || displayParents ) {\r\n\r\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\r\n\r\n\t\t\t\t\tconst { min, max } = boundingBox;\r\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\r\n\r\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\r\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\r\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\r\n\r\n\t\t\t\t\t\t\t\tposIndex += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn terminate;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\tlet indexArray;\r\n\t\t\tlet indices;\r\n\t\t\tif ( this.displayEdges ) {\r\n\r\n\t\t\t\t// fill in the index buffer to point to the corner points\r\n\t\t\t\tindices = new Uint8Array( [\r\n\t\t\t\t\t// x axis\r\n\t\t\t\t\t0, 4,\r\n\t\t\t\t\t1, 5,\r\n\t\t\t\t\t2, 6,\r\n\t\t\t\t\t3, 7,\r\n\r\n\t\t\t\t\t// y axis\r\n\t\t\t\t\t0, 2,\r\n\t\t\t\t\t1, 3,\r\n\t\t\t\t\t4, 6,\r\n\t\t\t\t\t5, 7,\r\n\r\n\t\t\t\t\t// z axis\r\n\t\t\t\t\t0, 1,\r\n\t\t\t\t\t2, 3,\r\n\t\t\t\t\t4, 5,\r\n\t\t\t\t\t6, 7,\r\n\t\t\t\t] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindices = new Uint8Array( [\r\n\r\n\t\t\t\t\t// X-, X+\r\n\t\t\t\t\t0, 1, 2,\r\n\t\t\t\t\t2, 1, 3,\r\n\r\n\t\t\t\t\t4, 6, 5,\r\n\t\t\t\t\t6, 7, 5,\r\n\r\n\t\t\t\t\t// Y-, Y+\r\n\t\t\t\t\t1, 4, 5,\r\n\t\t\t\t\t0, 4, 1,\r\n\r\n\t\t\t\t\t2, 3, 6,\r\n\t\t\t\t\t3, 7, 6,\r\n\r\n\t\t\t\t\t// Z-, Z+\r\n\t\t\t\t\t0, 2, 4,\r\n\t\t\t\t\t2, 6, 4,\r\n\r\n\t\t\t\t\t1, 5, 3,\r\n\t\t\t\t\t3, 5, 7,\r\n\r\n\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( positionArray.length > 65535 ) {\r\n\r\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst indexLength = indices.length;\r\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\r\n\r\n\t\t\t\tconst posOffset = i * 8;\r\n\t\t\t\tconst indexOffset = i * indexLength;\r\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\r\n\r\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the geometry\r\n\t\t\tgeometry.setIndex(\r\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\r\n\t\t\t);\r\n\t\t\tgeometry.setAttribute(\r\n\t\t\t\t'position',\r\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\r\n\t\t\t);\r\n\t\t\tthis.visible = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHVisualizer extends Group {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.edgeMaterial.color;\r\n\r\n\t}\r\n\r\n\tget opacity() {\r\n\r\n\t\treturn this.edgeMaterial.opacity;\r\n\r\n\t}\r\n\r\n\tset opacity( v ) {\r\n\r\n\t\tthis.edgeMaterial.opacity = v;\r\n\t\tthis.meshMaterial.opacity = v;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, depth = 10 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.name = 'MeshBVHVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._roots = [];\r\n\r\n\t\tconst edgeMaterial = new LineBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tconst meshMaterial = new MeshBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tmeshMaterial.color = edgeMaterial.color;\r\n\r\n\t\tthis.edgeMaterial = edgeMaterial;\r\n\t\tthis.meshMaterial = meshMaterial;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this.mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tconst root = this._roots.pop();\r\n\t\t\troot.geometry.dispose();\r\n\t\t\tthis.remove( root );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst root = this._roots[ i ];\r\n\t\t\troot.depth = this.depth;\r\n\t\t\troot.mesh = this.mesh;\r\n\t\t\troot.displayParents = this.displayParents;\r\n\t\t\troot.displayEdges = this.displayEdges;\r\n\t\t\troot.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\r\n\t\t\troot.update();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld( ...args ) {\r\n\r\n\t\tthis.position.copy( this.mesh.position );\r\n\t\tthis.rotation.copy( this.mesh.rotation );\r\n\t\tthis.scale.copy( this.mesh.scale );\r\n\r\n\t\tsuper.updateMatrixWorld( ...args );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.depth = source.depth;\r\n\t\tthis.mesh = source.mesh;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.edgeMaterial.dispose();\r\n\t\tthis.meshMaterial.dispose();\r\n\r\n\t\tconst children = this.children;\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].geometry.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { MeshBVHVisualizer };\r\n","import { Box3, Vector3 } from 'three';\r\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\n\r\nconst _box1 = /* @__PURE__ */ new Box3();\r\nconst _box2 = /* @__PURE__ */ new Box3();\r\nconst _vec = /* @__PURE__ */ new Vector3();\r\n\r\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\r\nfunction getPrimitiveSize( el ) {\r\n\r\n\tswitch ( typeof el ) {\r\n\r\n\t\tcase 'number':\r\n\t\t\treturn 8;\r\n\t\tcase 'string':\r\n\t\t\treturn el.length * 2;\r\n\t\tcase 'boolean':\r\n\t\t\treturn 4;\r\n\t\tdefault:\r\n\t\t\treturn 0;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction isTypedArray( arr ) {\r\n\r\n\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\r\n\treturn regex.test( arr.constructor.name );\r\n\r\n}\r\n\r\nfunction getRootExtremes( bvh, group ) {\r\n\r\n\tconst result = {\r\n\t\tnodeCount: 0,\r\n\t\tleafNodeCount: 0,\r\n\r\n\t\tdepth: {\r\n\t\t\tmin: Infinity, max: - Infinity\r\n\t\t},\r\n\t\ttris: {\r\n\t\t\tmin: Infinity, max: - Infinity\r\n\t\t},\r\n\t\tsplits: [ 0, 0, 0 ],\r\n\t\tsurfaceAreaScore: 0,\r\n\t};\r\n\r\n\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\r\n\r\n\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\r\n\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\r\n\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\r\n\r\n\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\r\n\r\n\t\tresult.nodeCount ++;\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tresult.leafNodeCount ++;\r\n\r\n\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\r\n\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\r\n\r\n\t\t\tresult.tris.min = Math.min( count, result.tris.min );\r\n\t\t\tresult.tris.max = Math.max( count, result.tris.max );\r\n\r\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult.splits[ offsetOrSplit ] ++;\r\n\r\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\r\n\r\n\t\t}\r\n\r\n\t}, group );\r\n\r\n\t// If there are no leaf nodes because the tree hasn't finished generating yet.\r\n\tif ( result.tris.min === Infinity ) {\r\n\r\n\t\tresult.tris.min = 0;\r\n\t\tresult.tris.max = 0;\r\n\r\n\t}\r\n\r\n\tif ( result.depth.min === Infinity ) {\r\n\r\n\t\tresult.depth.min = 0;\r\n\t\tresult.depth.max = 0;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction getBVHExtremes( bvh ) {\r\n\r\n\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\r\n\r\n}\r\n\r\nfunction estimateMemoryInBytes( obj ) {\r\n\r\n\tconst traversed = new Set();\r\n\tconst stack = [ obj ];\r\n\tlet bytes = 0;\r\n\r\n\twhile ( stack.length ) {\r\n\r\n\t\tconst curr = stack.pop();\r\n\t\tif ( traversed.has( curr ) ) {\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\ttraversed.add( curr );\r\n\r\n\t\tfor ( let key in curr ) {\r\n\r\n\t\t\tif ( ! curr.hasOwnProperty( key ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbytes += getPrimitiveSize( key );\r\n\r\n\t\t\tconst value = curr[ key ];\r\n\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\r\n\r\n\t\t\t\tif ( isTypedArray( value ) ) {\r\n\r\n\t\t\t\t\tbytes += value.byteLength;\r\n\r\n\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\r\n\r\n\t\t\t\t\tbytes += value.byteLength;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstack.push( value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbytes += getPrimitiveSize( value );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn bytes;\r\n\r\n}\r\n\r\nfunction validateBounds( bvh ) {\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tconst depthStack = [];\r\n\tconst index = geometry.index;\r\n\tconst position = geometry.getAttribute( 'position' );\r\n\tlet passes = true;\r\n\r\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\tconst info = {\r\n\t\t\tdepth,\r\n\t\t\tisLeaf,\r\n\t\t\tboundingData,\r\n\t\t\toffset,\r\n\t\t\tcount,\r\n\t\t};\r\n\t\tdepthStack[ depth ] = info;\r\n\r\n\t\tarrayToBox( 0, boundingData, _box1 );\r\n\t\tconst parent = depthStack[ depth - 1 ];\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\t// check triangles\r\n\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\tconst i0 = index.getX( i );\r\n\t\t\t\tconst i1 = index.getX( i + 1 );\r\n\t\t\t\tconst i2 = index.getX( i + 2 );\r\n\r\n\t\t\t\tlet isContained;\r\n\r\n\t\t\t\t_vec.fromBufferAttribute( position, i0 );\r\n\t\t\t\tisContained = _box1.containsPoint( _vec );\r\n\r\n\t\t\t\t_vec.fromBufferAttribute( position, i1 );\r\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\r\n\r\n\t\t\t\t_vec.fromBufferAttribute( position, i2 );\r\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\r\n\r\n\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\r\n\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( parent ) {\r\n\r\n\t\t\t// check if my bounds fit in my parents\r\n\t\t\tarrayToBox( 0, boundingData, _box2 );\r\n\r\n\t\t\tconst isContained = _box2.containsBox( _box1 );\r\n\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\r\n\t\t\tpasses = passes && isContained;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn passes;\r\n\r\n}\r\n\r\n// Returns a simple, human readable object that represents the BVH.\r\nfunction getJSONStructure( bvh ) {\r\n\r\n\tconst depthStack = [];\r\n\r\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\tconst info = {\r\n\t\t\tbounds: arrayToBox( 0, boundingData, new Box3() ),\r\n\t\t};\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tinfo.count = count;\r\n\t\t\tinfo.offset = offset;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinfo.left = null;\r\n\t\t\tinfo.right = null;\r\n\r\n\t\t}\r\n\r\n\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t// traversal hits the left then right node\r\n\t\tconst parent = depthStack[ depth - 1 ];\r\n\t\tif ( parent ) {\r\n\r\n\t\t\tif ( parent.left === null ) {\r\n\r\n\t\t\t\tparent.left = info;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tparent.right = info;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn depthStack[ 0 ];\r\n\r\n}\r\n\r\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };\r\n","import { Ray, Matrix4, Mesh } from 'three';\r\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\r\nimport { MeshBVH } from '../core/MeshBVH.js';\r\n\r\nconst ray = /* @__PURE__ */ new Ray();\r\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\r\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\r\n\r\nexport function acceleratedRaycast( raycaster, intersects ) {\r\n\r\n\tif ( this.geometry.boundsTree ) {\r\n\r\n\t\tif ( this.material === undefined ) return;\r\n\r\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\r\n\r\n\t\tconst bvh = this.geometry.boundsTree;\r\n\t\tif ( raycaster.firstHitOnly === true ) {\r\n\r\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\r\n\t\t\tif ( hit ) {\r\n\r\n\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst hits = bvh.raycast( ray, this.material );\r\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\r\n\t\t\t\tif ( hit ) {\r\n\r\n\t\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function computeBoundsTree( options ) {\r\n\r\n\tthis.boundsTree = new MeshBVH( this, options );\r\n\treturn this.boundsTree;\r\n\r\n}\r\n\r\nexport function disposeBoundsTree() {\r\n\r\n\tthis.boundsTree = null;\r\n\r\n}\r\n","import {\r\n\tDataTexture,\r\n\tFloatType,\r\n\tIntType,\r\n\tUnsignedIntType,\r\n\tByteType,\r\n\tUnsignedByteType,\r\n\tShortType,\r\n\tUnsignedShortType,\r\n\r\n\tRedFormat,\r\n\tRGFormat,\r\n\tRGBAFormat,\r\n\r\n\tRedIntegerFormat,\r\n\tRGIntegerFormat,\r\n\tRGBAIntegerFormat,\r\n\r\n\tNearestFilter,\r\n} from 'three';\r\n\r\nfunction countToStringFormat( count ) {\r\n\r\n\tswitch ( count ) {\r\n\r\n\t\tcase 1: return 'R';\r\n\t\tcase 2: return 'RG';\r\n\t\tcase 3: return 'RGBA';\r\n\t\tcase 4: return 'RGBA';\r\n\r\n\t}\r\n\r\n\tthrow new Error();\r\n\r\n}\r\n\r\nfunction countToFormat( count ) {\r\n\r\n\tswitch ( count ) {\r\n\r\n\t\tcase 1: return RedFormat;\r\n\t\tcase 2: return RGFormat;\r\n\t\tcase 3: return RGBAFormat;\r\n\t\tcase 4: return RGBAFormat;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction countToIntFormat( count ) {\r\n\r\n\tswitch ( count ) {\r\n\r\n\t\tcase 1: return RedIntegerFormat;\r\n\t\tcase 2: return RGIntegerFormat;\r\n\t\tcase 3: return RGBAIntegerFormat;\r\n\t\tcase 4: return RGBAIntegerFormat;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class VertexAttributeTexture extends DataTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\t\tthis.generateMipmaps = false;\r\n\t\tthis.overrideItemSize = null;\r\n\t\tthis._forcedType = null;\r\n\r\n\t}\r\n\r\n\tupdateFrom( attr ) {\r\n\r\n\t\tconst overrideItemSize = this.overrideItemSize;\r\n\t\tconst originalItemSize = attr.itemSize;\r\n\t\tconst originalCount = attr.count;\r\n\t\tif ( overrideItemSize !== null ) {\r\n\r\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattr.itemSize = overrideItemSize;\r\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\r\n\r\n\t\t}\r\n\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tconst count = attr.count;\r\n\t\tconst normalized = attr.normalized;\r\n\t\tconst originalBufferCons = attr.array.constructor;\r\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\r\n\t\tlet targetType = this._forcedType;\r\n\t\tlet finalStride = itemSize;\r\n\r\n\t\t// derive the type of texture this should be in the shader\r\n\t\tif ( targetType === null ) {\r\n\r\n\t\t\tswitch ( originalBufferCons ) {\r\n\r\n\t\t\t\tcase Float32Array:\r\n\t\t\t\t\ttargetType = FloatType;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Uint8Array:\r\n\t\t\t\tcase Uint16Array:\r\n\t\t\t\tcase Uint32Array:\r\n\t\t\t\t\ttargetType = UnsignedIntType;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Int8Array:\r\n\t\t\t\tcase Int16Array:\r\n\t\t\t\tcase Int32Array:\r\n\t\t\t\t\ttargetType = IntType;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// get the target format to store the texture as\r\n\t\tlet type, format, normalizeValue, targetBufferCons;\r\n\t\tlet internalFormat = countToStringFormat( itemSize );\r\n\t\tswitch ( targetType ) {\r\n\r\n\t\t\tcase FloatType:\r\n\t\t\t\tnormalizeValue = 1.0;\r\n\t\t\t\tformat = countToFormat( itemSize );\r\n\r\n\t\t\t\tif ( normalized && byteCount === 1 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\r\n\t\t\t\t\tinternalFormat += '8';\r\n\r\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\r\n\r\n\t\t\t\t\t\ttype = UnsignedByteType;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttype = ByteType;\r\n\t\t\t\t\t\tinternalFormat += '_SNORM';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetBufferCons = Float32Array;\r\n\t\t\t\t\tinternalFormat += '32F';\r\n\t\t\t\t\ttype = FloatType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase IntType:\r\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\r\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\r\n\t\t\t\tformat = countToIntFormat( itemSize );\r\n\r\n\t\t\t\tif ( byteCount === 1 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Int8Array;\r\n\t\t\t\t\ttype = ByteType;\r\n\r\n\t\t\t\t} else if ( byteCount === 2 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Int16Array;\r\n\t\t\t\t\ttype = ShortType;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetBufferCons = Int32Array;\r\n\t\t\t\t\ttype = IntType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase UnsignedIntType:\r\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\r\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\r\n\t\t\t\tformat = countToIntFormat( itemSize );\r\n\r\n\t\t\t\tif ( byteCount === 1 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Uint8Array;\r\n\t\t\t\t\ttype = UnsignedByteType;\r\n\r\n\t\t\t\t} else if ( byteCount === 2 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Uint16Array;\r\n\t\t\t\t\ttype = UnsignedShortType;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetBufferCons = Uint32Array;\r\n\t\t\t\t\ttype = UnsignedIntType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\t// there will be a mismatch between format length and final length because\r\n\t\t// RGBFormat and RGBIntegerFormat was removed\r\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\r\n\r\n\t\t\tfinalStride = 4;\r\n\r\n\t\t}\r\n\r\n\t\t// copy the data over to the new texture array\r\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) );\r\n\t\tconst length = finalStride * dimension * dimension;\r\n\t\tconst dataArray = new targetBufferCons( length );\r\n\t\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\t\tconst ii = finalStride * i;\r\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\r\n\r\n\t\t\tif ( itemSize >= 2 ) {\r\n\r\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( itemSize >= 3 ) {\r\n\r\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\r\n\r\n\t\t\t\tif ( finalStride === 4 ) {\r\n\r\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( itemSize >= 4 ) {\r\n\r\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.internalFormat = internalFormat;\r\n\t\tthis.format = format;\r\n\t\tthis.type = type;\r\n\t\tthis.image.width = dimension;\r\n\t\tthis.image.height = dimension;\r\n\t\tthis.image.data = dataArray;\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.dispose();\r\n\r\n\t\tattr.itemSize = originalItemSize;\r\n\t\tattr.count = originalCount;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._forcedType = UnsignedIntType;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._forcedType = IntType;\r\n\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._forcedType = FloatType;\r\n\r\n\t}\r\n\r\n}\r\n","import {\r\n\tDataTexture,\r\n\tFloatType,\r\n\tUnsignedIntType,\r\n\tRGBAFormat,\r\n\tRGIntegerFormat,\r\n\tNearestFilter,\r\n} from 'three';\r\nimport {\r\n\tFloatVertexAttributeTexture,\r\n\tUIntVertexAttributeTexture,\r\n} from './VertexAttributeTexture.js';\r\nimport { BYTES_PER_NODE } from '../core/Constants.js';\r\nimport {\r\n\tBOUNDING_DATA_INDEX,\r\n\tCOUNT,\r\n\tIS_LEAF,\r\n\tRIGHT_NODE,\r\n\tOFFSET,\r\n\tSPLIT_AXIS,\r\n} from '../core/nodeBufferFunctions.js';\r\n\r\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\r\n\r\n\tconst roots = bvh._roots;\r\n\r\n\tif ( roots.length !== 1 ) {\r\n\r\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\r\n\r\n\t}\r\n\r\n\tconst root = roots[ 0 ];\r\n\tconst uint16Array = new Uint16Array( root );\r\n\tconst uint32Array = new Uint32Array( root );\r\n\tconst float32Array = new Float32Array( root );\r\n\r\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\r\n\t// the width so we can expand the row by two and still have a square texture\r\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\r\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\r\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\r\n\r\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\r\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\r\n\r\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\r\n\r\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\r\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\r\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\r\n\t\tfor ( let b = 0; b < 3; b ++ ) {\r\n\r\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\r\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\r\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\r\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\r\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\r\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\r\n\r\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\r\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tboundsTexture.image.data = boundsArray;\r\n\tboundsTexture.image.width = boundsDimension;\r\n\tboundsTexture.image.height = boundsDimension;\r\n\tboundsTexture.format = RGBAFormat;\r\n\tboundsTexture.type = FloatType;\r\n\tboundsTexture.internalFormat = 'RGBA32F';\r\n\tboundsTexture.minFilter = NearestFilter;\r\n\tboundsTexture.magFilter = NearestFilter;\r\n\tboundsTexture.generateMipmaps = false;\r\n\tboundsTexture.needsUpdate = true;\r\n\tboundsTexture.dispose();\r\n\r\n\tcontentsTexture.image.data = contentsArray;\r\n\tcontentsTexture.image.width = contentsDimension;\r\n\tcontentsTexture.image.height = contentsDimension;\r\n\tcontentsTexture.format = RGIntegerFormat;\r\n\tcontentsTexture.type = UnsignedIntType;\r\n\tcontentsTexture.internalFormat = 'RG32UI';\r\n\tcontentsTexture.minFilter = NearestFilter;\r\n\tcontentsTexture.magFilter = NearestFilter;\r\n\tcontentsTexture.generateMipmaps = false;\r\n\tcontentsTexture.needsUpdate = true;\r\n\tcontentsTexture.dispose();\r\n\r\n}\r\n\r\nexport class MeshBVHUniformStruct {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.autoDispose = true;\r\n\t\tthis.index = new UIntVertexAttributeTexture();\r\n\t\tthis.position = new FloatVertexAttributeTexture();\r\n\t\tthis.bvhBounds = new DataTexture();\r\n\t\tthis.bvhContents = new DataTexture();\r\n\r\n\t\tthis.index.overrideItemSize = 3;\r\n\r\n\t}\r\n\r\n\tupdateFrom( bvh ) {\r\n\r\n\t\tconst { geometry } = bvh;\r\n\r\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\r\n\r\n\t\tthis.index.updateFrom( geometry.index );\r\n\t\tthis.position.updateFrom( geometry.attributes.position );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\r\n\r\n\t\tif ( index ) index.dispose();\r\n\t\tif ( position ) position.dispose();\r\n\t\tif ( bvhBounds ) bvhBounds.dispose();\r\n\t\tif ( bvhContents ) bvhContents.dispose();\r\n\r\n\t}\r\n\r\n}\r\n","export const shaderStructs = /* glsl */`\r\n#ifndef TRI_INTERSECT_EPSILON\r\n#define TRI_INTERSECT_EPSILON 1e-5\r\n#endif\r\n\r\n#ifndef INFINITY\r\n#define INFINITY 1e20\r\n#endif\r\n\r\nstruct BVH {\r\n\r\n\tusampler2D index;\r\n\tsampler2D position;\r\n\r\n\tsampler2D bvhBounds;\r\n\tusampler2D bvhContents;\r\n\r\n};\r\n\r\n// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\r\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\r\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\r\n`;\r\n\r\nexport const shaderIntersectFunction = /* glsl */`\r\n\r\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nvec4 texelFetch1D( sampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\r\n\r\n\treturn\r\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\r\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\r\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\r\n\r\n}\r\n\r\nvoid ndcToCameraRay(\r\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\r\n\tout vec3 rayOrigin, out vec3 rayDirection\r\n) {\r\n\r\n\t// get camera look direction and near plane for camera clipping\r\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\r\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\r\n\tfloat near = abs( nearVector.z / nearVector.w );\r\n\r\n\t// get the camera direction and position from camera matrices\r\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\r\n\tdirection /= direction.w;\r\n\tdirection = cameraWorld * direction - origin;\r\n\r\n\t// slide the origin along the ray until it sits at the near clip plane position\r\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\r\n\r\n\trayOrigin = origin.xyz;\r\n\trayDirection = direction.xyz;\r\n\r\n}\r\n\r\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\r\n\r\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\r\n\t// https://tavianator.com/2011/ray_box.html\r\n\tvec3 invDir = 1.0 / rayDirection;\r\n\r\n\t// find intersection distances for each plane\r\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\r\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\r\n\r\n\t// get the min and max distances from each intersection\r\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\r\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\r\n\r\n\t// get the furthest hit distance\r\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\r\n\tfloat t0 = max( t.x, t.y );\r\n\r\n\t// get the minimum hit distance\r\n\tt = min( tMaxHit.xx, tMaxHit.yz );\r\n\tfloat t1 = min( t.x, t.y );\r\n\r\n\t// set distance to 0.0 if the ray starts inside the box\r\n\tfloat dist = max( t0, 0.0 );\r\n\r\n\treturn t1 >= dist ? dist : INFINITY;\r\n\r\n}\r\n\r\nbool intersectsTriangle(\r\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\r\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\r\n) {\r\n\r\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\r\n\tvec3 edge1 = b - a;\r\n\tvec3 edge2 = c - a;\r\n\tnorm = cross( edge1, edge2 );\r\n\r\n\tfloat det = - dot( rayDirection, norm );\r\n\tfloat invdet = 1.0 / det;\r\n\r\n\tvec3 AO = rayOrigin - a;\r\n\tvec3 DAO = cross( AO, rayDirection );\r\n\r\n\tvec4 uvt;\r\n\tuvt.x = dot( edge2, DAO ) * invdet;\r\n\tuvt.y = - dot( edge1, DAO ) * invdet;\r\n\tuvt.z = dot( AO, norm ) * invdet;\r\n\tuvt.w = 1.0 - uvt.x - uvt.y;\r\n\r\n\t// set the hit information\r\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\r\n\tdist = uvt.z;\r\n\tside = sign( det );\r\n\tnorm = side * normalize( norm );\r\n\r\n\t// add an epsilon to avoid misses between triangles\r\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\r\n\r\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\r\n\r\n}\r\n\r\nbool intersectTriangles(\r\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\r\n\tinout float minDistance,\r\n\r\n\t// output variables\r\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\r\n\tout float side, out float dist\r\n) {\r\n\r\n\tbool found = false;\r\n\tvec3 localBarycoord, localNormal;\r\n\tfloat localDist, localSide;\r\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\r\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\r\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\r\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\r\n\r\n\t\tif (\r\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\r\n\t\t\t&& localDist < minDistance\r\n\t\t) {\r\n\r\n\t\t\tfound = true;\r\n\t\t\tminDistance = localDist;\r\n\r\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\r\n\t\t\tfaceNormal = localNormal;\r\n\r\n\t\t\tside = localSide;\r\n\t\t\tbarycoord = localBarycoord;\r\n\t\t\tdist = localDist;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn found;\r\n\r\n}\r\n\r\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\r\n\r\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\r\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\r\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\r\n\r\n}\r\n\r\nbool bvhIntersectFirstHit(\r\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\r\n\r\n\t// output variables\r\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\r\n\tout float side, out float dist\r\n) {\r\n\r\n\t// stack needs to be twice as long as the deepest tree we expect because\r\n\t// we push both the left and right child onto the stack every traversal\r\n\tint ptr = 0;\r\n\tuint stack[ 60 ];\r\n\tstack[ 0 ] = 0u;\r\n\r\n\tfloat triangleDistance = 1e20;\r\n\tbool found = false;\r\n\twhile ( ptr > - 1 && ptr < 60 ) {\r\n\r\n\t\tuint currNodeIndex = stack[ ptr ];\r\n\t\tptr --;\r\n\r\n\t\t// check if we intersect the current bounds\r\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\r\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\r\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\r\n\t\t\tuint offset = boundsInfo.y;\r\n\r\n\t\t\tfound = intersectTriangles(\r\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\r\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\r\n\t\t\t) || found;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuint leftIndex = currNodeIndex + 1u;\r\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\r\n\t\t\tuint rightIndex = boundsInfo.y;\r\n\r\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\r\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\r\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\r\n\r\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\r\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\r\n\t\t\t// traversed first\r\n\t\t\tptr ++;\r\n\t\t\tstack[ ptr ] = c2;\r\n\r\n\t\t\tptr ++;\r\n\t\t\tstack[ ptr ] = c1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn found;\r\n\r\n}\r\n\r\n`;\r\n","import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\r\n\r\nconst _positionVector = /*@__PURE__*/ new Vector3();\r\nconst _normalVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\r\n\r\nconst _morphVector = /*@__PURE__*/ new Vector3();\r\nconst _temp = /*@__PURE__*/ new Vector3();\r\n\r\nconst _skinIndex = /*@__PURE__*/ new Vector4();\r\nconst _skinWeight = /*@__PURE__*/ new Vector4();\r\nconst _matrix = /*@__PURE__*/ new Matrix4();\r\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\r\n\r\n// Confirms that the two provided attributes are compatible\r\nfunction validateAttributes( attr1, attr2 ) {\r\n\r\n\tif ( ! attr1 && ! attr2 ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tconst sameCount = attr1.count === attr2.count;\r\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\r\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\r\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\r\n\r\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Clones the given attribute with a new compatible buffer attribute but no data\r\nfunction createAttributeClone( attr, countOverride = null ) {\r\n\r\n\tconst cons = attr.array.constructor;\r\n\tconst normalized = attr.normalized;\r\n\tconst itemSize = attr.itemSize;\r\n\tconst count = countOverride === null ? attr.count : countOverride;\r\n\r\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\r\n\r\n}\r\n\r\n// target offset is the number of elements in the target buffer stride to skip before copying the\r\n// attributes contents in to.\r\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\r\n\r\n\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\r\n\r\n\t\t\tconst io = i + targetOffset;\r\n\t\t\ttarget.setX( io, attr.getX( i ) );\r\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\r\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\r\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconst array = target.array;\r\n\t\tconst cons = array.constructor;\r\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\r\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\r\n\t\ttemp.set( attr.array );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\r\nfunction addScaledMatrix( target, matrix, scale ) {\r\n\r\n\tconst targetArray = target.elements;\r\n\tconst matrixArray = matrix.elements;\r\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\r\n\r\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// A version of \"SkinnedMesh.boneTransform\" for normals\r\nfunction boneNormalTransform( mesh, index, target ) {\r\n\r\n\tconst skeleton = mesh.skeleton;\r\n\tconst geometry = mesh.geometry;\r\n\tconst bones = skeleton.bones;\r\n\tconst boneInverses = skeleton.boneInverses;\r\n\r\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\r\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\r\n\r\n\t_matrix.elements.fill( 0 );\r\n\r\n\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\tconst weight = _skinWeight.getComponent( i );\r\n\r\n\t\tif ( weight !== 0 ) {\r\n\r\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\r\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\r\n\r\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\r\n\ttarget.transformDirection( _matrix );\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\n// Applies the morph target data to the target vector\r\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\r\n\r\n\t_morphVector.set( 0, 0, 0 );\r\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\r\n\r\n\t\tconst influence = morphInfluences[ j ];\r\n\t\tconst morphAttribute = morphData[ j ];\r\n\r\n\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\r\n\r\n\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp, influence );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttarget.add( _morphVector );\r\n\r\n}\r\n\r\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in plac\r\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false }, targetGeometry = new BufferGeometry() ) {\r\n\r\n\tconst isIndexed = geometries[ 0 ].index !== null;\r\n\tconst { useGroups, updateIndex } = options;\r\n\r\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\r\n\tconst attributes = {};\r\n\r\n\tlet offset = 0;\r\n\r\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\tconst geometry = geometries[ i ];\r\n\t\tlet attributesCount = 0;\r\n\r\n\t\t// ensure that all geometries are indexed, or none\r\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t}\r\n\r\n\t\t// gather attributes, exit early if they're different\r\n\t\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\t\tif ( ! attributesUsed.has( name ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes[ name ] === undefined ) {\r\n\r\n\t\t\t\tattributes[ name ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\r\n\t\t\tattributesCount ++;\r\n\r\n\t\t}\r\n\r\n\t\t// ensure geometries have the same number of attributes\r\n\t\tif ( attributesCount !== attributesUsed.size ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( useGroups ) {\r\n\r\n\t\t\tlet count;\r\n\t\t\tif ( isIndexed ) {\r\n\r\n\t\t\t\tcount = geometry.index.count;\r\n\r\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\r\n\r\n\t\t\t\tcount = geometry.attributes.position.count;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.addGroup( offset, count, i );\r\n\t\t\toffset += count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// merge indices\r\n\tif ( isIndexed ) {\r\n\r\n\t\tlet forceUpateIndex = false;\r\n\t\tif ( ! targetGeometry.index ) {\r\n\r\n\t\t\tlet indexCount = 0;\r\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\t\tindexCount += geometries[ i ].index.count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\r\n\t\t\tforceUpateIndex = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateIndex || forceUpateIndex ) {\r\n\r\n\t\t\tconst targetIndex = targetGeometry.index;\r\n\t\t\tlet targetOffset = 0;\r\n\t\t\tlet indexOffset = 0;\r\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\t\tconst geometry = geometries[ i ];\r\n\t\t\t\tconst index = geometry.index;\r\n\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\r\n\r\n\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\r\n\t\t\t\t\ttargetOffset ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindexOffset += geometry.attributes.position.count;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// merge attributes\r\n\tfor ( const name in attributes ) {\r\n\r\n\t\tconst attrList = attributes[ name ];\r\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\r\n\r\n\t\t\tlet count = 0;\r\n\t\t\tfor ( const key in attrList ) {\r\n\r\n\t\t\t\tcount += attrList[ key ].count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\r\n\t\tlet offset = 0;\r\n\t\tfor ( const key in attrList ) {\r\n\r\n\t\t\tconst attr = attrList[ key ];\r\n\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\r\n\t\t\toffset += attr.count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn targetGeometry;\r\n\r\n}\r\n\r\nexport class StaticGeometryGenerator {\r\n\r\n\tconstructor( meshes ) {\r\n\r\n\t\tif ( ! Array.isArray( meshes ) ) {\r\n\r\n\t\t\tmeshes = [ meshes ];\r\n\r\n\t\t}\r\n\r\n\t\tconst finalMeshes = [];\r\n\t\tmeshes.forEach( object => {\r\n\r\n\t\t\tobject.traverse( c => {\r\n\r\n\t\t\t\tif ( c.isMesh ) {\r\n\r\n\t\t\t\t\tfinalMeshes.push( c );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.meshes = finalMeshes;\r\n\t\tthis.useGroups = true;\r\n\t\tthis.applyWorldTransforms = true;\r\n\t\tthis.attributes = [ 'position', 'normal', 'tangent', 'uv', 'uv2' ];\r\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\r\n\r\n\t}\r\n\r\n\tgetMaterials() {\r\n\r\n\t\tconst materials = [];\r\n\t\tthis.meshes.forEach( mesh => {\r\n\r\n\t\t\tif ( Array.isArray( mesh.material ) ) {\r\n\r\n\t\t\t\tmaterials.push( ...mesh.material );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterials.push( mesh.material );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\t\treturn materials;\r\n\r\n\t}\r\n\r\n\tgenerate( targetGeometry = new BufferGeometry() ) {\r\n\r\n\t\tconst { meshes, useGroups, _intermediateGeometry } = this;\r\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst mesh = meshes[ i ];\r\n\t\t\tconst geom = _intermediateGeometry[ i ];\r\n\t\t\tthis._convertToStaticGeometry( mesh, geom );\r\n\r\n\t\t}\r\n\r\n\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups }, targetGeometry );\r\n\t\tfor ( const key in targetGeometry.attributes ) {\r\n\r\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\treturn targetGeometry;\r\n\r\n\t}\r\n\r\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\r\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\r\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\r\n\t\tconst attributes = geometry.attributes;\r\n\t\tconst targetAttributes = targetGeometry.attributes;\r\n\r\n\t\t// initialize the attributes if they don't exist\r\n\t\tif ( ! targetGeometry.index ) {\r\n\r\n\t\t\ttargetGeometry.index = geometry.index;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! targetAttributes.position ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\r\n\r\n\t\t}\r\n\r\n\t\t// ensure the attributes are consistent\r\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\r\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\r\n\r\n\t\tif ( includeNormal ) {\r\n\r\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeTangent ) {\r\n\r\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\r\n\r\n\t\t}\r\n\r\n\t\t// generate transformed vertex attribute data\r\n\t\tconst position = attributes.position;\r\n\t\tconst normal = includeNormal ? attributes.normal : null;\r\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\r\n\t\tconst morphPosition = geometry.morphAttributes.position;\r\n\t\tconst morphNormal = geometry.morphAttributes.normal;\r\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\r\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\r\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\r\n\t\tconst normalMatrix = new Matrix3();\r\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\r\n\r\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\r\n\r\n\t\t\t_positionVector.fromBufferAttribute( position, i );\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\r\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// apply morph target transform\r\n\t\t\tif ( morphInfluences ) {\r\n\r\n\t\t\t\tif ( morphPosition ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( morphNormal ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( morphTangent ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// apply bone transform\r\n\t\t\tif ( mesh.isSkinnedMesh ) {\r\n\r\n\t\t\t\tmesh.boneTransform( i, _positionVector );\r\n\t\t\t\tif ( normal ) {\r\n\r\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the vectors of the attributes\r\n\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\r\n\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// copy other attributes over\r\n\t\tfor ( const i in this.attributes ) {\r\n\r\n\t\t\tconst key = this.attributes[ i ];\r\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! targetAttributes[ key ] ) {\r\n\r\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\r\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn targetGeometry;\r\n\r\n\t}\r\n\r\n}\r\n"],"names":["CENTER","AVERAGE","SAH","NOT_INTERSECTED","INTERSECTED","CONTAINED","TRIANGLE_INTERSECT_COST","BYTES_PER_NODE","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","Math","pow","MeshBVHNode","arrayToBox","nodeIndex32","array","target","min","x","y","z","max","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","Infinity","i","dist","copyBounds","source","set","unionBounds","a","b","aVal","bVal","d","d3","expandByTriangleBounds","startIndex","triangleBounds","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","getBounds","offset","count","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","end","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","partition","index","split","left","right","pos","axisOffset","axis","t0","t1","t2","BIN_COUNT","binsSort","candidate","sahBins","Array","fill","map","Float32Array","rightCacheBounds","leftCacheBounds","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","avg","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","truncatedBins","length","c","bin","sort","splitCount","bi","splice","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","console","warn","buildTree","geo","options","triggerProgress","trianglesProcessed","onProgress","totalTriangles","splitNode","node","depth","reachedMaxDepth","maxDepth","verbose","maxLeafTris","boundingData","splitOffset","indexArray","splitAxis","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","vertexCount","attributes","position","BufferConstructor","useSharedArrayBuffer","SharedArrayBuffer","ArrayBuffer","Uint32Array","Uint16Array","setIndex","BufferAttribute","ensureIndex","fullBounds","posAttr","triCount","normalized","posArr","bufferOffset","stride","isInterleavedBufferAttribute","data","getters","tri","tri3","tri6","ai","ci","el","halfExtents","el2","abs","computeTriangleBounds","roots","ranges","groups","rangeBoundaries","Set","group","add","start","sortedBoundaries","from","values","push","getRootIndexRanges","range","root","getCentroidBounds","buildPackedTree","float32Array","uint32Array","uint16Array","packedRoots","nodeCount","countNodes","buffer","populateBuffer","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","Error","SeparatingAxisBounds","this","points","field","l","val","p","dot","other","prototype","setFromBox","Vector3","box","boxMin","boxMax","cacheSatBounds","closestPointLineToLine","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","subVectors","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","Vector2","temp1","temp2","target1","target2","p2","at","closestPointToPoint","closestPoint","closestPoint2","distanceToSquared","copy","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","distanceTo","plane","getPlane","distanceToPoint","pp","projectPoint","containsPoint","isNearZero","value","ExtendedTriangle","args","isExtendedTriangle","satAxes","satBounds","Sphere","needsUpdate","axis0","sab0","getNormal","setFromPoints","axis1","sab1","axis2","sab2","axis3","sab3","setFromNormalAndCoplanarPoint","Triangle","closestPointToSegment","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","sqrt","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","tempDir","edge1","edge2","update","plane1","plane2","normal","satBounds1","satAxes1","sb","sa","isSeparated","satBounds2","satAxes2","sa1","i2","sa2","crossVectors","points1","found1","count1","pNext","delta","targetPoint","startIntersects","doesIntersect","intersectLine","points2","found2","count2","tmp","s1","e1","s2","e2","separated1","separated2","point","distanceToTriangle","cornerFields","line1","line2","lineTarget","getCenter","otherVec","thisVec","f11","f12","f21","f22","OrientedBox","isOrientedBox","matrix","Matrix4","invMatrix","alignedSatBounds","Box3","v","applyMatrix4","minVec","pi","setFromPointsField","invert","intersectsBox","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","clamp","distanceToBox","xyzFields","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","p1","f1","f2","f3","vA","vB","vC","uvA","uvB","uvC","intersectionPoint","checkBufferGeometryIntersection","ray","uv","side","fromBufferAttribute","intersection","pA","pB","pC","BackSide","intersectTriangle","DoubleSide","distance","origin","clone","checkIntersection","face","materialIndex","faceIndex","intersectTri","intersections","triOffset","getX","convertRaycastIntersect","hit","object","raycaster","matrixWorld","near","far","setTriangle","ta","tb","tc","i0","getY","getZ","iterateOverTriangles","geometry","intersectsTriangleFunc","contained","tempV1","tempV2","tempV3","tempUV1","tempUV2","tempUV3","getTriangleHitPointInfo","triangleIndex","indices","getIndex","positions","getAttribute","uvs","firstVertexIndex","PrimitivePool","getNewPrimitive","_getNewPrimitive","_primitives","primitives","pop","primitive","IS_LEAF","n16","OFFSET","n32","COUNT","LEFT_NODE","RIGHT_NODE","SPLIT_AXIS","boundingBox","boxIntersection","raycast","intersects","nodeIndex16","_float32Array","_uint16Array","_uint32Array","intersectTris","leftIndex","intersectRay","rightIndex","raycastFirst","res","intersectClosestTri","c1","c2","xyzAxis","leftToRight","direction","c1Result","c2Result","shapecast","_box1","_box2","boxStack","boxPool","getPrimitive","shapecastTraverse","releasePrimitive","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","getLeftOffset","getRightEndOffset","score1","score2","box1","box2","temp","c1StopTraversal","isC1Leaf","c1Intersection","c2StopTraversal","isC2Leaf","c2Intersection","intersectsGeometry","triangle2","invertedMat","obb","obb2","otherGeometry","geometryToBvh","cachedObb","computeBoundingBox","leftIntersection","rightIntersection","thisGeometry","thisIndex","thisPos","boundsTree","intersectsBounds","intersectBox","_prevBuffer","bufferStack","setBuffer","clearBuffer","SKIP_GENERATION","Symbol","aabb","aabb2","tempMatrix","temp3","temp4","tempBox","trianglePool","MeshBVH","isBufferGeometry","Object","assign","setBoundingBox","_roots","getBoundingBox","nodeIndices","isArray","indexArr","_traverse","byteLength","node32Index","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","callback","rootIndex","stopTraversal","materialOrSide","FrontSide","isMaterial","isArrayMaterial","materialSide","startCount","j","jl","closestResult","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","i3","boundsTraverseOrder","intersectsRange","originalIntersectsRange","nodeIndex","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","iterateOverDoubleTriangles","offset1","offset2","depth1","index1","depth2","originalIntersectsRanges","nodeIndex1","nodeIndex2","boxToMesh","intersectsSphere","minThreshold","maxThreshold","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","score","otherOffset","otherCount","sub","minThresholdSq","maxThresholdSq","triIndex","makeEmpty","forEach","union","bvh","serialize","arguments","cloneBuffers","undefined","rootData","indexAttribute","slice","deserialize","newIndex","MeshBVHRootVisualizer","mesh","material","BufferGeometry","name","displayParents","displayEdges","_group","dispose","visible","targetDepth","boundsCount","traverse","posIndex","positionArray","terminate","xVal","yVal","zVal","Uint8Array","indexLength","posOffset","indexOffset","setAttribute","Object3D","MeshBVHVisualizer","edgeMaterial","LineBasicMaterial","color","transparent","opacity","depthWrite","meshMaterial","MeshBasicMaterial","totalRoots","remove","rotation","scale","children","Group","_vec","getPrimitiveSize","getBVHExtremes","leafNodeCount","tris","splits","surfaceAreaScore","offsetOrSplit","l0","surfaceArea","getRootExtremes","estimateMemoryInBytes","obj","traversed","stack","bytes","curr","key","hasOwnProperty","test","constructor","validateBounds","depthStack","passes","info","parent","isContained","assert","containsBox","getJSONStructure","Ray","tmpInverseMatrix","origMeshRaycastFunc","Mesh","acceleratedRaycast","firstHitOnly","hits","call","computeBoundsTree","disposeBoundsTree","countToIntFormat","RedIntegerFormat","RGIntegerFormat","RGBAIntegerFormat","VertexAttributeTexture","minFilter","NearestFilter","magFilter","generateMipmaps","overrideItemSize","_forcedType","attr","originalItemSize","itemSize","originalCount","type","format","normalizeValue","targetBufferCons","originalBufferCons","byteCount","BYTES_PER_ELEMENT","targetType","finalStride","FloatType","UnsignedIntType","Int8Array","Int16Array","Int32Array","IntType","internalFormat","countToStringFormat","RedFormat","RGFormat","RGBAFormat","countToFormat","UnsignedByteType","ByteType","ShortType","UnsignedShortType","dimension","ceil","dataArray","ii","getW","image","width","height","DataTexture","UIntVertexAttributeTexture","IntVertexAttributeTexture","FloatVertexAttributeTexture","MeshBVHUniformStruct","autoDispose","bvhBounds","bvhContents","boundsTexture","contentsTexture","boundsDimension","boundsArray","contentsDimension","contentsArray","boundsIndex","mergedLeafCount","bvhToTextures","updateFrom","shaderStructs","shaderIntersectFunction","_positionVector","_normalVector","_tangentVector","_tangentVector4","Vector4","_morphVector","_temp","_skinIndex","_skinWeight","_matrix","_boneMatrix","validateAttributes","attr1","attr2","sameCount","sameNormalized","sameType","sameItemSize","createAttributeClone","countOverride","cons","copyAttributeContents","targetOffset","io","setX","setY","setZ","setW","addScaledMatrix","targetArray","elements","matrixArray","boneNormalTransform","skeleton","bones","boneInverses","skinIndex","skinWeight","weight","getComponent","boneIndex","multiplyMatrices","multiply","bindMatrix","premultiply","bindMatrixInverse","transformDirection","applyMorphTarget","morphData","morphInfluences","morphTargetsRelative","influence","morphAttribute","addScaledVector","mergeBufferGeometries","geometries","useGroups","updateIndex","targetGeometry","isIndexed","attributesUsed","keys","attributesCount","size","addGroup","forceUpateIndex","indexCount","targetIndex","attrList","targetAttribute","StaticGeometryGenerator","meshes","finalMeshes","isMesh","applyWorldTransforms","_intermediateGeometry","materials","geom","_convertToStaticGeometry","includeNormal","includes","includeTangent","targetAttributes","tangent","morphPosition","morphAttributes","morphNormal","morphTangent","morphTargetInfluences","normalMatrix","Matrix3","getNormalMatrix","isSkinnedMesh","boneTransform","setXYZ","applyNormalMatrix","setXYZW","w"],"sourceRoot":""}